{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"[IrisToolbox] Reference Manual","title":"Introduction"},{"location":"index.html#iristoolbox-reference-manual","text":"","title":"[IrisToolbox] Reference Manual"},{"location":"install.html","text":"Installing IrisT There are two basic ways to get IrisT up and running on your computer: clone the GitHub repository; or download and unpack Iris from a zip achive. Cloning the GitHub Repository Installing IrisT from a Zip Archive","title":"Installing IrisT"},{"location":"install.html#installing-irist","text":"There are two basic ways to get IrisT up and running on your computer: clone the GitHub repository; or download and unpack Iris from a zip achive.","title":"Installing IrisT"},{"location":"install.html#cloning-the-github-repository","text":"","title":"Cloning the GitHub Repository"},{"location":"install.html#installing-irist-from-a-zip-archive","text":"","title":"Installing IrisT from a Zip Archive"},{"location":"chartpack/index.html","text":"Databank Chartpacks Categorical List of Functions Constructor Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields","title":"Introduction"},{"location":"chartpack/index.html#databank-chartpacks","text":"","title":"Databank Chartpacks"},{"location":"chartpack/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"chartpack/index.html#constructor","text":"Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields","title":"Constructor"},{"location":"chartpack/Chartpack.html","text":"databank.Chartpack Create a new Chartpack object for plotting databank fields Syntax ch = databank.Chartpack() Output Arguments ch [ databank.Chartpack ] New empty databank.Chartpack object","title":"Chartpack"},{"location":"chartpack/Chartpack.html#databankchartpack","text":"Create a new Chartpack object for plotting databank fields","title":"databank.Chartpack"},{"location":"chartpack/Chartpack.html#syntax","text":"ch = databank.Chartpack()","title":"Syntax"},{"location":"chartpack/Chartpack.html#output-arguments","text":"ch [ databank.Chartpack ] New empty databank.Chartpack object","title":"Output Arguments"},{"location":"databank/index.html","text":"Databank Functions IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks. Categorical List of Functions Creating, Converting, Importing, and Exporting Databanks Function Description databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series Getting Information about Databanks Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields Processing Databanks Function Description databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields Creating Charts from Databank See Databank Chartpacks","title":"Introduction"},{"location":"databank/index.html#databank-functions","text":"IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks.","title":"Databank Functions"},{"location":"databank/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"databank/index.html#creating-converting-importing-and-exporting-databanks","text":"Function Description databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series","title":"Creating, Converting, Importing, and Exporting Databanks"},{"location":"databank/index.html#getting-information-about-databanks","text":"Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields","title":"Getting Information about Databanks"},{"location":"databank/index.html#processing-databanks","text":"Function Description databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields","title":"Processing Databanks"},{"location":"databank/index.html#creating-charts-from-databank","text":"See Databank Chartpacks","title":"Creating Charts from Databank"},{"location":"databank/apply.html","text":"databank.apply Apply function to a selection of databank fields Syntax [outputDb, appliedToNames, newNames] = apply(inputDb, func, ...) Input Arguments inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb . Output Arguments outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb . Options StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields. Description Example Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 ); Example Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"apply"},{"location":"databank/apply.html#databankapply","text":"Apply function to a selection of databank fields","title":"databank.apply"},{"location":"databank/apply.html#syntax","text":"[outputDb, appliedToNames, newNames] = apply(inputDb, func, ...)","title":"Syntax"},{"location":"databank/apply.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb .","title":"Input Arguments"},{"location":"databank/apply.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb .","title":"Output Arguments"},{"location":"databank/apply.html#options","text":"StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields.","title":"Options"},{"location":"databank/apply.html#description","text":"","title":"Description"},{"location":"databank/apply.html#example","text":"Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 );","title":"Example"},{"location":"databank/apply.html#example_1","text":"Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"Example"},{"location":"databank/clip.html","text":"databank.clip Clip all time series in databank to a new range Syntax outputDatabank = databank.clip(inputDatabank, newStart, newEnd) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered. Output Arguments outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range. Description Example Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"clip"},{"location":"databank/clip.html#databankclip","text":"Clip all time series in databank to a new range","title":"databank.clip"},{"location":"databank/clip.html#syntax","text":"outputDatabank = databank.clip(inputDatabank, newStart, newEnd)","title":"Syntax"},{"location":"databank/clip.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered.","title":"Input Arguments"},{"location":"databank/clip.html#output-arguments","text":"outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range.","title":"Output Arguments"},{"location":"databank/clip.html#description","text":"","title":"Description"},{"location":"databank/clip.html#example","text":"Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"Example"},{"location":"databank/copy.html","text":"databank.copy Copy fields of source databank to target databank Syntax targetDb = databank.copy(sourceDb, ...) Input Arguments sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb . Options SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform=[ ] [ empty | function_handle ] Transformation function applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank. Output Arguments targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over. Description Example","title":"copy"},{"location":"databank/copy.html#databankcopy","text":"Copy fields of source databank to target databank","title":"databank.copy"},{"location":"databank/copy.html#syntax","text":"targetDb = databank.copy(sourceDb, ...)","title":"Syntax"},{"location":"databank/copy.html#input-arguments","text":"sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb .","title":"Input Arguments"},{"location":"databank/copy.html#options","text":"SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform=[ ] [ empty | function_handle ] Transformation function applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank.","title":"Options"},{"location":"databank/copy.html#output-arguments","text":"targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over.","title":"Output Arguments"},{"location":"databank/copy.html#description","text":"","title":"Description"},{"location":"databank/copy.html#example","text":"","title":"Example"},{"location":"databank/eval.html","text":"databank.eval Evaluate an expression within a databank context Syntax [output, output, ...] = databank.eval(inputDatabank, expression, expression, ...) outputs = databank.eval(inputDatabank, expressions) outputDatabank = databank.eval(inputDatabank, expressionsDatabank) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDatabank fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDatabank fields. expressionsDatabank [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated. Output Arguments output [ * ] Result of the expression evaluated in the inputDatabank workspace. outputs [ cell ] Results of the expressions evaluated in the inputDatabank workspace. outputDatabank [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDatabank workspace. Description Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDatabank fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDatabank . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDatabank fields. To include round-bracket references to inputDatabank fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis. Example d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"eval"},{"location":"databank/eval.html#databankeval","text":"Evaluate an expression within a databank context","title":"databank.eval"},{"location":"databank/eval.html#syntax","text":"[output, output, ...] = databank.eval(inputDatabank, expression, expression, ...) outputs = databank.eval(inputDatabank, expressions) outputDatabank = databank.eval(inputDatabank, expressionsDatabank)","title":"Syntax"},{"location":"databank/eval.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDatabank fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDatabank fields. expressionsDatabank [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated.","title":"Input Arguments"},{"location":"databank/eval.html#output-arguments","text":"output [ * ] Result of the expression evaluated in the inputDatabank workspace. outputs [ cell ] Results of the expressions evaluated in the inputDatabank workspace. outputDatabank [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDatabank workspace.","title":"Output Arguments"},{"location":"databank/eval.html#description","text":"Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDatabank fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDatabank . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDatabank fields. To include round-bracket references to inputDatabank fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis.","title":"Description"},{"location":"databank/eval.html#example","text":"d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"Example"},{"location":"databank/fieldNames.html","text":"databank.fieldNames List of databank field names as a row vector of strings Syntax list = databank.fieldNames(db) Input Arguments db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object. Output Arguments list [ string ] List of all field names contained in the input db , arranged as a row vector of strings. Description The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop. Example d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"fieldNames"},{"location":"databank/fieldNames.html#databankfieldnames","text":"List of databank field names as a row vector of strings","title":"databank.fieldNames"},{"location":"databank/fieldNames.html#syntax","text":"list = databank.fieldNames(db)","title":"Syntax"},{"location":"databank/fieldNames.html#input-arguments","text":"db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object.","title":"Input Arguments"},{"location":"databank/fieldNames.html#output-arguments","text":"list [ string ] List of all field names contained in the input db , arranged as a row vector of strings.","title":"Output Arguments"},{"location":"databank/fieldNames.html#description","text":"The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop.","title":"Description"},{"location":"databank/fieldNames.html#example","text":"d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"Example"},{"location":"databank/filterFields.html","text":"databank.filterFields Get the names of databank fields that pass name or value tests Syntax list = databank.filterFields(inputDb, ...) Input Arguments inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values. Output Arguments list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests. Options __ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test. Description Example","title":"filterFields"},{"location":"databank/filterFields.html#databankfilterfields","text":"Get the names of databank fields that pass name or value tests","title":"databank.filterFields"},{"location":"databank/filterFields.html#syntax","text":"list = databank.filterFields(inputDb, ...)","title":"Syntax"},{"location":"databank/filterFields.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values.","title":"Input Arguments"},{"location":"databank/filterFields.html#output-arguments","text":"list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests.","title":"Output Arguments"},{"location":"databank/filterFields.html#options","text":"__ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test.","title":"Options"},{"location":"databank/filterFields.html#description","text":"","title":"Description"},{"location":"databank/filterFields.html#example","text":"","title":"Example"},{"location":"databank/fromCSV.html","text":"databank.fromCSV Create databank by loading CSV file Syntax outputDb = databank.fromCSV(fileName, ...) Input Arguments fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined. Output Arguments outputDb [ struct | Dictionary ] Database created from the input CSV file(s). Options AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series. Description Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example). Structure of CSV Data Files The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | Example Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"fromCSV"},{"location":"databank/fromCSV.html#databankfromcsv","text":"Create databank by loading CSV file","title":"databank.fromCSV"},{"location":"databank/fromCSV.html#syntax","text":"outputDb = databank.fromCSV(fileName, ...)","title":"Syntax"},{"location":"databank/fromCSV.html#input-arguments","text":"fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined.","title":"Input Arguments"},{"location":"databank/fromCSV.html#output-arguments","text":"outputDb [ struct | Dictionary ] Database created from the input CSV file(s).","title":"Output Arguments"},{"location":"databank/fromCSV.html#options","text":"AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series.","title":"Options"},{"location":"databank/fromCSV.html#description","text":"Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example).","title":"Description"},{"location":"databank/fromCSV.html#structure-of-csv-data-files","text":"The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | |","title":"Structure of CSV Data Files"},{"location":"databank/fromCSV.html#example","text":"Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"databank/list.html","text":"databank.list List databank fields adding date range to time series fields Syntax databank.list(db) Input Arguments db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields. Description Example d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"list"},{"location":"databank/list.html#databanklist","text":"List databank fields adding date range to time series fields","title":"databank.list"},{"location":"databank/list.html#syntax","text":"databank.list(db)","title":"Syntax"},{"location":"databank/list.html#input-arguments","text":"db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields.","title":"Input Arguments"},{"location":"databank/list.html#description","text":"","title":"Description"},{"location":"databank/list.html#example","text":"d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"Example"},{"location":"databank/merge.html","text":"databank.merge Merge two or more databanks Syntax outputDb = databank.merge(method, primaryDb [, otherDb ], ...) Input Arguments method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb . Output Arguments outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method . Options MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" . Description The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown. Example","title":"merge"},{"location":"databank/merge.html#databankmerge","text":"Merge two or more databanks","title":"databank.merge"},{"location":"databank/merge.html#syntax","text":"outputDb = databank.merge(method, primaryDb [, otherDb ], ...)","title":"Syntax"},{"location":"databank/merge.html#input-arguments","text":"method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb .","title":"Input Arguments"},{"location":"databank/merge.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method .","title":"Output Arguments"},{"location":"databank/merge.html#options","text":"MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" .","title":"Options"},{"location":"databank/merge.html#description","text":"The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown.","title":"Description"},{"location":"databank/merge.html#example","text":"","title":"Example"},{"location":"databank/retrieveColumns.html","text":"databank.retrieveColumns Retrieve selected columns from databank fields Syntax outputDb = function(inputDb, refs,...) Input Arguments inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd). Output Arguments outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails . Options WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb . Description Example","title":"retrieveColumns"},{"location":"databank/retrieveColumns.html#databankretrievecolumns","text":"Retrieve selected columns from databank fields","title":"databank.retrieveColumns"},{"location":"databank/retrieveColumns.html#syntax","text":"outputDb = function(inputDb, refs,...)","title":"Syntax"},{"location":"databank/retrieveColumns.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd).","title":"Input Arguments"},{"location":"databank/retrieveColumns.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails .","title":"Output Arguments"},{"location":"databank/retrieveColumns.html#options","text":"WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb .","title":"Options"},{"location":"databank/retrieveColumns.html#description","text":"","title":"Description"},{"location":"databank/retrieveColumns.html#example","text":"","title":"Example"},{"location":"databank/toCSV.html","text":"databank.toCSV Write databank to CSV file Syntax fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date. Output Arguments fieldsSaved [ string ] List of databank fields that have been written to the output file fileName . Options NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field. Description Example Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field. Example D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"toCSV"},{"location":"databank/toCSV.html#databanktocsv","text":"Write databank to CSV file","title":"databank.toCSV"},{"location":"databank/toCSV.html#syntax","text":"fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...)","title":"Syntax"},{"location":"databank/toCSV.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date.","title":"Input Arguments"},{"location":"databank/toCSV.html#output-arguments","text":"fieldsSaved [ string ] List of databank fields that have been written to the output file fileName .","title":"Output Arguments"},{"location":"databank/toCSV.html#options","text":"NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field.","title":"Options"},{"location":"databank/toCSV.html#description","text":"","title":"Description"},{"location":"databank/toCSV.html#example","text":"Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field.","title":"Example"},{"location":"databank/toCSV.html#example_1","text":"D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"Example"},{"location":"databank/withEmpty.html","text":"databank.withEmpty Create databank with empty time series Syntax outputDb = databank.withEmpty(names, ...) Input Arguments __ names [ char | cellstr | string ] List of names under which new empty time series will be created. Output Arguments __ outputDb [ struct ] Databank with the new empty time series created or added. Options AddToDatabank=struct() [ struct ] Add the new empty time series to this databank. Description Example","title":"withEmpty"},{"location":"databank/withEmpty.html#databankwithempty","text":"Create databank with empty time series","title":"databank.withEmpty"},{"location":"databank/withEmpty.html#syntax","text":"outputDb = databank.withEmpty(names, ...)","title":"Syntax"},{"location":"databank/withEmpty.html#input-arguments","text":"__ names [ char | cellstr | string ] List of names under which new empty time series will be created.","title":"Input Arguments"},{"location":"databank/withEmpty.html#output-arguments","text":"__ outputDb [ struct ] Databank with the new empty time series created or added.","title":"Output Arguments"},{"location":"databank/withEmpty.html#options","text":"AddToDatabank=struct() [ struct ] Add the new empty time series to this databank.","title":"Options"},{"location":"databank/withEmpty.html#description","text":"","title":"Description"},{"location":"databank/withEmpty.html#example","text":"","title":"Example"},{"location":"dates/index.html","text":"Dates IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with limited support to business daily) integer (numbered observations) Categorical List of Functions Creating Dates Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations) Converting Dates Function Description toString Print IrisT dates as formatted strings","title":"Introduction"},{"location":"dates/index.html#dates","text":"IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with limited support to business daily) integer (numbered observations)","title":"Dates"},{"location":"dates/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"dates/index.html#creating-dates","text":"Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations)","title":"Creating Dates"},{"location":"dates/index.html#converting-dates","text":"Function Description toString Print IrisT dates as formatted strings","title":"Converting Dates"},{"location":"dates/dd.html","text":"dd , Dater.dd , dater.dd Create daily dates Shortcut Syntax for Dater Objects date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year) Syntax for Dater Objects date = Dater.dd(...) Syntax for Numeric Date Codes date = dater.dd(...) Input Arguments year [ numeric ] Calendar year. month=1 [ numeric ] Calendar month. day=1 [ numeric ] Week of the year; \"end\" means the last day of the respective month (considering leap years for February). Output Arguments date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode. Description The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers. Example Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"dd"},{"location":"dates/dd.html#dd-daterdd-daterdd","text":"Create daily dates","title":"dd, Dater.dd, dater.dd"},{"location":"dates/dd.html#shortcut-syntax-for-dater-objects","text":"date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year)","title":"Shortcut Syntax for Dater Objects"},{"location":"dates/dd.html#syntax-for-dater-objects","text":"date = Dater.dd(...)","title":"Syntax for Dater Objects"},{"location":"dates/dd.html#syntax-for-numeric-date-codes","text":"date = dater.dd(...)","title":"Syntax for Numeric Date Codes"},{"location":"dates/dd.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric ] Calendar month. day=1 [ numeric ] Week of the year; \"end\" means the last day of the respective month (considering leap years for February).","title":"Input Arguments"},{"location":"dates/dd.html#output-arguments","text":"date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode.","title":"Output Arguments"},{"location":"dates/dd.html#description","text":"The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers.","title":"Description"},{"location":"dates/dd.html#example","text":"Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"Example"},{"location":"dates/hh.html","text":"hh , Dater.hh , dater.hh Create half-yearly dates Shortcut Syntax to Create Dater Objects date = hh(year, half) date = hh(year, \"end\") date = hh(year) Syntax to Create Dater Objects date = hh(...) Syntax to Create Numeric Date Codes dateCode = dater.hh(...) Input Arguments year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 . Output Arguments date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode. Description Example Calculate the number of halfyears between two halfyearly dates t1 = hh(2020,1); t2 = hh(2024,2); n = t2 - t1","title":"hh"},{"location":"dates/hh.html#hh-daterhh-daterhh","text":"Create half-yearly dates","title":"hh, Dater.hh, dater.hh"},{"location":"dates/hh.html#shortcut-syntax-to-create-dater-objects","text":"date = hh(year, half) date = hh(year, \"end\") date = hh(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"dates/hh.html#syntax-to-create-dater-objects","text":"date = hh(...)","title":"Syntax to Create Dater Objects"},{"location":"dates/hh.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.hh(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"dates/hh.html#input-arguments","text":"year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 .","title":"Input Arguments"},{"location":"dates/hh.html#output-arguments","text":"date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"dates/hh.html#description","text":"","title":"Description"},{"location":"dates/hh.html#example","text":"Calculate the number of halfyears between two halfyearly dates t1 = hh(2020,1); t2 = hh(2024,2); n = t2 - t1","title":"Example"},{"location":"dates/ii.html","text":"ii , Dater.ii , dater.ii Create integer dates (numbered observations) Shortcut Syntax to Create Dater Objects date = ii(integer) Syntax to Create Dater Objects date = Dater.ii(...) Syntax to Create Numeric Date Codes dateCode = dater.ii(...) Input Arguments integer [ numeric ] Integer number, any non-integers will be floored. Output Arguments date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode. Description This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed. Example Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"ii"},{"location":"dates/ii.html#ii-daterii-daterii","text":"Create integer dates (numbered observations)","title":"ii, Dater.ii, dater.ii"},{"location":"dates/ii.html#shortcut-syntax-to-create-dater-objects","text":"date = ii(integer)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"dates/ii.html#syntax-to-create-dater-objects","text":"date = Dater.ii(...)","title":"Syntax to Create Dater Objects"},{"location":"dates/ii.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.ii(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"dates/ii.html#input-arguments","text":"integer [ numeric ] Integer number, any non-integers will be floored.","title":"Input Arguments"},{"location":"dates/ii.html#output-arguments","text":"date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode.","title":"Output Arguments"},{"location":"dates/ii.html#description","text":"This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed.","title":"Description"},{"location":"dates/ii.html#example","text":"Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"Example"},{"location":"dates/mm.html","text":"mm , Dater.mm , dater.mm Create monthly dates Shortcut Syntax to Create Dater Objects date = mm(year, month) date = mm(year, \"end\") date = mm(year) Syntax to Create Dater Objects date = mm(...) Syntax to Create Numeric Date Codes dateCode = dater.mm(...) Input Arguments year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 . Output Arguments date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode. Description Example Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"mm"},{"location":"dates/mm.html#mm-datermm-datermm","text":"Create monthly dates","title":"mm, Dater.mm, dater.mm"},{"location":"dates/mm.html#shortcut-syntax-to-create-dater-objects","text":"date = mm(year, month) date = mm(year, \"end\") date = mm(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"dates/mm.html#syntax-to-create-dater-objects","text":"date = mm(...)","title":"Syntax to Create Dater Objects"},{"location":"dates/mm.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.mm(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"dates/mm.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 .","title":"Input Arguments"},{"location":"dates/mm.html#output-arguments","text":"date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"dates/mm.html#description","text":"","title":"Description"},{"location":"dates/mm.html#example","text":"Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"Example"},{"location":"dates/qq.html","text":"qq , Dater.qq , dater.qq Create quarterly dates Shortcut Syntax to Create Dater Objects date = qq(year, quarter) date = qq(year, \"end\") date = qq(year) Syntax to Create Dater Objects date = Dater.qq(...) Syntax to Create Numeric Date Codes dateCode = dater.qq(...) Input Arguments year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 . Output Arguments date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode. Description Example Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"qq"},{"location":"dates/qq.html#qq-daterqq-daterqq","text":"Create quarterly dates","title":"qq, Dater.qq, dater.qq"},{"location":"dates/qq.html#shortcut-syntax-to-create-dater-objects","text":"date = qq(year, quarter) date = qq(year, \"end\") date = qq(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"dates/qq.html#syntax-to-create-dater-objects","text":"date = Dater.qq(...)","title":"Syntax to Create Dater Objects"},{"location":"dates/qq.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.qq(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"dates/qq.html#input-arguments","text":"year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 .","title":"Input Arguments"},{"location":"dates/qq.html#output-arguments","text":"date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"dates/qq.html#description","text":"","title":"Description"},{"location":"dates/qq.html#example","text":"Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"Example"},{"location":"dates/toString.html","text":"toString Print IrisT dates as formatted strings Syntax outputString = toString(inputDate, format) Input Arguments inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string. Output Arguments outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format . Options Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Description The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed Example of Plain Vanilla Date Formatting Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\" Example of Open / Close Options Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"toString"},{"location":"dates/toString.html#tostring","text":"Print IrisT dates as formatted strings","title":"toString"},{"location":"dates/toString.html#syntax","text":"outputString = toString(inputDate, format)","title":"Syntax"},{"location":"dates/toString.html#input-arguments","text":"inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string.","title":"Input Arguments"},{"location":"dates/toString.html#output-arguments","text":"outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format .","title":"Output Arguments"},{"location":"dates/toString.html#options","text":"Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters.","title":"Options"},{"location":"dates/toString.html#description","text":"The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed","title":"Description"},{"location":"dates/toString.html#example-of-plain-vanilla-date-formatting","text":"Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\"","title":"Example of Plain Vanilla Date Formatting"},{"location":"dates/toString.html#example-of-openclose-options","text":"Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"Example of Open/Close Options"},{"location":"dates/ww.html","text":"ww , Dater.ww , dater.ww Create weekly dates Shortcut Syntax to Create Dater Objects date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day) Syntax to Create Dater Objects date = Dater.ww(...) Syntax to Create Plain Numeric Date Codes dateCode = dater.ww(...) Input Arguments year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601. Output Arguments date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode. Description Example Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"ww"},{"location":"dates/ww.html#ww-daterww-daterww","text":"Create weekly dates","title":"ww, Dater.ww, dater.ww"},{"location":"dates/ww.html#shortcut-syntax-to-create-dater-objects","text":"date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"dates/ww.html#syntax-to-create-dater-objects","text":"date = Dater.ww(...)","title":"Syntax to Create Dater Objects"},{"location":"dates/ww.html#syntax-to-create-plain-numeric-date-codes","text":"dateCode = dater.ww(...)","title":"Syntax to Create Plain Numeric Date Codes"},{"location":"dates/ww.html#input-arguments","text":"year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601.","title":"Input Arguments"},{"location":"dates/ww.html#output-arguments","text":"date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"dates/ww.html#description","text":"","title":"Description"},{"location":"dates/ww.html#example","text":"Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"Example"},{"location":"dates/yy.html","text":"yy , Dater.yy , dater.yy Create yearly dates Shortcut Syntax to Create Dater Objects date = yy(year) Syntax to Create Dater Objects date = Dater.yy(...) Syntax to Create Numeric Date Codes dateCode = dater.yy(...) Input Arguments year [ numeric ] Calendar year. Output Arguments date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode. Description Example Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"yy"},{"location":"dates/yy.html#yy-dateryy-dateryy","text":"Create yearly dates","title":"yy, Dater.yy, dater.yy"},{"location":"dates/yy.html#shortcut-syntax-to-create-dater-objects","text":"date = yy(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"dates/yy.html#syntax-to-create-dater-objects","text":"date = Dater.yy(...)","title":"Syntax to Create Dater Objects"},{"location":"dates/yy.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.yy(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"dates/yy.html#input-arguments","text":"year [ numeric ] Calendar year.","title":"Input Arguments"},{"location":"dates/yy.html#output-arguments","text":"date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"dates/yy.html#description","text":"","title":"Description"},{"location":"dates/yy.html#example","text":"Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"Example"}]}