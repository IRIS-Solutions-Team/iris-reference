{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"[IrisToolbox] Reference Manual","title":"Introduction"},{"location":"index.html#iristoolbox-reference-manual","text":"","title":"[IrisToolbox] Reference Manual"},{"location":"install.html","text":"Installing IrisT There are two basic ways to get IrisT up and running on your computer: clone the GitHub repository; or download and unpack Iris from a zip achive. Cloning the GitHub Repository Installing IrisT from a Zip Archive","title":"Installation"},{"location":"install.html#installing-irist","text":"There are two basic ways to get IrisT up and running on your computer: clone the GitHub repository; or download and unpack Iris from a zip achive.","title":"Installing IrisT"},{"location":"install.html#cloning-the-github-repository","text":"","title":"Cloning the GitHub Repository"},{"location":"install.html#installing-irist-from-a-zip-archive","text":"","title":"Installing IrisT from a Zip Archive"},{"location":"data-management/index.html","text":"Data Management","title":"Introduction"},{"location":"data-management/index.html#data-management","text":"","title":"Data Management"},{"location":"data-management/databank/index.html","text":"Databank Functions IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks. Categorical List of Functions Creating, Converting, Importing, and Exporting Databanks Function Description databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series Getting Information about Databanks Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields Processing Databanks Function Description databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy Copy fields of source databank to target databank databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields","title":"Introduction"},{"location":"data-management/databank/index.html#databank-functions","text":"IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks.","title":"Databank Functions"},{"location":"data-management/databank/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"data-management/databank/index.html#creating-converting-importing-and-exporting-databanks","text":"Function Description databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series","title":"Creating, Converting, Importing, and Exporting Databanks"},{"location":"data-management/databank/index.html#getting-information-about-databanks","text":"Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields","title":"Getting Information about Databanks"},{"location":"data-management/databank/index.html#processing-databanks","text":"Function Description databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy Copy fields of source databank to target databank databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields","title":"Processing Databanks"},{"location":"data-management/databank/apply.html","text":"databank.apply Apply function to a selection of databank fields Syntax [outputDb, appliedToNames, newNames] = apply(inputDb, func, ...) Input Arguments inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb . Output Arguments outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb . Options StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields. Description Example Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 ); Example Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"apply"},{"location":"data-management/databank/apply.html#databankapply","text":"Apply function to a selection of databank fields","title":"databank.apply"},{"location":"data-management/databank/apply.html#syntax","text":"[outputDb, appliedToNames, newNames] = apply(inputDb, func, ...)","title":"Syntax"},{"location":"data-management/databank/apply.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb .","title":"Input Arguments"},{"location":"data-management/databank/apply.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb .","title":"Output Arguments"},{"location":"data-management/databank/apply.html#options","text":"StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields.","title":"Options"},{"location":"data-management/databank/apply.html#description","text":"","title":"Description"},{"location":"data-management/databank/apply.html#example","text":"Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 );","title":"Example"},{"location":"data-management/databank/apply.html#example_1","text":"Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"Example"},{"location":"data-management/databank/clip.html","text":"databank.clip Clip all time series in databank to a new range Syntax outputDatabank = databank.clip(inputDatabank, newStart, newEnd) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered. Output Arguments outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range. Description Example Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"clip"},{"location":"data-management/databank/clip.html#databankclip","text":"Clip all time series in databank to a new range","title":"databank.clip"},{"location":"data-management/databank/clip.html#syntax","text":"outputDatabank = databank.clip(inputDatabank, newStart, newEnd)","title":"Syntax"},{"location":"data-management/databank/clip.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered.","title":"Input Arguments"},{"location":"data-management/databank/clip.html#output-arguments","text":"outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range.","title":"Output Arguments"},{"location":"data-management/databank/clip.html#description","text":"","title":"Description"},{"location":"data-management/databank/clip.html#example","text":"Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"Example"},{"location":"data-management/databank/copy.html","text":"databank.copy Copy fields of source databank to target databank Syntax targetDb = databank.copy(sourceDb, ...) Input Arguments sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb . Options SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform=[ ] [ empty | function_handle ] Transformation function applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank. Output Arguments targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over. Description Example","title":"copy"},{"location":"data-management/databank/copy.html#databankcopy","text":"Copy fields of source databank to target databank","title":"databank.copy"},{"location":"data-management/databank/copy.html#syntax","text":"targetDb = databank.copy(sourceDb, ...)","title":"Syntax"},{"location":"data-management/databank/copy.html#input-arguments","text":"sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb .","title":"Input Arguments"},{"location":"data-management/databank/copy.html#options","text":"SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform=[ ] [ empty | function_handle ] Transformation function applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank.","title":"Options"},{"location":"data-management/databank/copy.html#output-arguments","text":"targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over.","title":"Output Arguments"},{"location":"data-management/databank/copy.html#description","text":"","title":"Description"},{"location":"data-management/databank/copy.html#example","text":"","title":"Example"},{"location":"data-management/databank/eval.html","text":"databank.eval Evaluate an expression within a databank context Syntax [output, output, ...] = databank.eval(inputDb, expression, expression, ...) outputs = databank.eval(inputDb, expressions) outputDb = databank.eval(inputDb, expressionsDb) Input Arguments inputDb [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDb fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDb fields. expressionsDb [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated. Output Arguments output [ * ] Result of the expression evaluated in the inputDb workspace. outputs [ cell ] Results of the expressions evaluated in the inputDb workspace. outputDb [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDb workspace. Description Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDb fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDb . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDb fields. To include round-bracket references to inputDb fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis. Example d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"eval"},{"location":"data-management/databank/eval.html#databankeval","text":"Evaluate an expression within a databank context","title":"databank.eval"},{"location":"data-management/databank/eval.html#syntax","text":"[output, output, ...] = databank.eval(inputDb, expression, expression, ...) outputs = databank.eval(inputDb, expressions) outputDb = databank.eval(inputDb, expressionsDb)","title":"Syntax"},{"location":"data-management/databank/eval.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDb fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDb fields. expressionsDb [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated.","title":"Input Arguments"},{"location":"data-management/databank/eval.html#output-arguments","text":"output [ * ] Result of the expression evaluated in the inputDb workspace. outputs [ cell ] Results of the expressions evaluated in the inputDb workspace. outputDb [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDb workspace.","title":"Output Arguments"},{"location":"data-management/databank/eval.html#description","text":"Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDb fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDb . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDb fields. To include round-bracket references to inputDb fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis.","title":"Description"},{"location":"data-management/databank/eval.html#example","text":"d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"Example"},{"location":"data-management/databank/fieldNames.html","text":"databank.fieldNames List of databank field names as a row vector of strings Syntax list = databank.fieldNames(db) Input Arguments db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object. Output Arguments list [ string ] List of all field names contained in the input db , arranged as a row vector of strings. Description The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop. Example d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"fieldNames"},{"location":"data-management/databank/fieldNames.html#databankfieldnames","text":"List of databank field names as a row vector of strings","title":"databank.fieldNames"},{"location":"data-management/databank/fieldNames.html#syntax","text":"list = databank.fieldNames(db)","title":"Syntax"},{"location":"data-management/databank/fieldNames.html#input-arguments","text":"db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object.","title":"Input Arguments"},{"location":"data-management/databank/fieldNames.html#output-arguments","text":"list [ string ] List of all field names contained in the input db , arranged as a row vector of strings.","title":"Output Arguments"},{"location":"data-management/databank/fieldNames.html#description","text":"The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop.","title":"Description"},{"location":"data-management/databank/fieldNames.html#example","text":"d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"Example"},{"location":"data-management/databank/filterFields.html","text":"databank.filterFields Get the names of databank fields that pass name or value tests Syntax list = databank.filterFields(inputDb, ...) Input Arguments inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values. Output Arguments list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests. Options __ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test. Description Example","title":"filterFields"},{"location":"data-management/databank/filterFields.html#databankfilterfields","text":"Get the names of databank fields that pass name or value tests","title":"databank.filterFields"},{"location":"data-management/databank/filterFields.html#syntax","text":"list = databank.filterFields(inputDb, ...)","title":"Syntax"},{"location":"data-management/databank/filterFields.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values.","title":"Input Arguments"},{"location":"data-management/databank/filterFields.html#output-arguments","text":"list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests.","title":"Output Arguments"},{"location":"data-management/databank/filterFields.html#options","text":"__ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test.","title":"Options"},{"location":"data-management/databank/filterFields.html#description","text":"","title":"Description"},{"location":"data-management/databank/filterFields.html#example","text":"","title":"Example"},{"location":"data-management/databank/fromCSV.html","text":"databank.fromCSV Create databank by loading CSV file Syntax outputDb = databank.fromCSV(fileName, ...) Input Arguments fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined. Output Arguments outputDb [ struct | Dictionary ] Database created from the input CSV file(s). Options AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series. Description Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example). Structure of CSV Data Files The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | Example Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"fromCSV"},{"location":"data-management/databank/fromCSV.html#databankfromcsv","text":"Create databank by loading CSV file","title":"databank.fromCSV"},{"location":"data-management/databank/fromCSV.html#syntax","text":"outputDb = databank.fromCSV(fileName, ...)","title":"Syntax"},{"location":"data-management/databank/fromCSV.html#input-arguments","text":"fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined.","title":"Input Arguments"},{"location":"data-management/databank/fromCSV.html#output-arguments","text":"outputDb [ struct | Dictionary ] Database created from the input CSV file(s).","title":"Output Arguments"},{"location":"data-management/databank/fromCSV.html#options","text":"AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series.","title":"Options"},{"location":"data-management/databank/fromCSV.html#description","text":"Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example).","title":"Description"},{"location":"data-management/databank/fromCSV.html#structure-of-csv-data-files","text":"The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | |","title":"Structure of CSV Data Files"},{"location":"data-management/databank/fromCSV.html#example","text":"Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/databank/list.html","text":"databank.list List databank fields adding date range to time series fields Syntax databank.list(db) Input Arguments db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields. Description Example d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"list"},{"location":"data-management/databank/list.html#databanklist","text":"List databank fields adding date range to time series fields","title":"databank.list"},{"location":"data-management/databank/list.html#syntax","text":"databank.list(db)","title":"Syntax"},{"location":"data-management/databank/list.html#input-arguments","text":"db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields.","title":"Input Arguments"},{"location":"data-management/databank/list.html#description","text":"","title":"Description"},{"location":"data-management/databank/list.html#example","text":"d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"Example"},{"location":"data-management/databank/merge.html","text":"databank.merge Merge two or more databanks Syntax outputDb = databank.merge(method, primaryDb [, otherDb ], ...) Input Arguments method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb . Output Arguments outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method . Options MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" . Description The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown. Example","title":"merge"},{"location":"data-management/databank/merge.html#databankmerge","text":"Merge two or more databanks","title":"databank.merge"},{"location":"data-management/databank/merge.html#syntax","text":"outputDb = databank.merge(method, primaryDb [, otherDb ], ...)","title":"Syntax"},{"location":"data-management/databank/merge.html#input-arguments","text":"method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb .","title":"Input Arguments"},{"location":"data-management/databank/merge.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method .","title":"Output Arguments"},{"location":"data-management/databank/merge.html#options","text":"MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" .","title":"Options"},{"location":"data-management/databank/merge.html#description","text":"The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown.","title":"Description"},{"location":"data-management/databank/merge.html#example","text":"","title":"Example"},{"location":"data-management/databank/retrieveColumns.html","text":"databank.retrieveColumns Retrieve selected columns from databank fields Syntax outputDb = function(inputDb, refs,...) Input Arguments inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd). Output Arguments outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails . Options WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb . Description Example","title":"retrieveColumns"},{"location":"data-management/databank/retrieveColumns.html#databankretrievecolumns","text":"Retrieve selected columns from databank fields","title":"databank.retrieveColumns"},{"location":"data-management/databank/retrieveColumns.html#syntax","text":"outputDb = function(inputDb, refs,...)","title":"Syntax"},{"location":"data-management/databank/retrieveColumns.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd).","title":"Input Arguments"},{"location":"data-management/databank/retrieveColumns.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails .","title":"Output Arguments"},{"location":"data-management/databank/retrieveColumns.html#options","text":"WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb .","title":"Options"},{"location":"data-management/databank/retrieveColumns.html#description","text":"","title":"Description"},{"location":"data-management/databank/retrieveColumns.html#example","text":"","title":"Example"},{"location":"data-management/databank/toCSV.html","text":"databank.toCSV Write databank to CSV file Syntax fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date. Output Arguments fieldsSaved [ string ] List of databank fields that have been written to the output file fileName . Options NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field. Description Example Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field. Example D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"toCSV"},{"location":"data-management/databank/toCSV.html#databanktocsv","text":"Write databank to CSV file","title":"databank.toCSV"},{"location":"data-management/databank/toCSV.html#syntax","text":"fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...)","title":"Syntax"},{"location":"data-management/databank/toCSV.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date.","title":"Input Arguments"},{"location":"data-management/databank/toCSV.html#output-arguments","text":"fieldsSaved [ string ] List of databank fields that have been written to the output file fileName .","title":"Output Arguments"},{"location":"data-management/databank/toCSV.html#options","text":"NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field.","title":"Options"},{"location":"data-management/databank/toCSV.html#description","text":"","title":"Description"},{"location":"data-management/databank/toCSV.html#example","text":"Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field.","title":"Example"},{"location":"data-management/databank/toCSV.html#example_1","text":"D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"Example"},{"location":"data-management/databank/withEmpty.html","text":"databank.withEmpty Create databank with empty time series Syntax outputDb = databank.withEmpty(names, ...) Input Arguments __ names [ char | cellstr | string ] List of names under which new empty time series will be created. Output Arguments __ outputDb [ struct ] Databank with the new empty time series created or added. Options AddToDatabank=struct() [ struct ] Add the new empty time series to this databank. Description Example","title":"withEmpty"},{"location":"data-management/databank/withEmpty.html#databankwithempty","text":"Create databank with empty time series","title":"databank.withEmpty"},{"location":"data-management/databank/withEmpty.html#syntax","text":"outputDb = databank.withEmpty(names, ...)","title":"Syntax"},{"location":"data-management/databank/withEmpty.html#input-arguments","text":"__ names [ char | cellstr | string ] List of names under which new empty time series will be created.","title":"Input Arguments"},{"location":"data-management/databank/withEmpty.html#output-arguments","text":"__ outputDb [ struct ] Databank with the new empty time series created or added.","title":"Output Arguments"},{"location":"data-management/databank/withEmpty.html#options","text":"AddToDatabank=struct() [ struct ] Add the new empty time series to this databank.","title":"Options"},{"location":"data-management/databank/withEmpty.html#description","text":"","title":"Description"},{"location":"data-management/databank/withEmpty.html#example","text":"","title":"Example"},{"location":"data-management/dates/index.html","text":"Dates IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with limited support to business daily) integer (numbered observations) Categorical List of Functions Creating Dates Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations) Converting Dates Function Description toString Print IrisT dates as formatted strings","title":"Introduction"},{"location":"data-management/dates/index.html#dates","text":"IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with limited support to business daily) integer (numbered observations)","title":"Dates"},{"location":"data-management/dates/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"data-management/dates/index.html#creating-dates","text":"Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations)","title":"Creating Dates"},{"location":"data-management/dates/index.html#converting-dates","text":"Function Description toString Print IrisT dates as formatted strings","title":"Converting Dates"},{"location":"data-management/dates/dd.html","text":"dd | Dater.dd | dater.dd Create daily dates Shortcut syntax for Dater objects date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year) Syntax for Dater objects date = Dater.dd(...) Syntax for numeric date codes date = dater.dd(...) Input arguments year [ numeric ] Calendar year. month=1 [ numeric ] Calendar month. day=1 [ numeric ] Week of the year; \"end\" means the last day of the respective month (considering leap years for February). Output arguments date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode. Description The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers. Example Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"dd"},{"location":"data-management/dates/dd.html#dd-daterdd-daterdd","text":"Create daily dates","title":"dd  |  Dater.dd  |  dater.dd"},{"location":"data-management/dates/dd.html#shortcut-syntax-for-dater-objects","text":"date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year)","title":"Shortcut syntax for Dater objects"},{"location":"data-management/dates/dd.html#syntax-for-dater-objects","text":"date = Dater.dd(...)","title":"Syntax for Dater objects"},{"location":"data-management/dates/dd.html#syntax-for-numeric-date-codes","text":"date = dater.dd(...)","title":"Syntax for numeric date codes"},{"location":"data-management/dates/dd.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric ] Calendar month. day=1 [ numeric ] Week of the year; \"end\" means the last day of the respective month (considering leap years for February).","title":"Input arguments"},{"location":"data-management/dates/dd.html#output-arguments","text":"date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode.","title":"Output arguments"},{"location":"data-management/dates/dd.html#description","text":"The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers.","title":"Description"},{"location":"data-management/dates/dd.html#example","text":"Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"Example"},{"location":"data-management/dates/hh.html","text":"hh | Dater.hh | dater.hh Create half-yearly dates Shortcut syntax to create Dater objects date = hh(year, half) date = hh(year, \"end\") date = hh(year) Syntax to create Dater objects date = hh(...) Syntax to create numeric date codes dateCode = dater.hh(...) Input arguments year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 . Output arguments date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode. Description Example Calculate the number of halfyears between two halfyearly dates t1 = hh ( 2020 , 1 ); t2 = hh ( 2024 , 2 ); n = t2 - t1","title":"hh"},{"location":"data-management/dates/hh.html#hh-daterhh-daterhh","text":"Create half-yearly dates","title":"hh  |  Dater.hh  |  dater.hh"},{"location":"data-management/dates/hh.html#shortcut-syntax-to-create-dater-objects","text":"date = hh(year, half) date = hh(year, \"end\") date = hh(year)","title":"Shortcut syntax to create Dater objects"},{"location":"data-management/dates/hh.html#syntax-to-create-dater-objects","text":"date = hh(...)","title":"Syntax to create Dater objects"},{"location":"data-management/dates/hh.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.hh(...)","title":"Syntax to create numeric date codes"},{"location":"data-management/dates/hh.html#input-arguments","text":"year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 .","title":"Input arguments"},{"location":"data-management/dates/hh.html#output-arguments","text":"date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode.","title":"Output arguments"},{"location":"data-management/dates/hh.html#description","text":"","title":"Description"},{"location":"data-management/dates/hh.html#example","text":"Calculate the number of halfyears between two halfyearly dates t1 = hh ( 2020 , 1 ); t2 = hh ( 2024 , 2 ); n = t2 - t1","title":"Example"},{"location":"data-management/dates/ii.html","text":"ii | Dater.ii | dater.ii Create integer dates (numbered observations) Shortcut Syntax to Create Dater Objects date = ii(integer) Syntax to Create Dater Objects date = Dater.ii(...) Syntax to Create Numeric Date Codes dateCode = dater.ii(...) Input Arguments integer [ numeric ] Integer number, any non-integers will be floored. Output Arguments date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode. Description This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed. Example Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"ii"},{"location":"data-management/dates/ii.html#ii-daterii-daterii","text":"Create integer dates (numbered observations)","title":"ii  |  Dater.ii  |  dater.ii"},{"location":"data-management/dates/ii.html#shortcut-syntax-to-create-dater-objects","text":"date = ii(integer)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/ii.html#syntax-to-create-dater-objects","text":"date = Dater.ii(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/ii.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.ii(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"data-management/dates/ii.html#input-arguments","text":"integer [ numeric ] Integer number, any non-integers will be floored.","title":"Input Arguments"},{"location":"data-management/dates/ii.html#output-arguments","text":"date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/ii.html#description","text":"This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed.","title":"Description"},{"location":"data-management/dates/ii.html#example","text":"Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"Example"},{"location":"data-management/dates/mm.html","text":"mm | Dater.mm | dater.mm Create monthly dates Shortcut Syntax to Create Dater Objects date = mm(year, month) date = mm(year, \"end\") date = mm(year) Syntax to Create Dater Objects date = mm(...) Syntax to Create Numeric Date Codes dateCode = dater.mm(...) Input Arguments year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 . Output Arguments date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode. Description Example Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"mm"},{"location":"data-management/dates/mm.html#mm-datermm-datermm","text":"Create monthly dates","title":"mm  |  Dater.mm  |  dater.mm"},{"location":"data-management/dates/mm.html#shortcut-syntax-to-create-dater-objects","text":"date = mm(year, month) date = mm(year, \"end\") date = mm(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/mm.html#syntax-to-create-dater-objects","text":"date = mm(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/mm.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.mm(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"data-management/dates/mm.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 .","title":"Input Arguments"},{"location":"data-management/dates/mm.html#output-arguments","text":"date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/mm.html#description","text":"","title":"Description"},{"location":"data-management/dates/mm.html#example","text":"Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"Example"},{"location":"data-management/dates/qq.html","text":"qq | Dater.qq | dater.qq Create quarterly dates Shortcut Syntax to Create Dater Objects date = qq(year, quarter) date = qq(year, \"end\") date = qq(year) Syntax to Create Dater Objects date = Dater.qq(...) Syntax to Create Numeric Date Codes dateCode = dater.qq(...) Input Arguments year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 . Output Arguments date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode. Description Example Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"qq"},{"location":"data-management/dates/qq.html#qq-daterqq-daterqq","text":"Create quarterly dates","title":"qq  |  Dater.qq  |  dater.qq"},{"location":"data-management/dates/qq.html#shortcut-syntax-to-create-dater-objects","text":"date = qq(year, quarter) date = qq(year, \"end\") date = qq(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/qq.html#syntax-to-create-dater-objects","text":"date = Dater.qq(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/qq.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.qq(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"data-management/dates/qq.html#input-arguments","text":"year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 .","title":"Input Arguments"},{"location":"data-management/dates/qq.html#output-arguments","text":"date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/qq.html#description","text":"","title":"Description"},{"location":"data-management/dates/qq.html#example","text":"Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"Example"},{"location":"data-management/dates/toString.html","text":"toString Print IrisT dates as formatted strings Syntax outputString = toString(inputDate, format) Input Arguments inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string. Output Arguments outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format . Options Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Description The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed Example of Plain Vanilla Date Formatting Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\" Example of Open / Close Options Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"toString"},{"location":"data-management/dates/toString.html#tostring","text":"Print IrisT dates as formatted strings","title":"toString"},{"location":"data-management/dates/toString.html#syntax","text":"outputString = toString(inputDate, format)","title":"Syntax"},{"location":"data-management/dates/toString.html#input-arguments","text":"inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string.","title":"Input Arguments"},{"location":"data-management/dates/toString.html#output-arguments","text":"outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format .","title":"Output Arguments"},{"location":"data-management/dates/toString.html#options","text":"Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters.","title":"Options"},{"location":"data-management/dates/toString.html#description","text":"The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed","title":"Description"},{"location":"data-management/dates/toString.html#example-of-plain-vanilla-date-formatting","text":"Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\"","title":"Example of Plain Vanilla Date Formatting"},{"location":"data-management/dates/toString.html#example-of-openclose-options","text":"Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"Example of Open/Close Options"},{"location":"data-management/dates/ww.html","text":"ww | Dater.ww | dater.ww Create weekly dates Shortcut Syntax to Create Dater Objects date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day) Syntax to Create Dater Objects date = Dater.ww(...) Syntax to Create Plain Numeric Date Codes dateCode = dater.ww(...) Input Arguments year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601. Output Arguments date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode. Description Example Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"ww"},{"location":"data-management/dates/ww.html#ww-daterww-daterww","text":"Create weekly dates","title":"ww  |  Dater.ww  |  dater.ww"},{"location":"data-management/dates/ww.html#shortcut-syntax-to-create-dater-objects","text":"date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/ww.html#syntax-to-create-dater-objects","text":"date = Dater.ww(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/ww.html#syntax-to-create-plain-numeric-date-codes","text":"dateCode = dater.ww(...)","title":"Syntax to Create Plain Numeric Date Codes"},{"location":"data-management/dates/ww.html#input-arguments","text":"year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601.","title":"Input Arguments"},{"location":"data-management/dates/ww.html#output-arguments","text":"date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/ww.html#description","text":"","title":"Description"},{"location":"data-management/dates/ww.html#example","text":"Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"Example"},{"location":"data-management/dates/yy.html","text":"yy | Dater.yy | dater.yy Create yearly dates Shortcut Syntax to Create Dater Objects date = yy(year) Syntax to Create Dater Objects date = Dater.yy(...) Syntax to Create Numeric Date Codes dateCode = dater.yy(...) Input Arguments year [ numeric ] Calendar year. Output Arguments date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode. Description Example Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"yy"},{"location":"data-management/dates/yy.html#yy-dateryy-dateryy","text":"Create yearly dates","title":"yy  |  Dater.yy  |  dater.yy"},{"location":"data-management/dates/yy.html#shortcut-syntax-to-create-dater-objects","text":"date = yy(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/yy.html#syntax-to-create-dater-objects","text":"date = Dater.yy(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/yy.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.yy(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"data-management/dates/yy.html#input-arguments","text":"year [ numeric ] Calendar year.","title":"Input Arguments"},{"location":"data-management/dates/yy.html#output-arguments","text":"date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/yy.html#description","text":"","title":"Description"},{"location":"data-management/dates/yy.html#example","text":"Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"Example"},{"location":"data-management/imf/index.html","text":"Interfact to [IMF Data Portal] Categorical list of functions Download time series Function Description databank.fromCSV.data Download databank of time series from IMF Data Portal Download meta data and dataset structure information Function Description databank.fromCSV.datasets Download list of datasets from IMF Data Portal databank.fromCSV.codes Download code lists from IMF Data Portal","title":"Introduction"},{"location":"data-management/imf/index.html#interfact-to-imf-data-portal","text":"","title":"Interfact to [IMF Data Portal]"},{"location":"data-management/imf/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"data-management/imf/index.html#download-time-series","text":"Function Description databank.fromCSV.data Download databank of time series from IMF Data Portal","title":"Download time series"},{"location":"data-management/imf/index.html#download-meta-data-and-dataset-structure-information","text":"Function Description databank.fromCSV.datasets Download list of datasets from IMF Data Portal databank.fromCSV.codes Download code lists from IMF Data Portal","title":"Download meta data and dataset structure information"},{"location":"data-management/imf/codes.html","text":"databank.fromIMF.codes Download code lists from IMF Data Portal","title":"codes"},{"location":"data-management/imf/codes.html#databankfromimfcodes","text":"Download code lists from IMF Data Portal","title":"databank.fromIMF.codes"},{"location":"data-management/imf/data.html","text":"databank.fromIMF.data Download databank of time series from IMF Data Portal Syntax for Two-Dimensional Requests [outputDb, info] = databank.fromIMF.data(datasetId, frequency, areas, items, ...) Syntax for Three-Dimensional Requests outputDb = databank.fromIMF.data(datasetId, frequency, areas, items, counters, ...) Input Arguments databankId [ string ] IMF dataset ID; only one dataset is allowed in one data request. frequency [ Frequency ] Date frequency for the output time series; the frequency must be yearly, quarterly or monthly; only one frequency is allowed in one data request. areas [ string ] List of reference areas for which the output time series will be retrieved; an empty string or emtpy array means all reference areas. items [ string ] List of indicators that will be retrieved for each of the areas . counter=empty [ string ] List of counterparty reference areas for which the output time series will be retrieved; counterparty reference areas are needed for only some of the IMF databanks, such as Directions of Trade Statistics (DOT); an empty string or empty array means all counterparty reference areas. Output Arguments outputDb [ struct | Dictionary ] Output databank with time series retrieved from an IMF databank. info [ struct ] Output information struct with the following fields: .Request - the entire request string (including the URL) .Response - a JSON struct with the IMF data portal response Options for HTTP Request EndDate=-Inf [ Dater ] End date for the data requested; -Inf means the date of the latest observation for each series. StartDate=-Inf [ Dater ] Start date for the data requested; -Inf means the date of the earliest observation for each series. URL=\"http://dataservices.imf.org/REST/SDMX_JSON.svc/CompactData/\" [ string ] URL for the IMF data portal HTTP request. WebOptions=weboptions(\"Timeout\", 9999) [ weboption ] A weboptions object with HTTP settings. Options for Output Databank AddToDatabank=struct() [ struct | Dictionary ] Add the output time series to this databank. ApplyMultiplier=true [ true | false ] Apply the unit multiplier to the output time series data, scaling them to basic units (e.g. from millions). Options for Output Time Series Names NameFunc=[] [ empty | function_handle ] Function that will be applied to each time series name before it is stored in the outputDb . IncludeArea=true [ true | false ] Include the respective reference area code as a prefix in the name of each output time series. IncludeCounter=true [ true | false ] Three-dimensional requests only (with counterparty reference area): Include the respective counterparty reference area code as a suffix in the name of each output time series. Separator=\"_\" [ string ] Separator used in the area prefix and/or the counterparty area suffix in the output time series names. Description This function returns a databank of time series from the IMF data portal. To create a data request, you need to know the IMF dataset code, the reference area code(s), the indicator code(s), and for three-dimensional requests, also the counterparty reference area code(s). Leaving the reference area code, the indicator code or the counterparty reference area code empty will return data for all of those that exist in that dimension. The IMF data portal has bandwith restrictions. Sometimes, requests returning larger amounts of data need to be split into smaller, more specific requests. Sometimes, the function needs to be called several times before an actual data response is returned. Examples Two-Dimensional Requests Most of the IMF data requests need two dimensions to be specified: the reference area and the indicator (the concept). From the IMF IFS dataset, retrieve quarterly nominal GDP in localy currency for the US: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , \"NGDP_XDC\" ) Retrieve nominal GDP in localy currency for all areas (countries and regions) for which this indicator is available: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , [], \"NGDP_XDC\" ) Retrieve all indicators available from the IMF IFS databank for the US; do not include the country prefix (here, \"US_\") in the names of the output time series: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , [], \"includeArea\" , false ) Three-Dimensional Requests From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to Euro Area (code \"U2\"): d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , \"U2\" ); From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to all reported areas: d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , []);","title":"data"},{"location":"data-management/imf/data.html#databankfromimfdata","text":"Download databank of time series from IMF Data Portal","title":"databank.fromIMF.data"},{"location":"data-management/imf/data.html#syntax-for-two-dimensional-requests","text":"[outputDb, info] = databank.fromIMF.data(datasetId, frequency, areas, items, ...)","title":"Syntax for Two-Dimensional Requests"},{"location":"data-management/imf/data.html#syntax-for-three-dimensional-requests","text":"outputDb = databank.fromIMF.data(datasetId, frequency, areas, items, counters, ...)","title":"Syntax for Three-Dimensional Requests"},{"location":"data-management/imf/data.html#input-arguments","text":"databankId [ string ] IMF dataset ID; only one dataset is allowed in one data request. frequency [ Frequency ] Date frequency for the output time series; the frequency must be yearly, quarterly or monthly; only one frequency is allowed in one data request. areas [ string ] List of reference areas for which the output time series will be retrieved; an empty string or emtpy array means all reference areas. items [ string ] List of indicators that will be retrieved for each of the areas . counter=empty [ string ] List of counterparty reference areas for which the output time series will be retrieved; counterparty reference areas are needed for only some of the IMF databanks, such as Directions of Trade Statistics (DOT); an empty string or empty array means all counterparty reference areas.","title":"Input Arguments"},{"location":"data-management/imf/data.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank with time series retrieved from an IMF databank. info [ struct ] Output information struct with the following fields: .Request - the entire request string (including the URL) .Response - a JSON struct with the IMF data portal response","title":"Output Arguments"},{"location":"data-management/imf/data.html#options-for-http-request","text":"EndDate=-Inf [ Dater ] End date for the data requested; -Inf means the date of the latest observation for each series. StartDate=-Inf [ Dater ] Start date for the data requested; -Inf means the date of the earliest observation for each series. URL=\"http://dataservices.imf.org/REST/SDMX_JSON.svc/CompactData/\" [ string ] URL for the IMF data portal HTTP request. WebOptions=weboptions(\"Timeout\", 9999) [ weboption ] A weboptions object with HTTP settings.","title":"Options for HTTP Request"},{"location":"data-management/imf/data.html#options-for-output-databank","text":"AddToDatabank=struct() [ struct | Dictionary ] Add the output time series to this databank. ApplyMultiplier=true [ true | false ] Apply the unit multiplier to the output time series data, scaling them to basic units (e.g. from millions).","title":"Options for Output Databank"},{"location":"data-management/imf/data.html#options-for-output-time-series-names","text":"NameFunc=[] [ empty | function_handle ] Function that will be applied to each time series name before it is stored in the outputDb . IncludeArea=true [ true | false ] Include the respective reference area code as a prefix in the name of each output time series. IncludeCounter=true [ true | false ] Three-dimensional requests only (with counterparty reference area): Include the respective counterparty reference area code as a suffix in the name of each output time series. Separator=\"_\" [ string ] Separator used in the area prefix and/or the counterparty area suffix in the output time series names.","title":"Options for Output Time Series Names"},{"location":"data-management/imf/data.html#description","text":"This function returns a databank of time series from the IMF data portal. To create a data request, you need to know the IMF dataset code, the reference area code(s), the indicator code(s), and for three-dimensional requests, also the counterparty reference area code(s). Leaving the reference area code, the indicator code or the counterparty reference area code empty will return data for all of those that exist in that dimension. The IMF data portal has bandwith restrictions. Sometimes, requests returning larger amounts of data need to be split into smaller, more specific requests. Sometimes, the function needs to be called several times before an actual data response is returned.","title":"Description"},{"location":"data-management/imf/data.html#examples","text":"","title":"Examples"},{"location":"data-management/imf/data.html#two-dimensional-requests","text":"Most of the IMF data requests need two dimensions to be specified: the reference area and the indicator (the concept). From the IMF IFS dataset, retrieve quarterly nominal GDP in localy currency for the US: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , \"NGDP_XDC\" ) Retrieve nominal GDP in localy currency for all areas (countries and regions) for which this indicator is available: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , [], \"NGDP_XDC\" ) Retrieve all indicators available from the IMF IFS databank for the US; do not include the country prefix (here, \"US_\") in the names of the output time series: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , [], \"includeArea\" , false )","title":"Two-Dimensional Requests"},{"location":"data-management/imf/data.html#three-dimensional-requests","text":"From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to Euro Area (code \"U2\"): d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , \"U2\" ); From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to all reported areas: d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , []);","title":"Three-Dimensional Requests"},{"location":"data-management/imf/datasets.html","text":"databank.fromIMF.datasets Download list of datasets from IMF Data Portal","title":"datasets"},{"location":"data-management/imf/datasets.html#databankfromimfdatasets","text":"Download list of datasets from IMF Data Portal","title":"databank.fromIMF.datasets"},{"location":"data-management/series/index.html","text":"Time series Categorical list of functions Creating new time series Function Description Series Create new time series object Series.linearTrend Create time series with linear trend Series.empty Create empty time series or empty existing time series Series.seasonDummy Create time series with seasonal dummies Series.randomlyGrowing Create randomly growing time series Filtering time series Function Description moving Apply function to moving window of time series observation","title":"Introduction"},{"location":"data-management/series/index.html#time-series","text":"","title":"Time series"},{"location":"data-management/series/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"data-management/series/index.html#creating-new-time-series","text":"Function Description Series Create new time series object Series.linearTrend Create time series with linear trend Series.empty Create empty time series or empty existing time series Series.seasonDummy Create time series with seasonal dummies Series.randomlyGrowing Create randomly growing time series","title":"Creating new time series"},{"location":"data-management/series/index.html#filtering-time-series","text":"Function Description moving Apply function to moving window of time series observation","title":"Filtering time series"},{"location":"data-management/series/Series.html","text":"Series Create new time series object Syntax X = Series() X = Series(dates, values) X = Series(dates, values, comments) X = Series(dates, values, comments, userData) Input Arguments dates [ numeric | char ] Dates for which observations will be supplied; dates do not need to be sorted in ascending order or create a continuous date range. If dates is scalar and values have multiple rows, then the date is interpreted as the start date for the entire time series. values [ numeric | function_handle ] Numerical values (observations) arranged columnwise, or a function that will be used to create an N-by-1 array of values, where N is the number of dates . comments [ string ] Comment(s) attached to each column of the time series; if omitted, comments will be empty strings. userData [ * ] Any kind of user data attached to the object; if omitted, user data will be empty; if userData is a struct, the Series methods accessUserData and assignUserData can be used access or assign/change them. Output Arguments x [ Series ] New times series. Description Example x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), @ rand , \"Random numbers\" );","title":"Series"},{"location":"data-management/series/Series.html#series","text":"Create new time series object","title":"Series"},{"location":"data-management/series/Series.html#syntax","text":"X = Series() X = Series(dates, values) X = Series(dates, values, comments) X = Series(dates, values, comments, userData)","title":"Syntax"},{"location":"data-management/series/Series.html#input-arguments","text":"dates [ numeric | char ] Dates for which observations will be supplied; dates do not need to be sorted in ascending order or create a continuous date range. If dates is scalar and values have multiple rows, then the date is interpreted as the start date for the entire time series. values [ numeric | function_handle ] Numerical values (observations) arranged columnwise, or a function that will be used to create an N-by-1 array of values, where N is the number of dates . comments [ string ] Comment(s) attached to each column of the time series; if omitted, comments will be empty strings. userData [ * ] Any kind of user data attached to the object; if omitted, user data will be empty; if userData is a struct, the Series methods accessUserData and assignUserData can be used access or assign/change them.","title":"Input Arguments"},{"location":"data-management/series/Series.html#output-arguments","text":"x [ Series ] New times series.","title":"Output Arguments"},{"location":"data-management/series/Series.html#description","text":"","title":"Description"},{"location":"data-management/series/Series.html#example","text":"x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), @ rand , \"Random numbers\" );","title":"Example"},{"location":"data-management/series/convert.html","text":"convert Convert time series to another frequency Syntax outputSeries = convert(inputSeries, newFreq, ...) outputSeries = convert(inputSeries, newFreq, range, ...) Input Arguments inputSeries [ Series ] Input time series that will be converted to a new frequency, freq , aggregating or intrapolating the data. newFreq [ Frequency ] New frequency to which the input data will be converted; see Description for frequency formats allowed. range=Inf [ Dater ] Date range on which the input data will be converted; Inf means the conversion will be done on the entire time series range. Output Arguments outputSeries [ Series ] Output tseries created by converting the inputSeries to the new frequency (aggregating or interpolating). Options RemoveNaN=false [ true | false ] Exclude NaN values from agreggation. Missing=@default [ @default | numeric | \"previous\" | \"next\" ] Fill missing observations with this value before conversion: @default means no preprocessing; \"previous\" or \"next\" means fill in the nearest preceding or nearest following value available in the time series. Options for High- to Low-Frequency Aggregation Method=\"mean\" [ \"mean\" | \"sum\" | \"first\" | \"last\" | function_handle ] Aggregation method; \"first\" , \"last\" and \"random\" select the first, last or a random observation from the high-frequency periods contained in the correspoding low-frequency period. RemoveWeekends=false [ true | false ] For daily frequency time series only: remove all weekend observations before aggregation. Select=Inf [ numeric ] Select only these high-frequency observations within each low-frequency period; Inf means all observations will be used. Options for Low- to High-Frequency Interpolation Method=\"pchip\" [ string | \"quadSum\" | \"quadMean\" | \"flat\" | \"first\" | \"last\" ] Interpolation method; any option valid for the built-in function interp1 can be used, or 'QuadSum' or 'QuadMean' ; these two options use quadratic interpolation preserving the sum or the average of observations within each period. Position=\"center\" [ \"center\" | \"start\" | \"end\" ] Position of dates within each period in the low-frequency date grid. RemoveWeekends=false [ true | false ] For interpolation to daily frequency only: replace all weekend observations in the final time series (after interpolation) with NaN (or the default missing value as defined in the time series object property .MissingValue ). Description The function handle that you pass in through the Method option when you aggregate the data (convert higher frequency to lower frequency) should behave like the built-in functions mean , sum etc. In other words, it is expected to accept two input arguments: the data to be aggregated; the dimension along which the aggregation is calculated. The function will be called with the second input argument set to 1, as the data are processed en block columnwise. If this call fails, convert() will attempt to call the function with just one input argument, the data, but this is not a safe option under some circumstances since dimension mismatch may occur. Example -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"convert"},{"location":"data-management/series/convert.html#convert","text":"Convert time series to another frequency","title":"convert"},{"location":"data-management/series/convert.html#syntax","text":"outputSeries = convert(inputSeries, newFreq, ...) outputSeries = convert(inputSeries, newFreq, range, ...)","title":"Syntax"},{"location":"data-management/series/convert.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be converted to a new frequency, freq , aggregating or intrapolating the data. newFreq [ Frequency ] New frequency to which the input data will be converted; see Description for frequency formats allowed. range=Inf [ Dater ] Date range on which the input data will be converted; Inf means the conversion will be done on the entire time series range.","title":"Input Arguments"},{"location":"data-management/series/convert.html#output-arguments","text":"outputSeries [ Series ] Output tseries created by converting the inputSeries to the new frequency (aggregating or interpolating).","title":"Output Arguments"},{"location":"data-management/series/convert.html#options","text":"RemoveNaN=false [ true | false ] Exclude NaN values from agreggation. Missing=@default [ @default | numeric | \"previous\" | \"next\" ] Fill missing observations with this value before conversion: @default means no preprocessing; \"previous\" or \"next\" means fill in the nearest preceding or nearest following value available in the time series.","title":"Options"},{"location":"data-management/series/convert.html#options-for-high-to-low-frequency-aggregation","text":"Method=\"mean\" [ \"mean\" | \"sum\" | \"first\" | \"last\" | function_handle ] Aggregation method; \"first\" , \"last\" and \"random\" select the first, last or a random observation from the high-frequency periods contained in the correspoding low-frequency period. RemoveWeekends=false [ true | false ] For daily frequency time series only: remove all weekend observations before aggregation. Select=Inf [ numeric ] Select only these high-frequency observations within each low-frequency period; Inf means all observations will be used.","title":"Options for High- to Low-Frequency Aggregation"},{"location":"data-management/series/convert.html#options-for-low-to-high-frequency-interpolation","text":"Method=\"pchip\" [ string | \"quadSum\" | \"quadMean\" | \"flat\" | \"first\" | \"last\" ] Interpolation method; any option valid for the built-in function interp1 can be used, or 'QuadSum' or 'QuadMean' ; these two options use quadratic interpolation preserving the sum or the average of observations within each period. Position=\"center\" [ \"center\" | \"start\" | \"end\" ] Position of dates within each period in the low-frequency date grid. RemoveWeekends=false [ true | false ] For interpolation to daily frequency only: replace all weekend observations in the final time series (after interpolation) with NaN (or the default missing value as defined in the time series object property .MissingValue ).","title":"Options for Low- to High-Frequency Interpolation"},{"location":"data-management/series/convert.html#description","text":"The function handle that you pass in through the Method option when you aggregate the data (convert higher frequency to lower frequency) should behave like the built-in functions mean , sum etc. In other words, it is expected to accept two input arguments: the data to be aggregated; the dimension along which the aggregation is calculated. The function will be called with the second input argument set to 1, as the data are processed en block columnwise. If this call fails, convert() will attempt to call the function with just one input argument, the data, but this is not a safe option under some circumstances since dimension mismatch may occur.","title":"Description"},{"location":"data-management/series/convert.html#example","text":"-[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/series/empty.html","text":"Series.empty Create empty time series or empty existing time series Syntax x = Series.empty([0, size, ...]) x = Series.empty(0, size, ...) x = Series.empty(x) Input Arguments size [ numeric ] Size of new time series in 2nd and higher dimensions; first dimenstion (time) must be always 0. this [ Series ] Input time series that will be emptied. Output Arguments this [ Series ] Empty time series with the 2nd and higher dimensions the same size as the input time series, and comments preserved. Description Examples Plain Vanilla Example Create a 12-by-3-by-2 monthly time series, and then use Series.empty to create a new, empty series with now rows but the same size in 2nd and higher dimensions x = Series ( mm ( 2020 , 01 ), rand ( 12 , 3 , 2 )) x0 = Series . empty ( x )","title":"empty"},{"location":"data-management/series/empty.html#seriesempty","text":"Create empty time series or empty existing time series","title":"Series.empty"},{"location":"data-management/series/empty.html#syntax","text":"x = Series.empty([0, size, ...]) x = Series.empty(0, size, ...) x = Series.empty(x)","title":"Syntax"},{"location":"data-management/series/empty.html#input-arguments","text":"size [ numeric ] Size of new time series in 2nd and higher dimensions; first dimenstion (time) must be always 0. this [ Series ] Input time series that will be emptied.","title":"Input Arguments"},{"location":"data-management/series/empty.html#output-arguments","text":"this [ Series ] Empty time series with the 2nd and higher dimensions the same size as the input time series, and comments preserved.","title":"Output Arguments"},{"location":"data-management/series/empty.html#description","text":"","title":"Description"},{"location":"data-management/series/empty.html#examples","text":"","title":"Examples"},{"location":"data-management/series/empty.html#plain-vanilla-example","text":"Create a 12-by-3-by-2 monthly time series, and then use Series.empty to create a new, empty series with now rows but the same size in 2nd and higher dimensions x = Series ( mm ( 2020 , 01 ), rand ( 12 , 3 , 2 )) x0 = Series . empty ( x )","title":"Plain Vanilla Example"},{"location":"data-management/series/fillMissing.html","text":"fillMissings Fill missing time series observations Syntax outputSeries = fillMissing(inputSeries, range, method) outputSeries = fillMissing(inputSeries, range, method, specs) outputSeries = fillMissing(inputSeries, range, anotherSeries) Input Arguments inputSeries [ Series ] Input time series whose missing entries lying within the range will be filled with values determined by the method or from anotherSeries . range [ Dater | Inf ] Date range within which missing entries will be looked up in the inputSeries and filled with values determined by the method or from anotherSeries . method [ string | Series ] String specifying the method to obtain missing observations, or a time series with replacement values. The method can be any of the methods valid in the built-in fillmissing() function (see help fillmissing ) or one of the regression methods provided by IrisT: \"regressConstant\" , \"regressTrend\" or \"regressLogTrend\" for a regression on a constant, a regression on a constant and a linear time trend, and a log-regression on a constant and a time trend, respectively. specs [ * ] Some of the methods in the built-in fillmissing() function require addition specification (see help fillmissing ). anotherSeries [ Series ] Another time series whose values will be used to fill missing entries in the inputSeries . Output Arguments outputSeries [ Series ] Output time series whose missing observations found within the range have been filled with values given by the method or from anotherSeries . Description Example -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2019 [IrisToolbox] Solutions Team","title":"fillMissing"},{"location":"data-management/series/fillMissing.html#fillmissings","text":"Fill missing time series observations","title":"fillMissings"},{"location":"data-management/series/fillMissing.html#syntax","text":"outputSeries = fillMissing(inputSeries, range, method) outputSeries = fillMissing(inputSeries, range, method, specs) outputSeries = fillMissing(inputSeries, range, anotherSeries)","title":"Syntax"},{"location":"data-management/series/fillMissing.html#input-arguments","text":"inputSeries [ Series ] Input time series whose missing entries lying within the range will be filled with values determined by the method or from anotherSeries . range [ Dater | Inf ] Date range within which missing entries will be looked up in the inputSeries and filled with values determined by the method or from anotherSeries . method [ string | Series ] String specifying the method to obtain missing observations, or a time series with replacement values. The method can be any of the methods valid in the built-in fillmissing() function (see help fillmissing ) or one of the regression methods provided by IrisT: \"regressConstant\" , \"regressTrend\" or \"regressLogTrend\" for a regression on a constant, a regression on a constant and a linear time trend, and a log-regression on a constant and a time trend, respectively. specs [ * ] Some of the methods in the built-in fillmissing() function require addition specification (see help fillmissing ). anotherSeries [ Series ] Another time series whose values will be used to fill missing entries in the inputSeries .","title":"Input Arguments"},{"location":"data-management/series/fillMissing.html#output-arguments","text":"outputSeries [ Series ] Output time series whose missing observations found within the range have been filled with values given by the method or from anotherSeries .","title":"Output Arguments"},{"location":"data-management/series/fillMissing.html#description","text":"","title":"Description"},{"location":"data-management/series/fillMissing.html#example","text":"-[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2019 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/series/grow.html","text":"grow Cumulate level time series from differences or rates of growth Syntax outputSeries = grow(inputSeries, operator, changeSeries, dates) outputSeries = grow(inputSeries, operator, changeSeries, dates, shift) Input Arguments inputSeries [ Series ] Input time series including at least the initial condition for the level. operator [ \"diff\" | \"difflog\" | \"roc\" | \"pcr\" ] Function expressing the relationship between the resulting outputSeries and the input changeSeries . changeSeries [ Series | numeric ] Time series or numeric scalar specifying the change in the input time series (difference, difference of logs, gross rate of change, or percent change, see the input argument operator ). dates [ Dater ] Date range or a vector of dates on which the level series will be cumulated. shift=-1 [ numeric ] Negative number specifying the lag of the base period to which the change operator function applies. Output Arguments outputSeries [ Series ] Output time series constructed from the input time series, inputSeries , extended by its differences or growth rates, growth . Options Direction=\"forward\" [ \"forward\" | \"backward\" ] Direction of calculations in time; Direction=\"backward\" means that the calculations start from the last date in dates going backwards to the first one, and an inverse operator is applied. Description The function grow() calculates new values at dates (which may not constitute a continuous range, and be discrete time periods instead) using one of the the following formulas (depending on the operator ): $ x_t = x_{t-k} + g_t $ $ x_t = x_{t-k} \\cdot \\exp g_t $ $ x_t = x_{t-k} \\cdot g_t $ $ x_t = x_{t-k} \\cdot \\left( 1 + \\frac{g_t}{100} \\right) $ where $ k $ is a time lag specified by the input argument shift , and the values $ g_t $ are given by the second input series growth . Alternatively, the operator applied to $ x_{t-k} $ and $ g_t $ can be any user-specified function. Any values contained in the input time series inputSeries outside the dates are preserved in the output time series unchanged. Example Extend a quarterly time series x using the gross rates of growth calculated from another time series, y : x = grow(x, \"roc\", roc(y), qq(2020,1):qq(2030,4)); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"grow"},{"location":"data-management/series/grow.html#grow","text":"Cumulate level time series from differences or rates of growth","title":"grow"},{"location":"data-management/series/grow.html#syntax","text":"outputSeries = grow(inputSeries, operator, changeSeries, dates) outputSeries = grow(inputSeries, operator, changeSeries, dates, shift)","title":"Syntax"},{"location":"data-management/series/grow.html#input-arguments","text":"inputSeries [ Series ] Input time series including at least the initial condition for the level. operator [ \"diff\" | \"difflog\" | \"roc\" | \"pcr\" ] Function expressing the relationship between the resulting outputSeries and the input changeSeries . changeSeries [ Series | numeric ] Time series or numeric scalar specifying the change in the input time series (difference, difference of logs, gross rate of change, or percent change, see the input argument operator ). dates [ Dater ] Date range or a vector of dates on which the level series will be cumulated. shift=-1 [ numeric ] Negative number specifying the lag of the base period to which the change operator function applies.","title":"Input Arguments"},{"location":"data-management/series/grow.html#output-arguments","text":"outputSeries [ Series ] Output time series constructed from the input time series, inputSeries , extended by its differences or growth rates, growth .","title":"Output Arguments"},{"location":"data-management/series/grow.html#options","text":"Direction=\"forward\" [ \"forward\" | \"backward\" ] Direction of calculations in time; Direction=\"backward\" means that the calculations start from the last date in dates going backwards to the first one, and an inverse operator is applied.","title":"Options"},{"location":"data-management/series/grow.html#description","text":"The function grow() calculates new values at dates (which may not constitute a continuous range, and be discrete time periods instead) using one of the the following formulas (depending on the operator ): $ x_t = x_{t-k} + g_t $ $ x_t = x_{t-k} \\cdot \\exp g_t $ $ x_t = x_{t-k} \\cdot g_t $ $ x_t = x_{t-k} \\cdot \\left( 1 + \\frac{g_t}{100} \\right) $ where $ k $ is a time lag specified by the input argument shift , and the values $ g_t $ are given by the second input series growth . Alternatively, the operator applied to $ x_{t-k} $ and $ g_t $ can be any user-specified function. Any values contained in the input time series inputSeries outside the dates are preserved in the output time series unchanged.","title":"Description"},{"location":"data-management/series/grow.html#example","text":"Extend a quarterly time series x using the gross rates of growth calculated from another time series, y : x = grow(x, \"roc\", roc(y), qq(2020,1):qq(2030,4)); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/series/linearTrend.html","text":"Series.linearTrend Create time series with linear trend Syntax x = Series.linearTrend(range) x = Series.linearTrend(range, step) x = Series.linearTrend(range, step, startValue) Input Arguments range [ Dater ] Date range on which the trend time series will be created. step=1 [ numeric ] Difference between two consecutive dates in the trend; if omitted, the increment of the trend will be 1. startValue=0 [ numeric ] Starting value for the trend; if omitted, the trend will startValue at zero. Output Arguments x [ Series ] Output time series with a linear trend. Description Example","title":"linearTrend"},{"location":"data-management/series/linearTrend.html#serieslineartrend","text":"Create time series with linear trend","title":"Series.linearTrend"},{"location":"data-management/series/linearTrend.html#syntax","text":"x = Series.linearTrend(range) x = Series.linearTrend(range, step) x = Series.linearTrend(range, step, startValue)","title":"Syntax"},{"location":"data-management/series/linearTrend.html#input-arguments","text":"range [ Dater ] Date range on which the trend time series will be created. step=1 [ numeric ] Difference between two consecutive dates in the trend; if omitted, the increment of the trend will be 1. startValue=0 [ numeric ] Starting value for the trend; if omitted, the trend will startValue at zero.","title":"Input Arguments"},{"location":"data-management/series/linearTrend.html#output-arguments","text":"x [ Series ] Output time series with a linear trend.","title":"Output Arguments"},{"location":"data-management/series/linearTrend.html#description","text":"","title":"Description"},{"location":"data-management/series/linearTrend.html#example","text":"","title":"Example"},{"location":"data-management/series/moving.html","text":"moving Apply function to moving window of time series observation Syntax outputSeries = moving(inputSeries, ...) Input arguments inputSeries [ Series ] Input times series. Output arguments outputSeries [ Series ] Output time series with their observations constructed by applying the the function Function= to a moving window Window= of observations from the inputSeries . Options Function=@mean [ function_handle ] Function to be applied to moving window of observations. Period=false [ true | false ] Force the calculations to be put in a loop period by period; this options works only whemn Window= is not a complex number (in which case the calculations are always period by period). If true , the function Function= is evaluated on a column vector of observations (determined by the Window= specification), one period at a time. If false , the funcion is evaluated on a whole array of observations, and supplied a second input argument 1 to indicate the dimension along which the function is to be calculated. This is consistent with standard functions such as mean , sum , etc. Range=Inf [ Dater | Inf ] Date range to which the inputSeries will be trimmed before running the calculations. __ Window=@auto [ numeric | @auto ] The moving window of observations to which the function Function= will applied to construct the observations of the outputSeries ; see Description and Examples. Description The moving window of observations can be specificied in three different ways: Automatic specification; this only works for time series with a regular date frequency (yearly, half-yearly, quarterly, monthly); the window covers the last moving year including the current observation, e.g. \\(t\\) , \\(t-1\\) , \\(t-2\\) and \\(t-3\\) for quarterly series. This is equivalent to specifying Window=[0, -1, -2, -3] . An exact specification of lags or leads relative to the current observation. A fixed number of available (non-missing) observations from the current period (plus/minus an offset) backward or forward. Exact specification of moving window Use a vector of integers to specify an exact composition of the moving window. Negative numbers mean lags (observations before the current observation), positive numbers mean leads (observations after the current observation), zero means the current observation: \\[ \\mathit{window} = \\left[ a, b, c, \\dots \\right] \\\\[5pt] y_t = f\\left( \\left[ x_{t+a}, x_{t+b}, x_{t+c}, \\dots \\right] \\right) \\] If some of the observations are missing, they are still included in the window (typically a NaN for plain numeric time series), and the result may be a missing observation again. This depends on the function used, consider, for instance, the difference between @mean and @nanmean . Moving window depending on the availability of observations Use a complex number (with a real part denoting the offset and the imaginary part specifying the length of the window) to specify a window consisting of a fixed number of available (non-missing) observations from the current observation backward, or from the current observation forward (positive imaginary part). The a nonzero offset means that the available (non-missing) observation will be looked up starting not from the current observation, but from an observation before (a negative offset) or after (a positive offset). If \\(\\mathit{window}=a + bi\\) , the algorithm is as follows: For each period \\(t\\) , define the output value \\(y_t\\) by applying the function \\(f\\) to a vector of a total of \\(b\\) observations from the input series \\(x_t\\) constructed as described in steps 2 and 3. If the window length (the imaginary part) \\(b\\) is a negative number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going backward, i.e. \\(x_{t+a}, x_{t+a-1}, x_{t+a-2}, \\dots\\) , all the way to the very first observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going backward. If the window length (the imaginary part) \\(b\\) is a positive number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going forward, i.e. \\(x_{t+a}, x_{t+a+1}, x_{t+a+2}, \\dots\\) , all the way to the very last observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going forward. Example Centered moving average and sum Calculate a centered moving average with a total length of the window being 5 observations: x = moving ( x , \"window\" , [ - 2 , - 1 , 0 , 1 , 2 ]) or more concisely x = moving ( x , \"window\" , - 2 : 2 ) Calculate a moving sum on the same window of observations: x = moving(x, \"window\", -2:2, \"function\", @sum) Weighted centered moving average Supply a user defined function to calculate a weighted centered moving average (with the window specification as in the previous example); note that we have to use period=true in this case: func = @( x ) 0.10 * x ( 1 ) + 0.15 * x ( 2 ) + 0.50 * x ( 3 ) + 0.15 * x ( 4 ) + 0.10 * x ( 5 ); y = moving ( x , \"window\" , - 2 : 2 , \"function\" , func , \"period\" , true ) This is though equivalent to a more compact expression y = 0.10 * x { - 2 } + 0.15 * x { - 1 } + 0.50 * x + 0.15 * x { 1 } + 0.10 * x { 2 } Average of 5 last available observations Create a daily series of random observations, and remove weekends: x = Series ( dd ( 2000 , 1 , 1 ): dd ( 2020 , 12 , 31 ), @ randn ); x = removeWeekends ( x ); Create a time series by calculating the average of the five most recent observations available (i.e. excluding any missing observations): y0 = moving ( x , \"window\" , - 5 i ) Create a time series by calculating the average of the five most recent observations available, however now not including the current observation (i.e. select the last five observations from \\(x_{t-1}, x_{t-2}, \\dots\\) y1 = moving ( x , \"window\" , - 1 - 5 i )","title":"moving"},{"location":"data-management/series/moving.html#moving","text":"Apply function to moving window of time series observation","title":"moving"},{"location":"data-management/series/moving.html#syntax","text":"outputSeries = moving(inputSeries, ...)","title":"Syntax"},{"location":"data-management/series/moving.html#input-arguments","text":"inputSeries [ Series ] Input times series.","title":"Input arguments"},{"location":"data-management/series/moving.html#output-arguments","text":"outputSeries [ Series ] Output time series with their observations constructed by applying the the function Function= to a moving window Window= of observations from the inputSeries .","title":"Output arguments"},{"location":"data-management/series/moving.html#options","text":"Function=@mean [ function_handle ] Function to be applied to moving window of observations. Period=false [ true | false ] Force the calculations to be put in a loop period by period; this options works only whemn Window= is not a complex number (in which case the calculations are always period by period). If true , the function Function= is evaluated on a column vector of observations (determined by the Window= specification), one period at a time. If false , the funcion is evaluated on a whole array of observations, and supplied a second input argument 1 to indicate the dimension along which the function is to be calculated. This is consistent with standard functions such as mean , sum , etc. Range=Inf [ Dater | Inf ] Date range to which the inputSeries will be trimmed before running the calculations. __ Window=@auto [ numeric | @auto ] The moving window of observations to which the function Function= will applied to construct the observations of the outputSeries ; see Description and Examples.","title":"Options"},{"location":"data-management/series/moving.html#description","text":"The moving window of observations can be specificied in three different ways: Automatic specification; this only works for time series with a regular date frequency (yearly, half-yearly, quarterly, monthly); the window covers the last moving year including the current observation, e.g. \\(t\\) , \\(t-1\\) , \\(t-2\\) and \\(t-3\\) for quarterly series. This is equivalent to specifying Window=[0, -1, -2, -3] . An exact specification of lags or leads relative to the current observation. A fixed number of available (non-missing) observations from the current period (plus/minus an offset) backward or forward.","title":"Description"},{"location":"data-management/series/moving.html#exact-specification-of-moving-window","text":"Use a vector of integers to specify an exact composition of the moving window. Negative numbers mean lags (observations before the current observation), positive numbers mean leads (observations after the current observation), zero means the current observation: \\[ \\mathit{window} = \\left[ a, b, c, \\dots \\right] \\\\[5pt] y_t = f\\left( \\left[ x_{t+a}, x_{t+b}, x_{t+c}, \\dots \\right] \\right) \\] If some of the observations are missing, they are still included in the window (typically a NaN for plain numeric time series), and the result may be a missing observation again. This depends on the function used, consider, for instance, the difference between @mean and @nanmean .","title":"Exact specification of moving window"},{"location":"data-management/series/moving.html#moving-window-depending-on-the-availability-of-observations","text":"Use a complex number (with a real part denoting the offset and the imaginary part specifying the length of the window) to specify a window consisting of a fixed number of available (non-missing) observations from the current observation backward, or from the current observation forward (positive imaginary part). The a nonzero offset means that the available (non-missing) observation will be looked up starting not from the current observation, but from an observation before (a negative offset) or after (a positive offset). If \\(\\mathit{window}=a + bi\\) , the algorithm is as follows: For each period \\(t\\) , define the output value \\(y_t\\) by applying the function \\(f\\) to a vector of a total of \\(b\\) observations from the input series \\(x_t\\) constructed as described in steps 2 and 3. If the window length (the imaginary part) \\(b\\) is a negative number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going backward, i.e. \\(x_{t+a}, x_{t+a-1}, x_{t+a-2}, \\dots\\) , all the way to the very first observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going backward. If the window length (the imaginary part) \\(b\\) is a positive number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going forward, i.e. \\(x_{t+a}, x_{t+a+1}, x_{t+a+2}, \\dots\\) , all the way to the very last observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going forward.","title":"Moving window depending on the availability of observations"},{"location":"data-management/series/moving.html#example","text":"","title":"Example"},{"location":"data-management/series/moving.html#centered-moving-average-and-sum","text":"Calculate a centered moving average with a total length of the window being 5 observations: x = moving ( x , \"window\" , [ - 2 , - 1 , 0 , 1 , 2 ]) or more concisely x = moving ( x , \"window\" , - 2 : 2 ) Calculate a moving sum on the same window of observations: x = moving(x, \"window\", -2:2, \"function\", @sum)","title":"Centered moving average and sum"},{"location":"data-management/series/moving.html#weighted-centered-moving-average","text":"Supply a user defined function to calculate a weighted centered moving average (with the window specification as in the previous example); note that we have to use period=true in this case: func = @( x ) 0.10 * x ( 1 ) + 0.15 * x ( 2 ) + 0.50 * x ( 3 ) + 0.15 * x ( 4 ) + 0.10 * x ( 5 ); y = moving ( x , \"window\" , - 2 : 2 , \"function\" , func , \"period\" , true ) This is though equivalent to a more compact expression y = 0.10 * x { - 2 } + 0.15 * x { - 1 } + 0.50 * x + 0.15 * x { 1 } + 0.10 * x { 2 }","title":"Weighted centered moving average"},{"location":"data-management/series/moving.html#average-of-5-last-available-observations","text":"Create a daily series of random observations, and remove weekends: x = Series ( dd ( 2000 , 1 , 1 ): dd ( 2020 , 12 , 31 ), @ randn ); x = removeWeekends ( x ); Create a time series by calculating the average of the five most recent observations available (i.e. excluding any missing observations): y0 = moving ( x , \"window\" , - 5 i ) Create a time series by calculating the average of the five most recent observations available, however now not including the current observation (i.e. select the last five observations from \\(x_{t-1}, x_{t-2}, \\dots\\) y1 = moving ( x , \"window\" , - 1 - 5 i )","title":"Average of 5 last available observations"},{"location":"data-management/series/randomlyGrowing.html","text":"Series.randomlyGrowing Create randomly growing time series Syntax outputSeries = Series.randomlyGrowing(range) outputSeries = Series.randomlyGrowing(range, [mean, stdev], ...) Input Arguments range [ Dater ] Date range on which the randomly growing time series will be created. [mean=0, stdev=1] [ numeric ] The mean and std deviation of the Normal distribution from which the log-growth rate or the difference will be drawn; see Description. Output Arguments outputSeries [ Series ] Output time series. Options Comment=\"\" [ string ] Comment, or an array of comments (depending on the Dimensions option) that will be assigned to the outputSeries . Dimensions=1 [ numeric ] The size of the outputSeries in 2nd and higher dimensions. Exponentiate=true [ true | false ] Exponentiate the cumulative sum of random numbers to create the outputSeries . Initial=0 [ numeric ] Initial value for the cumulative sum of random numbers (before exponentiation when Exponentiate=true . Description The output series is created as follows: Generate a series of a total of N random numbers from \\(N(\\mu, \\sigma)\\) , where the mean \\(\\mu\\) and the std deviation \\(\\sigma\\) are determined by the input arguments mean and stdev , respectively, and N is the number of periods in the range . Replace the first random number in the series with Initial , and calculate the cumulative sum of these random numbers. When Exponentiate=true , exponentiate the cumulated series. Example x = Series . randomlyGrowing ( qq ( 2020 , 1 ): qq ( 2030 , 4 ), [ 0.01 , 0.02 ])","title":"randomlyGrowing"},{"location":"data-management/series/randomlyGrowing.html#seriesrandomlygrowing","text":"Create randomly growing time series","title":"Series.randomlyGrowing"},{"location":"data-management/series/randomlyGrowing.html#syntax","text":"outputSeries = Series.randomlyGrowing(range) outputSeries = Series.randomlyGrowing(range, [mean, stdev], ...)","title":"Syntax"},{"location":"data-management/series/randomlyGrowing.html#input-arguments","text":"range [ Dater ] Date range on which the randomly growing time series will be created. [mean=0, stdev=1] [ numeric ] The mean and std deviation of the Normal distribution from which the log-growth rate or the difference will be drawn; see Description.","title":"Input Arguments"},{"location":"data-management/series/randomlyGrowing.html#output-arguments","text":"outputSeries [ Series ] Output time series.","title":"Output Arguments"},{"location":"data-management/series/randomlyGrowing.html#options","text":"Comment=\"\" [ string ] Comment, or an array of comments (depending on the Dimensions option) that will be assigned to the outputSeries . Dimensions=1 [ numeric ] The size of the outputSeries in 2nd and higher dimensions. Exponentiate=true [ true | false ] Exponentiate the cumulative sum of random numbers to create the outputSeries . Initial=0 [ numeric ] Initial value for the cumulative sum of random numbers (before exponentiation when Exponentiate=true .","title":"Options"},{"location":"data-management/series/randomlyGrowing.html#description","text":"The output series is created as follows: Generate a series of a total of N random numbers from \\(N(\\mu, \\sigma)\\) , where the mean \\(\\mu\\) and the std deviation \\(\\sigma\\) are determined by the input arguments mean and stdev , respectively, and N is the number of periods in the range . Replace the first random number in the series with Initial , and calculate the cumulative sum of these random numbers. When Exponentiate=true , exponentiate the cumulated series.","title":"Description"},{"location":"data-management/series/randomlyGrowing.html#example","text":"x = Series . randomlyGrowing ( qq ( 2020 , 1 ): qq ( 2030 , 4 ), [ 0.01 , 0.02 ])","title":"Example"},{"location":"data-management/series/seasonDummy.html","text":"Series.seasonDummy Create time series with seasonal dummies Syntax outputSeries = Series.seasonDummy(range, dummyPeriods, ...) Input Arguments range [ Dater ] Date range on which the time series will be created. dummyPeriods [ numeric ] Numeric periods in which the new outputSeries will be assigned the value 1 in each year of the range ; otherwise, the values will 0 ; the dummyPeriods are frequency specific and depend on the date frequency of the range , e.g. the dummyPeriods represent quarters for a quarterly range , months for a monthly range , etc. Any further input arguments (third, fourth, etc.) will be pased into the Series constructor as the third, fourth, etc. input arguments (i.e. the comments , userData , etc.) Output Arguments outputSeries [ Series ] New time series with the value 1 in the dummyPeriods in each year within the range , and with 0 otherwise. Description Examples x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), 1 ) x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), [ 1 , 7 ])","title":"seasonDummy"},{"location":"data-management/series/seasonDummy.html#seriesseasondummy","text":"Create time series with seasonal dummies","title":"Series.seasonDummy"},{"location":"data-management/series/seasonDummy.html#syntax","text":"outputSeries = Series.seasonDummy(range, dummyPeriods, ...)","title":"Syntax"},{"location":"data-management/series/seasonDummy.html#input-arguments","text":"range [ Dater ] Date range on which the time series will be created. dummyPeriods [ numeric ] Numeric periods in which the new outputSeries will be assigned the value 1 in each year of the range ; otherwise, the values will 0 ; the dummyPeriods are frequency specific and depend on the date frequency of the range , e.g. the dummyPeriods represent quarters for a quarterly range , months for a monthly range , etc. Any further input arguments (third, fourth, etc.) will be pased into the Series constructor as the third, fourth, etc. input arguments (i.e. the comments , userData , etc.)","title":"Input Arguments"},{"location":"data-management/series/seasonDummy.html#output-arguments","text":"outputSeries [ Series ] New time series with the value 1 in the dummyPeriods in each year within the range , and with 0 otherwise.","title":"Output Arguments"},{"location":"data-management/series/seasonDummy.html#description","text":"","title":"Description"},{"location":"data-management/series/seasonDummy.html#examples","text":"x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), 1 ) x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), [ 1 , 7 ])","title":"Examples"},{"location":"data-management/x13/index.html","text":"Interface to X13-Arima","title":"Introduction"},{"location":"data-management/x13/index.html#interface-to-x13-arima","text":"","title":"Interface to X13-Arima"},{"location":"data-management/x13/season.html","text":"x13.season Interface to X13-Arima seasonal adjustment procedure Syntax [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, ...) [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, range, ...) Input Arguments inputSeries [ Series ] Input time series that will be subjected to a X13-ARIMA seasonal adjustment procedure. range=Inf [ Dater ] Date range on which the seasonal adjustment will be performed; any observations outside the range will be clipped off before running the procedure; if not specified, all observations available will be used. Output Arguments outputSeries [ Series ] One or more output time series that correspond to the type of output requested in the option Output . info [ struct ] Information struct with details on the X13-ARIMA procedure run. The info struct includes the following fields and nested fields: .InputFiles - a struct with nested fields named after the extensions of the individual input files, with the content of the these input files. .OutputFiles - a struct with with nested fields named after the extensions of the individual output files produced by the X13-ARIMA procedure, with the content of these output files. The output files always included are .log , .out , and .err . Additional output files are included based on the output series (output tables) requested in the option Output . .Message - the screen output of the X13-ARIMA procedure; this output is also printed on the screen when the option Display=true . .OutputSpecs - selected specs based on the information captured from some output files; the output specs may include OutputSpecs.X11_Mode , OutputSpecs.Arima_Model , OutputSpecs.Arima_AR , OutputSPecs.Arima_MA . .Path - the entire path to the input and output files, including the file name wkithout and extension (the same file name with different extensions is used for both input and output files); when Cleanup=true , the input and output files are all deleted automatically. General Options Output=\"d10\" [ string ] Types of output requested to be returned as time series from the X13-ARIMA procedure; see the Output Tables in Description; the number of the outputSeries arguments corresponds to the number of elements in this option. Range=Inf [ Dater ] Date range that will be extracted from the inputSeries before running the X13-ARIMA procedure; the observations outside the range will be discarded. Display=false [ true | false ] Print the screen output produced by the X13-ARIMA procedure; the message is also captured in the output argument info.Message . Cleanup=true [ true | false ] Delete all input and output files automatically. X13-ARIMA Options Below are listed the X13-ARIMA specs that are supported in the current implemenation; refer to the X13-ARIMA-SEATS manual for details and explanation. To assign values to the individual specs and their settings, follow these rules: if a numeric scalar or vector is expected, assign the option a numeric scalar or vector; if a \"yes\" or \"no\" value is expected, assign a true or false ; if a text value or a list of more than onetext values is expected (such as log in Transform_Function , or td lpyear in Regression_Variables ), enter a single double-quoted string, or an array of strings (such as \"log\" or [\"td\", \"lpyear\"] ); if time series data are expected (such as in Regression_Data ), enter a time series object; if a fixed numeric value is expected (such as fixed coefficients in Arima_AR , as opposed to initial values in the same spec), enter an imaginary value (such as 0.8i ); imaginary values will be printed with an extra F in the input files (such as 0.8F ); Series Spec Series_Title Series_Span Series_ModelSpan Series_Precision Series_Decimals Series_CompType Series_CompWeight Series_AppendBcst Series_AppendFcst Series_Type Series_Save X11 Spec X11_SeasonalMA X11_TrendMA X11_SigmaLim X11_Title X11_AppendFcst X11_AppendBcst X11_Final X11_Print X11_Save X11_SaveLog Transform Spec Transform_Function Transform_Power Transform_Adjust Transform_Title Transform_AicDiff Transform_Print Transform_Save Transform_SaveLog Estimate Spec Estimate_Tol Estimate_MaxIter Estimate_Exact Estimate_OutOfSample Estimate_Print Estimate_Save Estimate_SaveLog Automdl Spec Automdl_MaxOrder Automdl_MaxDiff Automdl_Diff Automdl_AcceptDefault Automdl_CheckMu Automdl_LjungBoxLimit Automdl_Mixed Automdl_Print Automdl_SaveLog Arima Spec Arima_Model Arima_AR Arima_MA Arima_Title Force Spec Force_Type Force_Lambda Force_Rho Force_Round Force_Start Force_Target Force_UseFcst Force_Print Force_Save Forecast Spec Forecast_MaxLead Forecast_MaxBack Forecast_Exclude Forecast_LogNormal Forecast_Print Forecast_Save Regression Spec Regression_Variables Regression_TestAllEaster Regression_Data Regression_User Regression_UserType Regression_AicTest Regression_AicDiff Regression_PVAicTest Regression_TLimit Regression_Chi2Test Regression_Chi2TestCV Regression_Print Regression_Save Regression_SaveLog X11Regression Spec X11Regression_Variables X11Regression_Data X11Regression_User X11Regression_UserType X11Regression_AicTest X11Regression_AicDiff X11Regression_TDPrior X11Regression_Prior X11Regression_Span X11Regression_Sigma X11Regression_Critical X11Regression_OutlierMethod X11Regression_OutlierSpan X11Regression_Print X11Regression_Save X11Regression_SaveLog Seats Spec Seats_AppendFcst Seats_HpCycle Seats_NoAdmiss Seats_QMax Seats_RMod Seats_Out Seats_StatSeas Seats_TabTables Seats_PrintPhtrf Seats_Print Seats_Save Seats_SaveLog Description Bulding the Input File With no options specified, all specs (see their list above) are empty, meaning they are not included in the input file at all and the X13-ARIMA default values (see the X13-ARIMA-SEATS manual) are assumed, with the following exceptions: Series_Start , Series_Data and Series_Period are automatically created based on the inputSeries ; Series_Precision and Series_Decimals are both set to 5 (the maximum precision accepted by the X13-ARIMA procedure); Either an X11 spec or a pair of Seat and Automdl specs are included to force the execution of the X11 type of seasonal adjustment (if d.. types of output tables are requested in Output ) or the execution of the SEAT type of seasonal adjustment (if x.. types of output tables are requested in Output ). If no setting within a particular spec is not defined in the options, the spec itself is not included in the input file. To force the inclusion of an empty spec in the input file (assuming thus the default values for all the settings within that spece), use the name of the spec as an option and set it to true , e.g. (..., \"Automdl\", true, ...) to force the estimation of an ARIMA model based on an automatic model selection procedure. If at least one setting from a particular spec is specified as an option in the fuction call, that spec is included explicitly in the input file. Type of Seasonal Adjustment Two types of seasonal adjustments are available in X13-ARIMA: X11 and SEATS . Which one is invoked depends on the type of output requested in the option Output : the output tables starting with a d refer to X11 (hence, the default Output=\"d11\" invokes X11 and returns the final seasonally adjusted series) whereas the output tables starting with an s refer to SEATS . Depending on the output tables requested, the correct spec for the respective seasonal adjustment procedure will be included in the input file and invoked. The two procedures cannot be combined together in one run; i.e. the option Output cannot combine d.. and s.. output tables. Output Tables (Output Series) The following output tables (i.e. output series) can be requested in the option Output : Name in option Output Output table in X13 Description \"d10\" X11_d10 X11 final seasonal factors \"d11\" X11_d11 X11 final seasonally adjusted series \"d12\" X11_d12 X11 final trend-cycle \"d13\" X11_d13 X11 final irregular component \"d16\" X11_d16 X11 final combined seasonal and trading day factors \"d18\" X11_d18 X11 combined holiday and trading day factors \"s10\" Seats_s10 SEATS final seasonal component \"s11\" Seats_s11 SEATS final seasonal adjustment component \"s12\" Seats_s12 SEATS final trend component \"s13\" Seats_s13 SEATS final irregular component \"s14\" Seats_s14 SEATS final transitory component \"s16\" Seats_s16 SEATS final combined adjustment component \"s18\" Seats_s18 SEATS final adjustment ratio \"cyc\" Seats_cyc SEATS cycle component \"a18\" Series_a18 Original series adjusted for regARIMA calendar effects \"a19\" Series_a19 Original series adjusted for regARIMA outliers \"b1\" Series_b1 Original series, adjusted for prior effects and forecast extended \"mva\" Series_mva Original series with missing values replaced by regARIMA estimates \"saa\" Force_saa Final seasonally adjusted series with constrained yearly totals \"rnd\" Force_rnd Rounded final seasonally adjusted series \"fct\" Forecast_fct Point forecasts on the original scale \"bct\" Forecast_bct Point backcasts on the original scale \"ftr\" Forecast_ftr Point forecasts on the transformed scale \"btr\" Forecast_btr Point backcasts on the transformed scale Example A plain vanilla call xsa = x13 . season ( x ) or [ xsa , info ] = x13 . season ( x ) produces a seasonally adjusted series xsa with all default settings (hence no ARIMA model estimated). Example Estimate an ARIMA model based on an automatic model selection procedures, use the ARIMA information in the seasonal adjustment, and return the estimated ARIMA model in the output info struct: [xsa, info] = x13.season(x, \"Automdl\", true, \"Estimate_Save\", \"mdl\") Example Request additional output series: the seasonally adjusted series, the seasonal factors and the trend cycle component: [ xsa , xsf , xtc , info ] = x13 . season ( x , \"Output\" , [ \"d11\" , \"d10\" , \"d12\" ]); Example Run seasonal adjustment based on an automatically selected ARIMA model with dummy variables of additive outliers in period 2017Q3, 2017Q4 and 2018Q1: xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Variables\" , \"aos2017.3-2018.1\" ... ); This call is equivalent to creating the dummies manually (a time series object with three columns), and using the option Regression_Data instead: dummy = Series ( startDate : endDate , zeros ( 1 , 3 )); dummy ( qq ( 2017 , 3 ), 1 ) = 1 ; dummy ( qq ( 2017 , 4 ), 2 ) = 1 ; dummy ( qq ( 2018 , 1 ), 3 ) = 1 ; xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Data\" , dummy ... );","title":"season"},{"location":"data-management/x13/season.html#x13season","text":"Interface to X13-Arima seasonal adjustment procedure","title":"x13.season"},{"location":"data-management/x13/season.html#syntax","text":"[outputSeries, outputSeries, ..., info] = x13.season(inputSeries, ...) [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, range, ...)","title":"Syntax"},{"location":"data-management/x13/season.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be subjected to a X13-ARIMA seasonal adjustment procedure. range=Inf [ Dater ] Date range on which the seasonal adjustment will be performed; any observations outside the range will be clipped off before running the procedure; if not specified, all observations available will be used.","title":"Input Arguments"},{"location":"data-management/x13/season.html#output-arguments","text":"outputSeries [ Series ] One or more output time series that correspond to the type of output requested in the option Output . info [ struct ] Information struct with details on the X13-ARIMA procedure run. The info struct includes the following fields and nested fields: .InputFiles - a struct with nested fields named after the extensions of the individual input files, with the content of the these input files. .OutputFiles - a struct with with nested fields named after the extensions of the individual output files produced by the X13-ARIMA procedure, with the content of these output files. The output files always included are .log , .out , and .err . Additional output files are included based on the output series (output tables) requested in the option Output . .Message - the screen output of the X13-ARIMA procedure; this output is also printed on the screen when the option Display=true . .OutputSpecs - selected specs based on the information captured from some output files; the output specs may include OutputSpecs.X11_Mode , OutputSpecs.Arima_Model , OutputSpecs.Arima_AR , OutputSPecs.Arima_MA . .Path - the entire path to the input and output files, including the file name wkithout and extension (the same file name with different extensions is used for both input and output files); when Cleanup=true , the input and output files are all deleted automatically.","title":"Output Arguments"},{"location":"data-management/x13/season.html#general-options","text":"Output=\"d10\" [ string ] Types of output requested to be returned as time series from the X13-ARIMA procedure; see the Output Tables in Description; the number of the outputSeries arguments corresponds to the number of elements in this option. Range=Inf [ Dater ] Date range that will be extracted from the inputSeries before running the X13-ARIMA procedure; the observations outside the range will be discarded. Display=false [ true | false ] Print the screen output produced by the X13-ARIMA procedure; the message is also captured in the output argument info.Message . Cleanup=true [ true | false ] Delete all input and output files automatically.","title":"General Options"},{"location":"data-management/x13/season.html#x13-arima-options","text":"Below are listed the X13-ARIMA specs that are supported in the current implemenation; refer to the X13-ARIMA-SEATS manual for details and explanation. To assign values to the individual specs and their settings, follow these rules: if a numeric scalar or vector is expected, assign the option a numeric scalar or vector; if a \"yes\" or \"no\" value is expected, assign a true or false ; if a text value or a list of more than onetext values is expected (such as log in Transform_Function , or td lpyear in Regression_Variables ), enter a single double-quoted string, or an array of strings (such as \"log\" or [\"td\", \"lpyear\"] ); if time series data are expected (such as in Regression_Data ), enter a time series object; if a fixed numeric value is expected (such as fixed coefficients in Arima_AR , as opposed to initial values in the same spec), enter an imaginary value (such as 0.8i ); imaginary values will be printed with an extra F in the input files (such as 0.8F );","title":"X13-ARIMA Options"},{"location":"data-management/x13/season.html#series-spec","text":"Series_Title Series_Span Series_ModelSpan Series_Precision Series_Decimals Series_CompType Series_CompWeight Series_AppendBcst Series_AppendFcst Series_Type Series_Save","title":"Series Spec"},{"location":"data-management/x13/season.html#x11-spec","text":"X11_SeasonalMA X11_TrendMA X11_SigmaLim X11_Title X11_AppendFcst X11_AppendBcst X11_Final X11_Print X11_Save X11_SaveLog","title":"X11 Spec"},{"location":"data-management/x13/season.html#transform-spec","text":"Transform_Function Transform_Power Transform_Adjust Transform_Title Transform_AicDiff Transform_Print Transform_Save Transform_SaveLog","title":"Transform Spec"},{"location":"data-management/x13/season.html#estimate-spec","text":"Estimate_Tol Estimate_MaxIter Estimate_Exact Estimate_OutOfSample Estimate_Print Estimate_Save Estimate_SaveLog","title":"Estimate Spec"},{"location":"data-management/x13/season.html#automdl-spec","text":"Automdl_MaxOrder Automdl_MaxDiff Automdl_Diff Automdl_AcceptDefault Automdl_CheckMu Automdl_LjungBoxLimit Automdl_Mixed Automdl_Print Automdl_SaveLog","title":"Automdl Spec"},{"location":"data-management/x13/season.html#arima-spec","text":"Arima_Model Arima_AR Arima_MA Arima_Title","title":"Arima Spec"},{"location":"data-management/x13/season.html#force-spec","text":"Force_Type Force_Lambda Force_Rho Force_Round Force_Start Force_Target Force_UseFcst Force_Print Force_Save","title":"Force Spec"},{"location":"data-management/x13/season.html#forecast-spec","text":"Forecast_MaxLead Forecast_MaxBack Forecast_Exclude Forecast_LogNormal Forecast_Print Forecast_Save","title":"Forecast Spec"},{"location":"data-management/x13/season.html#regression-spec","text":"Regression_Variables Regression_TestAllEaster Regression_Data Regression_User Regression_UserType Regression_AicTest Regression_AicDiff Regression_PVAicTest Regression_TLimit Regression_Chi2Test Regression_Chi2TestCV Regression_Print Regression_Save Regression_SaveLog","title":"Regression Spec"},{"location":"data-management/x13/season.html#x11regression-spec","text":"X11Regression_Variables X11Regression_Data X11Regression_User X11Regression_UserType X11Regression_AicTest X11Regression_AicDiff X11Regression_TDPrior X11Regression_Prior X11Regression_Span X11Regression_Sigma X11Regression_Critical X11Regression_OutlierMethod X11Regression_OutlierSpan X11Regression_Print X11Regression_Save X11Regression_SaveLog","title":"X11Regression Spec"},{"location":"data-management/x13/season.html#seats-spec","text":"Seats_AppendFcst Seats_HpCycle Seats_NoAdmiss Seats_QMax Seats_RMod Seats_Out Seats_StatSeas Seats_TabTables Seats_PrintPhtrf Seats_Print Seats_Save Seats_SaveLog","title":"Seats Spec"},{"location":"data-management/x13/season.html#description","text":"","title":"Description"},{"location":"data-management/x13/season.html#bulding-the-input-file","text":"With no options specified, all specs (see their list above) are empty, meaning they are not included in the input file at all and the X13-ARIMA default values (see the X13-ARIMA-SEATS manual) are assumed, with the following exceptions: Series_Start , Series_Data and Series_Period are automatically created based on the inputSeries ; Series_Precision and Series_Decimals are both set to 5 (the maximum precision accepted by the X13-ARIMA procedure); Either an X11 spec or a pair of Seat and Automdl specs are included to force the execution of the X11 type of seasonal adjustment (if d.. types of output tables are requested in Output ) or the execution of the SEAT type of seasonal adjustment (if x.. types of output tables are requested in Output ). If no setting within a particular spec is not defined in the options, the spec itself is not included in the input file. To force the inclusion of an empty spec in the input file (assuming thus the default values for all the settings within that spece), use the name of the spec as an option and set it to true , e.g. (..., \"Automdl\", true, ...) to force the estimation of an ARIMA model based on an automatic model selection procedure. If at least one setting from a particular spec is specified as an option in the fuction call, that spec is included explicitly in the input file.","title":"Bulding the Input File"},{"location":"data-management/x13/season.html#type-of-seasonal-adjustment","text":"Two types of seasonal adjustments are available in X13-ARIMA: X11 and SEATS . Which one is invoked depends on the type of output requested in the option Output : the output tables starting with a d refer to X11 (hence, the default Output=\"d11\" invokes X11 and returns the final seasonally adjusted series) whereas the output tables starting with an s refer to SEATS . Depending on the output tables requested, the correct spec for the respective seasonal adjustment procedure will be included in the input file and invoked. The two procedures cannot be combined together in one run; i.e. the option Output cannot combine d.. and s.. output tables.","title":"Type of Seasonal Adjustment"},{"location":"data-management/x13/season.html#output-tables-output-series","text":"The following output tables (i.e. output series) can be requested in the option Output : Name in option Output Output table in X13 Description \"d10\" X11_d10 X11 final seasonal factors \"d11\" X11_d11 X11 final seasonally adjusted series \"d12\" X11_d12 X11 final trend-cycle \"d13\" X11_d13 X11 final irregular component \"d16\" X11_d16 X11 final combined seasonal and trading day factors \"d18\" X11_d18 X11 combined holiday and trading day factors \"s10\" Seats_s10 SEATS final seasonal component \"s11\" Seats_s11 SEATS final seasonal adjustment component \"s12\" Seats_s12 SEATS final trend component \"s13\" Seats_s13 SEATS final irregular component \"s14\" Seats_s14 SEATS final transitory component \"s16\" Seats_s16 SEATS final combined adjustment component \"s18\" Seats_s18 SEATS final adjustment ratio \"cyc\" Seats_cyc SEATS cycle component \"a18\" Series_a18 Original series adjusted for regARIMA calendar effects \"a19\" Series_a19 Original series adjusted for regARIMA outliers \"b1\" Series_b1 Original series, adjusted for prior effects and forecast extended \"mva\" Series_mva Original series with missing values replaced by regARIMA estimates \"saa\" Force_saa Final seasonally adjusted series with constrained yearly totals \"rnd\" Force_rnd Rounded final seasonally adjusted series \"fct\" Forecast_fct Point forecasts on the original scale \"bct\" Forecast_bct Point backcasts on the original scale \"ftr\" Forecast_ftr Point forecasts on the transformed scale \"btr\" Forecast_btr Point backcasts on the transformed scale","title":"Output Tables (Output Series)"},{"location":"data-management/x13/season.html#example","text":"A plain vanilla call xsa = x13 . season ( x ) or [ xsa , info ] = x13 . season ( x ) produces a seasonally adjusted series xsa with all default settings (hence no ARIMA model estimated).","title":"Example"},{"location":"data-management/x13/season.html#example_1","text":"Estimate an ARIMA model based on an automatic model selection procedures, use the ARIMA information in the seasonal adjustment, and return the estimated ARIMA model in the output info struct: [xsa, info] = x13.season(x, \"Automdl\", true, \"Estimate_Save\", \"mdl\")","title":"Example"},{"location":"data-management/x13/season.html#example_2","text":"Request additional output series: the seasonally adjusted series, the seasonal factors and the trend cycle component: [ xsa , xsf , xtc , info ] = x13 . season ( x , \"Output\" , [ \"d11\" , \"d10\" , \"d12\" ]);","title":"Example"},{"location":"data-management/x13/season.html#example_3","text":"Run seasonal adjustment based on an automatically selected ARIMA model with dummy variables of additive outliers in period 2017Q3, 2017Q4 and 2018Q1: xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Variables\" , \"aos2017.3-2018.1\" ... ); This call is equivalent to creating the dummies manually (a time series object with three columns), and using the option Regression_Data instead: dummy = Series ( startDate : endDate , zeros ( 1 , 3 )); dummy ( qq ( 2017 , 3 ), 1 ) = 1 ; dummy ( qq ( 2017 , 4 ), 2 ) = 1 ; dummy ( qq ( 2018 , 1 ), 3 ) = 1 ; xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Data\" , dummy ... );","title":"Example"},{"location":"reporting/index.html","text":"Reporting","title":"Introduction"},{"location":"reporting/index.html#reporting","text":"","title":"Reporting"},{"location":"reporting/chartpack/index.html","text":"Databank Chartpacks Categorical List of Functions Creating New Chartpacks Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields Modifiable Properties of Chartpacks Property Description","title":"Introduction"},{"location":"reporting/chartpack/index.html#databank-chartpacks","text":"","title":"Databank Chartpacks"},{"location":"reporting/chartpack/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"reporting/chartpack/index.html#creating-new-chartpacks","text":"Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields","title":"Creating New Chartpacks"},{"location":"reporting/chartpack/index.html#modifiable-properties-of-chartpacks","text":"Property Description","title":"Modifiable Properties of Chartpacks"},{"location":"reporting/chartpack/Chartpack.html","text":"databank.Chartpack Create a new Chartpack object for plotting databank fields Syntax ch = databank.Chartpack() Output Arguments ch [ databank.Chartpack ] New empty databank.Chartpack object","title":"Chartpack"},{"location":"reporting/chartpack/Chartpack.html#databankchartpack","text":"Create a new Chartpack object for plotting databank fields","title":"databank.Chartpack"},{"location":"reporting/chartpack/Chartpack.html#syntax","text":"ch = databank.Chartpack()","title":"Syntax"},{"location":"reporting/chartpack/Chartpack.html#output-arguments","text":"ch [ databank.Chartpack ] New empty databank.Chartpack object","title":"Output Arguments"},{"location":"reporting/rephrase/index.html","text":"Interface to rephrase.js","title":"Introduction"},{"location":"reporting/rephrase/index.html#interface-to-rephrasejs","text":"","title":"Interface to rephrase.js"},{"location":"statistics-utilities/index.html","text":"Statistics Utilities","title":"Introduction"},{"location":"statistics-utilities/index.html#statistics-utilities","text":"","title":"Statistics Utilities"},{"location":"statistics-utilities/distribution/index.html","text":"Distribution Package","title":"Introduction"},{"location":"statistics-utilities/distribution/index.html#distribution-package","text":"","title":"Distribution Package"},{"location":"statistics-utilities/distribution/beta/index.html","text":"Beta Distribution Constructors The following are static constructors and need to be called with distribution.Beta. preceding their names. fromAB - Beta distribution from parameters A and B fromMeanVar - Beta distribution from mean and variance fromMeanStd - Beta distribution from mean and std deviation fromModeVar - Beta distribution from mode and variance fromModeStd - Beta distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution A - Parameter A of Beta distribution Beta - Beta distribution object Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Introduction"},{"location":"statistics-utilities/distribution/beta/index.html#beta-distribution","text":"Constructors The following are static constructors and need to be called with distribution.Beta. preceding their names. fromAB - Beta distribution from parameters A and B fromMeanVar - Beta distribution from mean and variance fromMeanStd - Beta distribution from mean and std deviation fromModeVar - Beta distribution from mode and variance fromModeStd - Beta distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution A - Parameter A of Beta distribution Beta - Beta distribution object Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Beta Distribution"},{"location":"statistics-utilities/distribution/gamma/index.html","text":"Gamma Distribution Constructors The following are static constructors and need to be called with distribution.Gamma. preceding their names. fromShapeScale - Gamma distribution from shape and scale parameters fromAlphaBeta - Gamma distribution from alpha and beta parameters fromMeanVar - Gamma distribution from mean and variance fromMeanStd - Gamma distribution from mean and std deviation fromModeVar - Gamma distribution from mode and variance fromModeStd - Gamma distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution Alpha - Alpha (shape) parameter of Gamma distribution Beta - Beta (scale) parameter of Gamma distribution Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Shape - Shape parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Introduction"},{"location":"statistics-utilities/distribution/gamma/index.html#gamma-distribution","text":"Constructors The following are static constructors and need to be called with distribution.Gamma. preceding their names. fromShapeScale - Gamma distribution from shape and scale parameters fromAlphaBeta - Gamma distribution from alpha and beta parameters fromMeanVar - Gamma distribution from mean and variance fromMeanStd - Gamma distribution from mean and std deviation fromModeVar - Gamma distribution from mode and variance fromModeStd - Gamma distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution Alpha - Alpha (shape) parameter of Gamma distribution Beta - Beta (scale) parameter of Gamma distribution Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Shape - Shape parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Gamma Distribution"},{"location":"structural-modeling/index.html","text":"Structural Modeling","title":"Introduction"},{"location":"structural-modeling/index.html#structural-modeling","text":"","title":"Structural Modeling"},{"location":"structural-modeling/explanatory/index.html","text":"Explanatory Equations","title":"Introduction"},{"location":"structural-modeling/explanatory/index.html#explanatory-equations","text":"","title":"Explanatory Equations"},{"location":"structural-modeling/explanatory/regress.html","text":"regress Estimate parameters and residual models in Explanatory object Syntax [expy, outputDb, info] = regress(expy, inputDb, fittedRange, ...) Input Arguments expy [ Explanatory ] Explanatory object or array whose parameters (associated with regression terms) will be estimated by running a single-equation linear regression; only those parameters that have the corresonding element in .Fixed set to NaN will be estimated.k inputDb [ struct | Dictionary ] Input databank from which the time series for each variable in the Explanatory object or array will be retrieved. fittedRange [ DateWrapper ] Date range on which the linear regression(s) will be fitted; this range does not include the pre-sample initial condition if there are lags in the Explanatory object or array. Output Arguments expy [ Explanatory ] Output Explanatory object or array with the parameters estimated. outputDb [ struct | Dictionary ] Output databank inclusive of the fitted values and residuals (whose names will be created using the .FittedNamePattern and .ResidualNamePattern . info [ struct ] Information structure with the following fields: .FittedRange - A K-by-N cell array with the dates of the fitted periods for each of the K equations and each of the N data pages or parameter variants. .ExitFlagsResidualModels - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the residual models; NaN means no residual model was estimated. .ExitFlagsParameters - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the parameters; NaN means the parameters were estimated by linear regression with no iterative procedure. Options AppendInput=false [ true | false ] Append post-sample data from the inputDb to the outputDb . __ MissingObservations=\"warning\" [ \"error\" | \"warning\" | \"silent\" ] Action taken when some within-sample observations are missing: \"error\" means an error message will be thrown; \"warning\" means these observations will be excluded from the estimation sample with a warning; \"silent\" means these observations will be excluded from the estimation sample silently. PrependInput=false [ true | false ] Prepend pre-sample data from the inputDb to the outputDb . Description Example Create an Explanatory object from a string inclusive of three regression terms, i.e. additive terms preceded by +@* or -@* : expy0 = Explanatory . fromString ( \"difflog(x) = @ + @*difflog(x{-1}) + @*log(z)\" ); expy0 . Parameters Assign some parameters to the three regression terms: expy0 . Parameters = [ 0.002 , 0.8 , 1 ]; Simulate the equation period by period, using random shocks (names 'res_x' by default) and random observations for z : rng ( 981 ); d0 = struct (); d0 . x = Series ( qq ( 2020 , 1 ), ones ( 40 , 1 )); d0 . z = Series ( qq ( 2020 , 1 ), exp ( randn ( 40 , 1 ) / 10 )); d0 . res_x = Series ( qq ( 2020 , 1 ), randn ( 40 , 1 ) / 50 ); d1 = simulate ( expy0 , d0 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); Estimate the parameters using the simulated data, and compare the parameter estimates and the estimated residuals with their \"true\" values: [ expy2 , d2 ] = regress ( expy0 , d1 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); [ expy0 . Parameters ; expy2 . Parameters ] plot ([ d0 . res_x , d2 . res_x ]);","title":"regress"},{"location":"structural-modeling/explanatory/regress.html#regress","text":"Estimate parameters and residual models in Explanatory object","title":"regress"},{"location":"structural-modeling/explanatory/regress.html#syntax","text":"[expy, outputDb, info] = regress(expy, inputDb, fittedRange, ...)","title":"Syntax"},{"location":"structural-modeling/explanatory/regress.html#input-arguments","text":"expy [ Explanatory ] Explanatory object or array whose parameters (associated with regression terms) will be estimated by running a single-equation linear regression; only those parameters that have the corresonding element in .Fixed set to NaN will be estimated.k inputDb [ struct | Dictionary ] Input databank from which the time series for each variable in the Explanatory object or array will be retrieved. fittedRange [ DateWrapper ] Date range on which the linear regression(s) will be fitted; this range does not include the pre-sample initial condition if there are lags in the Explanatory object or array.","title":"Input Arguments"},{"location":"structural-modeling/explanatory/regress.html#output-arguments","text":"expy [ Explanatory ] Output Explanatory object or array with the parameters estimated. outputDb [ struct | Dictionary ] Output databank inclusive of the fitted values and residuals (whose names will be created using the .FittedNamePattern and .ResidualNamePattern . info [ struct ] Information structure with the following fields: .FittedRange - A K-by-N cell array with the dates of the fitted periods for each of the K equations and each of the N data pages or parameter variants. .ExitFlagsResidualModels - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the residual models; NaN means no residual model was estimated. .ExitFlagsParameters - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the parameters; NaN means the parameters were estimated by linear regression with no iterative procedure.","title":"Output Arguments"},{"location":"structural-modeling/explanatory/regress.html#options","text":"AppendInput=false [ true | false ] Append post-sample data from the inputDb to the outputDb . __ MissingObservations=\"warning\" [ \"error\" | \"warning\" | \"silent\" ] Action taken when some within-sample observations are missing: \"error\" means an error message will be thrown; \"warning\" means these observations will be excluded from the estimation sample with a warning; \"silent\" means these observations will be excluded from the estimation sample silently. PrependInput=false [ true | false ] Prepend pre-sample data from the inputDb to the outputDb .","title":"Options"},{"location":"structural-modeling/explanatory/regress.html#description","text":"","title":"Description"},{"location":"structural-modeling/explanatory/regress.html#example","text":"Create an Explanatory object from a string inclusive of three regression terms, i.e. additive terms preceded by +@* or -@* : expy0 = Explanatory . fromString ( \"difflog(x) = @ + @*difflog(x{-1}) + @*log(z)\" ); expy0 . Parameters Assign some parameters to the three regression terms: expy0 . Parameters = [ 0.002 , 0.8 , 1 ]; Simulate the equation period by period, using random shocks (names 'res_x' by default) and random observations for z : rng ( 981 ); d0 = struct (); d0 . x = Series ( qq ( 2020 , 1 ), ones ( 40 , 1 )); d0 . z = Series ( qq ( 2020 , 1 ), exp ( randn ( 40 , 1 ) / 10 )); d0 . res_x = Series ( qq ( 2020 , 1 ), randn ( 40 , 1 ) / 50 ); d1 = simulate ( expy0 , d0 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); Estimate the parameters using the simulated data, and compare the parameter estimates and the estimated residuals with their \"true\" values: [ expy2 , d2 ] = regress ( expy0 , d1 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); [ expy0 . Parameters ; expy2 . Parameters ] plot ([ d0 . res_x , d2 . res_x ]);","title":"Example"},{"location":"structural-modeling/linear/index.html","text":"Linear Systems","title":"Introduction"},{"location":"structural-modeling/linear/index.html#linear-systems","text":"","title":"Linear Systems"},{"location":"structural-modeling/model/index.html","text":"Models","title":"Introduction"},{"location":"structural-modeling/model/index.html#models","text":"","title":"Models"},{"location":"structural-modeling/plan/index.html","text":"Simulation Plans","title":"Introduction"},{"location":"structural-modeling/plan/index.html#simulation-plans","text":"","title":"Simulation Plans"},{"location":"structural-modeling/slang/index.html","text":"Model Source File Language","title":"Introduction"},{"location":"structural-modeling/slang/index.html#model-source-file-language","text":"","title":"Model Source File Language"},{"location":"time-series-modeling/index.html","text":"Time Series Modeling","title":"Introduction"},{"location":"time-series-modeling/index.html#time-series-modeling","text":"","title":"Time Series Modeling"},{"location":"time-series-modeling/dfm/index.html","text":"Dynamic Factor Models","title":"Introduction"},{"location":"time-series-modeling/dfm/index.html#dynamic-factor-models","text":"","title":"Dynamic Factor Models"},{"location":"time-series-modeling/dummy/index.html","text":"Estimation with Prior Dummies","title":"Introduction"},{"location":"time-series-modeling/dummy/index.html#estimation-with-prior-dummies","text":"","title":"Estimation with Prior Dummies"},{"location":"time-series-modeling/panel/index.html","text":"Panel VARs","title":"Introduction"},{"location":"time-series-modeling/panel/index.html#panel-vars","text":"","title":"Panel VARs"},{"location":"time-series-modeling/svar/index.html","text":"Structural VARs","title":"Introduction"},{"location":"time-series-modeling/svar/index.html#structural-vars","text":"","title":"Structural VARs"},{"location":"time-series-modeling/var/index.html","text":"Vector Autoregressions","title":"Introduction"},{"location":"time-series-modeling/var/index.html#vector-autoregressions","text":"","title":"Vector Autoregressions"}]}