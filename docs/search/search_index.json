{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Home The Iris Toolbox is a macroeconomic modeling package for Matlab developed by the Iris Solutions Team since 2001. Setup IrisT provides tools to support the typical workflows in the theoretical development and practical operation of macroeconomic models and model-based production frameworks. In a seamless command line oriented interface, the toolbox integrates the following four broad areas: Structural modeling tools Tools for development, implementation, diagnosis, and operation of advanced macro models, including nonlinear nonstationary models with forward-looking (model-consistent, rational) expectations, or systems of nonlinear empirical equations. Time series modeling Tools for estimation, diagnosis and operation of empirical univariate and multivariate time series models with focus on dimension reduction, such as VAR, bayesian VAR or dynamic factor models. Data management Data management and time series processing functions optimized for use in practical macroeconomic models. Reporting Frameworks for the on-screen and HTML visualization of results. Furthermore, IrisT offers a number of utility functions to make macroeconomic modeling more convenient in Matlab: Utilities Utilities for","title":"Home"},{"location":"index.html#home","text":"The Iris Toolbox is a macroeconomic modeling package for Matlab developed by the Iris Solutions Team since 2001.","title":"Home"},{"location":"index.html#setup","text":"IrisT provides tools to support the typical workflows in the theoretical development and practical operation of macroeconomic models and model-based production frameworks. In a seamless command line oriented interface, the toolbox integrates the following four broad areas: Structural modeling tools Tools for development, implementation, diagnosis, and operation of advanced macro models, including nonlinear nonstationary models with forward-looking (model-consistent, rational) expectations, or systems of nonlinear empirical equations.","title":" Setup"},{"location":"index.html#time-series-modeling","text":"Tools for estimation, diagnosis and operation of empirical univariate and multivariate time series models with focus on dimension reduction, such as VAR, bayesian VAR or dynamic factor models.","title":" Time series modeling"},{"location":"index.html#data-management","text":"Data management and time series processing functions optimized for use in practical macroeconomic models.","title":" Data management"},{"location":"index.html#reporting","text":"Frameworks for the on-screen and HTML visualization of results. Furthermore, IrisT offers a number of utility functions to make macroeconomic modeling more convenient in Matlab:","title":" Reporting"},{"location":"index.html#utilities","text":"Utilities for","title":" Utilities"},{"location":"DataManagement/index.html","text":"Overview of data management tools","title":"Overview of data management tools"},{"location":"DataManagement/index.html#overview-of-data-management-tools","text":"","title":"Overview of data management tools"},{"location":"DataManagement/Dater/index.html","text":"Overview of IrisT dates and Dater objects IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with support for business daily frequency) integer (numbered observations) Categorical list of functions Dater constructors Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations) Converting dates Function Description toString Print IrisT dates as formatted strings","title":"Overview of IrisT dates and Dater objects"},{"location":"DataManagement/Dater/index.html#overview-of-irist-dates-and-dater-objects","text":"IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with support for business daily frequency) integer (numbered observations)","title":"Overview of IrisT dates and Dater objects"},{"location":"DataManagement/Dater/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"DataManagement/Dater/index.html#dater-constructors","text":"Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations)","title":"Dater constructors"},{"location":"DataManagement/Dater/index.html#converting-dates","text":"Function Description toString Print IrisT dates as formatted strings","title":"Converting dates"},{"location":"DataManagement/Dater/dd.html","text":"dd | Dater.dd | dater.dd Create daily dates Shortcut syntax for Dater objects date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year) Syntax for Dater objects date = Dater.dd(___) Syntax for numeric date codes date = dater.dd(___) Input arguments year [ numeric ] Calendar year. month=1 [ numeric | string ] Calendar month of the year ; can be specified either as an integer or as a string representing the English names of the months (resolved from the first three letters). day=1 [ numeric ] Calendar day of the month ; \"end\" means the last day of the respective month (considering leap years for February). Output arguments date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode. Description The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers. Example Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"dd  |  Dater.dd  |  dater.dd"},{"location":"DataManagement/Dater/dd.html#dd-daterdd-daterdd","text":"Create daily dates","title":"dd  |  Dater.dd  |  dater.dd"},{"location":"DataManagement/Dater/dd.html#shortcut-syntax-for-dater-objects","text":"date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year)","title":"Shortcut syntax for Dater objects"},{"location":"DataManagement/Dater/dd.html#syntax-for-dater-objects","text":"date = Dater.dd(___)","title":"Syntax for Dater objects"},{"location":"DataManagement/Dater/dd.html#syntax-for-numeric-date-codes","text":"date = dater.dd(___)","title":"Syntax for numeric date codes"},{"location":"DataManagement/Dater/dd.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric | string ] Calendar month of the year ; can be specified either as an integer or as a string representing the English names of the months (resolved from the first three letters). day=1 [ numeric ] Calendar day of the month ; \"end\" means the last day of the respective month (considering leap years for February).","title":"Input arguments"},{"location":"DataManagement/Dater/dd.html#output-arguments","text":"date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode.","title":"Output arguments"},{"location":"DataManagement/Dater/dd.html#description","text":"The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers.","title":"Description"},{"location":"DataManagement/Dater/dd.html#example","text":"Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"Example"},{"location":"DataManagement/Dater/hh.html","text":"hh | Dater.hh | dater.hh Create half-yearly dates Shortcut syntax to create Dater objects date = hh(year, half) date = hh(year, \"end\") date = hh(year) Syntax to create Dater objects date = hh(...) Syntax to create numeric date codes dateCode = dater.hh(...) Input arguments year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 . Output arguments date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode. Description Example Calculate the number of halfyears between two halfyearly dates t1 = hh ( 2020 , 1 ); t2 = hh ( 2024 , 2 ); n = t2 - t1","title":"hh  |  Dater.hh  |  dater.hh"},{"location":"DataManagement/Dater/hh.html#hh-daterhh-daterhh","text":"Create half-yearly dates","title":"hh  |  Dater.hh  |  dater.hh"},{"location":"DataManagement/Dater/hh.html#shortcut-syntax-to-create-dater-objects","text":"date = hh(year, half) date = hh(year, \"end\") date = hh(year)","title":"Shortcut syntax to create Dater objects"},{"location":"DataManagement/Dater/hh.html#syntax-to-create-dater-objects","text":"date = hh(...)","title":"Syntax to create Dater objects"},{"location":"DataManagement/Dater/hh.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.hh(...)","title":"Syntax to create numeric date codes"},{"location":"DataManagement/Dater/hh.html#input-arguments","text":"year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 .","title":"Input arguments"},{"location":"DataManagement/Dater/hh.html#output-arguments","text":"date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode.","title":"Output arguments"},{"location":"DataManagement/Dater/hh.html#description","text":"","title":"Description"},{"location":"DataManagement/Dater/hh.html#example","text":"Calculate the number of halfyears between two halfyearly dates t1 = hh ( 2020 , 1 ); t2 = hh ( 2024 , 2 ); n = t2 - t1","title":"Example"},{"location":"DataManagement/Dater/ii.html","text":"ii | Dater.ii | dater.ii Create integer dates (numbered observations) Shortcut Syntax to Create Dater Objects date = ii(integer) Syntax to Create Dater Objects date = Dater.ii(...) Syntax to Create Numeric Date Codes dateCode = dater.ii(...) Input Arguments integer [ numeric ] Integer number, any non-integers will be floored. Output Arguments date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode. Description This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed. Example Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"ii  |  Dater.ii  |  dater.ii"},{"location":"DataManagement/Dater/ii.html#ii-daterii-daterii","text":"Create integer dates (numbered observations)","title":"ii  |  Dater.ii  |  dater.ii"},{"location":"DataManagement/Dater/ii.html#shortcut-syntax-to-create-dater-objects","text":"date = ii(integer)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/ii.html#syntax-to-create-dater-objects","text":"date = Dater.ii(...)","title":"Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/ii.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.ii(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"DataManagement/Dater/ii.html#input-arguments","text":"integer [ numeric ] Integer number, any non-integers will be floored.","title":"Input Arguments"},{"location":"DataManagement/Dater/ii.html#output-arguments","text":"date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode.","title":"Output Arguments"},{"location":"DataManagement/Dater/ii.html#description","text":"This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed.","title":"Description"},{"location":"DataManagement/Dater/ii.html#example","text":"Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"Example"},{"location":"DataManagement/Dater/mm.html","text":"mm | Dater.mm | dater.mm Create monthly dates Shortcut Syntax to Create Dater Objects date = mm(year, month) date = mm(year, \"end\") date = mm(year) Syntax to Create Dater Objects date = mm(...) Syntax to Create Numeric Date Codes dateCode = dater.mm(...) Input Arguments year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 . Output Arguments date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode. Description Example Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"mm  |  Dater.mm  |  dater.mm"},{"location":"DataManagement/Dater/mm.html#mm-datermm-datermm","text":"Create monthly dates","title":"mm  |  Dater.mm  |  dater.mm"},{"location":"DataManagement/Dater/mm.html#shortcut-syntax-to-create-dater-objects","text":"date = mm(year, month) date = mm(year, \"end\") date = mm(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/mm.html#syntax-to-create-dater-objects","text":"date = mm(...)","title":"Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/mm.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.mm(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"DataManagement/Dater/mm.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 .","title":"Input Arguments"},{"location":"DataManagement/Dater/mm.html#output-arguments","text":"date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"DataManagement/Dater/mm.html#description","text":"","title":"Description"},{"location":"DataManagement/Dater/mm.html#example","text":"Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"Example"},{"location":"DataManagement/Dater/qq.html","text":"qq | Dater.qq | dater.qq Create quarterly dates Syntax shortcuts to create dater objects date = qq(year, quarter) date = qq(year, \"end\") date = qq(year) Syntax to create dater objects date = Dater.qq(...) Syntax to create numeric date codes dateCode = dater.qq(...) Input arguments year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 . Output arguments date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode. Description Examples Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"qq  |  Dater.qq  |  dater.qq"},{"location":"DataManagement/Dater/qq.html#qq-daterqq-daterqq","text":"Create quarterly dates","title":"qq  |  Dater.qq  |  dater.qq"},{"location":"DataManagement/Dater/qq.html#syntax-shortcuts-to-create-dater-objects","text":"date = qq(year, quarter) date = qq(year, \"end\") date = qq(year)","title":"Syntax shortcuts to create dater objects"},{"location":"DataManagement/Dater/qq.html#syntax-to-create-dater-objects","text":"date = Dater.qq(...)","title":"Syntax to create dater objects"},{"location":"DataManagement/Dater/qq.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.qq(...)","title":"Syntax to create numeric date codes"},{"location":"DataManagement/Dater/qq.html#input-arguments","text":"year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 .","title":"Input arguments"},{"location":"DataManagement/Dater/qq.html#output-arguments","text":"date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode.","title":"Output arguments"},{"location":"DataManagement/Dater/qq.html#description","text":"","title":"Description"},{"location":"DataManagement/Dater/qq.html#examples","text":"Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"Examples"},{"location":"DataManagement/Dater/toString.html","text":"toString Print IrisT dates as formatted strings Syntax outputString = toString(inputDate, format) Input Arguments inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string. Output Arguments outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format . Options Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Description The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed Example of Plain Vanilla Date Formatting Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\" Example of Open / Close Options Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"toString"},{"location":"DataManagement/Dater/toString.html#tostring","text":"Print IrisT dates as formatted strings","title":"toString"},{"location":"DataManagement/Dater/toString.html#syntax","text":"outputString = toString(inputDate, format)","title":"Syntax"},{"location":"DataManagement/Dater/toString.html#input-arguments","text":"inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string.","title":"Input Arguments"},{"location":"DataManagement/Dater/toString.html#output-arguments","text":"outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format .","title":"Output Arguments"},{"location":"DataManagement/Dater/toString.html#options","text":"Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters.","title":"Options"},{"location":"DataManagement/Dater/toString.html#description","text":"The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed","title":"Description"},{"location":"DataManagement/Dater/toString.html#example-of-plain-vanilla-date-formatting","text":"Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\"","title":"Example of Plain Vanilla Date Formatting"},{"location":"DataManagement/Dater/toString.html#example-of-openclose-options","text":"Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"Example of Open/Close Options"},{"location":"DataManagement/Dater/ww.html","text":"ww | Dater.ww | dater.ww Create weekly dates Shortcut Syntax to Create Dater Objects date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day) Syntax to Create Dater Objects date = Dater.ww(...) Syntax to Create Plain Numeric Date Codes dateCode = dater.ww(...) Input Arguments year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601. Output Arguments date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode. Description Example Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"ww  |  Dater.ww  |  dater.ww"},{"location":"DataManagement/Dater/ww.html#ww-daterww-daterww","text":"Create weekly dates","title":"ww  |  Dater.ww  |  dater.ww"},{"location":"DataManagement/Dater/ww.html#shortcut-syntax-to-create-dater-objects","text":"date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/ww.html#syntax-to-create-dater-objects","text":"date = Dater.ww(...)","title":"Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/ww.html#syntax-to-create-plain-numeric-date-codes","text":"dateCode = dater.ww(...)","title":"Syntax to Create Plain Numeric Date Codes"},{"location":"DataManagement/Dater/ww.html#input-arguments","text":"year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601.","title":"Input Arguments"},{"location":"DataManagement/Dater/ww.html#output-arguments","text":"date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"DataManagement/Dater/ww.html#description","text":"","title":"Description"},{"location":"DataManagement/Dater/ww.html#example","text":"Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"Example"},{"location":"DataManagement/Dater/yy.html","text":"yy | Dater.yy | dater.yy Create yearly dates Shortcut Syntax to Create Dater Objects date = yy(year) Syntax to Create Dater Objects date = Dater.yy(...) Syntax to Create Numeric Date Codes dateCode = dater.yy(...) Input Arguments year [ numeric ] Calendar year. Output Arguments date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode. Description Example Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"yy  |  Dater.yy  |  dater.yy"},{"location":"DataManagement/Dater/yy.html#yy-dateryy-dateryy","text":"Create yearly dates","title":"yy  |  Dater.yy  |  dater.yy"},{"location":"DataManagement/Dater/yy.html#shortcut-syntax-to-create-dater-objects","text":"date = yy(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/yy.html#syntax-to-create-dater-objects","text":"date = Dater.yy(...)","title":"Syntax to Create Dater Objects"},{"location":"DataManagement/Dater/yy.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.yy(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"DataManagement/Dater/yy.html#input-arguments","text":"year [ numeric ] Calendar year.","title":"Input Arguments"},{"location":"DataManagement/Dater/yy.html#output-arguments","text":"date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"DataManagement/Dater/yy.html#description","text":"","title":"Description"},{"location":"DataManagement/Dater/yy.html#example","text":"Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"Example"},{"location":"DataManagement/Series/index.html","text":"Overview of Series objects Series objects are two- or higher-dimensional arrays whose rows are referenced by dates. The arrays can be one of the following types: numeric arrays string arrays cell arrays Categorical list of functions Constructing time series objects Function Description Series Create new time series object Series.linearTrend Create time series with linear trend Series.empty Create empty time series or empty existing time series Series.seasonDummy Create time series with seasonal dummies Series.randomlyGrowing Create randomly growing time series Generating new time series Series.grow | Cumulate level time series from differences or rates of growth Converting and modifying time series Function Description convert Convert time series to another frequency rebase Rebase times series data to specified period fillMissing Fill missing time series observations Filtering and aggregating time series Function Description arf Create autoregressive time series from input data hpf Hodrick-Prescott filter with conditioning information moving Apply function to moving window of time series observations chainlink Calculate chain linked aggregate level series from level components and weights Regression and statistics Function Description rmse Calculate RMSE for given observations and predictions regress Ordinary or weighted least-square regression","title":"Overview of Series objects"},{"location":"DataManagement/Series/index.html#overview-of-series-objects","text":"Series objects are two- or higher-dimensional arrays whose rows are referenced by dates. The arrays can be one of the following types: numeric arrays string arrays cell arrays","title":"Overview of Series objects"},{"location":"DataManagement/Series/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"DataManagement/Series/index.html#constructing-time-series-objects","text":"Function Description Series Create new time series object Series.linearTrend Create time series with linear trend Series.empty Create empty time series or empty existing time series Series.seasonDummy Create time series with seasonal dummies Series.randomlyGrowing Create randomly growing time series","title":"Constructing time series objects"},{"location":"DataManagement/Series/index.html#generating-new-time-series","text":"Series.grow | Cumulate level time series from differences or rates of growth","title":"Generating new time series"},{"location":"DataManagement/Series/index.html#converting-and-modifying-time-series","text":"Function Description convert Convert time series to another frequency rebase Rebase times series data to specified period fillMissing Fill missing time series observations","title":"Converting and modifying time series"},{"location":"DataManagement/Series/index.html#filtering-and-aggregating-time-series","text":"Function Description arf Create autoregressive time series from input data hpf Hodrick-Prescott filter with conditioning information moving Apply function to moving window of time series observations chainlink Calculate chain linked aggregate level series from level components and weights","title":"Filtering and aggregating time series"},{"location":"DataManagement/Series/index.html#regression-and-statistics","text":"Function Description rmse Calculate RMSE for given observations and predictions regress Ordinary or weighted least-square regression","title":"Regression and statistics"},{"location":"DataManagement/Series/Series.html","text":"Series Create new time series object Syntax X = Series() X = Series(dates, values) X = Series(dates, values, comments) X = Series(dates, values, comments, userData) Input Arguments dates [ numeric | char ] Dates for which observations will be supplied; dates do not need to be sorted in ascending order or create a continuous date range. If dates is scalar and values have multiple rows, then the date is interpreted as the start date for the entire time series. values [ numeric | function_handle ] Numerical values (observations) arranged columnwise, or a function that will be used to create an N-by-1 array of values, where N is the number of dates . comments [ string ] Comment(s) attached to each column of the time series; if omitted, comments will be empty strings. userData [ * ] Any kind of user data attached to the object; if omitted, user data will be empty; if userData is a struct, the Series methods accessUserData and assignUserData can be used access or assign/change them. Output Arguments x [ Series ] New times series. Description Example x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), @ rand , \"Random numbers\" );","title":"Series"},{"location":"DataManagement/Series/Series.html#series","text":"Create new time series object","title":"Series"},{"location":"DataManagement/Series/Series.html#syntax","text":"X = Series() X = Series(dates, values) X = Series(dates, values, comments) X = Series(dates, values, comments, userData)","title":"Syntax"},{"location":"DataManagement/Series/Series.html#input-arguments","text":"dates [ numeric | char ] Dates for which observations will be supplied; dates do not need to be sorted in ascending order or create a continuous date range. If dates is scalar and values have multiple rows, then the date is interpreted as the start date for the entire time series. values [ numeric | function_handle ] Numerical values (observations) arranged columnwise, or a function that will be used to create an N-by-1 array of values, where N is the number of dates . comments [ string ] Comment(s) attached to each column of the time series; if omitted, comments will be empty strings. userData [ * ] Any kind of user data attached to the object; if omitted, user data will be empty; if userData is a struct, the Series methods accessUserData and assignUserData can be used access or assign/change them.","title":"Input Arguments"},{"location":"DataManagement/Series/Series.html#output-arguments","text":"x [ Series ] New times series.","title":"Output Arguments"},{"location":"DataManagement/Series/Series.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/Series.html#example","text":"x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), @ rand , \"Random numbers\" );","title":"Example"},{"location":"DataManagement/Series/arf.html","text":"arf Create autoregressive time series from input data Syntax x = arf(x, A, Z, range, ...) Input arguments x [ Series ] - Input data from which initial condition will be taken. A [ numeric ] - Vector of coefficients of the autoregressive polynomial. Z [ numeric | Series ] - Exogenous input series or constant in the autoregressive process. range [ Dater | @all ] - Date range on which the new time series observations will be computed; range does not include pre-sample initial condition. @all means the entire possible range will be used (taking into account the length of pre-sample initial condition needed). Output Arguments x [ Series ] Output data with new observations created by running an autoregressive process described by A and Z . Description The autoregressive process has one of the following forms: A1*x + A2*x(-1) + ... + An*x(-n) = z, or A1*x + A2*x(+1) + ... + An*x(+n) = z, depending on whether the range is increasing (running forward in time), or decreasing (running backward in time). The coefficients A1 , ... An are gathered in the input vector A , A = [A1, A2, ..., An]. Examples The following two lines create an autoregressive process constructed from normally distributed residuals \\[ x_t = \\rho x_{t-1} + \\epsilon_t \\] rho = 0.8 ; x = Series ( 1 : 20 , @ randn ); x = arf ( x , [ 1 , - rho ], x , 2 : 20 );","title":"arf"},{"location":"DataManagement/Series/arf.html#arf","text":"Create autoregressive time series from input data","title":"arf"},{"location":"DataManagement/Series/arf.html#syntax","text":"x = arf(x, A, Z, range, ...)","title":"Syntax"},{"location":"DataManagement/Series/arf.html#input-arguments","text":"x [ Series ] - Input data from which initial condition will be taken. A [ numeric ] - Vector of coefficients of the autoregressive polynomial. Z [ numeric | Series ] - Exogenous input series or constant in the autoregressive process. range [ Dater | @all ] - Date range on which the new time series observations will be computed; range does not include pre-sample initial condition. @all means the entire possible range will be used (taking into account the length of pre-sample initial condition needed).","title":"Input arguments"},{"location":"DataManagement/Series/arf.html#output-arguments","text":"x [ Series ] Output data with new observations created by running an autoregressive process described by A and Z .","title":"Output Arguments"},{"location":"DataManagement/Series/arf.html#description","text":"The autoregressive process has one of the following forms: A1*x + A2*x(-1) + ... + An*x(-n) = z, or A1*x + A2*x(+1) + ... + An*x(+n) = z, depending on whether the range is increasing (running forward in time), or decreasing (running backward in time). The coefficients A1 , ... An are gathered in the input vector A , A = [A1, A2, ..., An].","title":"Description"},{"location":"DataManagement/Series/arf.html#examples","text":"The following two lines create an autoregressive process constructed from normally distributed residuals \\[ x_t = \\rho x_{t-1} + \\epsilon_t \\] rho = 0.8 ; x = Series ( 1 : 20 , @ randn ); x = arf ( x , [ 1 , - rho ], x , 2 : 20 );","title":"Examples"},{"location":"DataManagement/Series/chainlink.html","text":"chainlink Calculate chain linked aggregate level series from level components and weights Syntax [aggregateLevel, aggregateRate, info] = chainlink(levels, weights, ...) Input arguments levels [ Series ] Time series with level data of components that will be chain link aggregated. weights [ Series ] Time series with weights of the input components levels . Output arguments aggregateLevel [ Series ] Aggregate level series calculated by chain linking the levels components with weights . aggregateRate [ Series ] Aggregate rates of change relative with the end period of previous year set as the base period. info [ struct ] Output information struct with the following fields: .Rates - rates of change in the individual components with the end period of previous year set as the base period; .Weights - component weights; may potentially differ from the input weights because of normalization; see the option NormalizeWeights= . Options Range=Inf [ Inf | Dater ] Date range on which the aggregation will be calculated; Inf means the entire range available in levels and weights . RebaseDates=[] [ empty | Dates ] Dates of observations whose average will be used to rebase the resulting level aggregate; empty dates means to rebasing is performed. NormalizeWeights=true [ true | false ] Normalize the input weights so that they sum up to 1 in each period. Description Examples","title":"chainlink"},{"location":"DataManagement/Series/chainlink.html#chainlink","text":"Calculate chain linked aggregate level series from level components and weights","title":"chainlink"},{"location":"DataManagement/Series/chainlink.html#syntax","text":"[aggregateLevel, aggregateRate, info] = chainlink(levels, weights, ...)","title":"Syntax"},{"location":"DataManagement/Series/chainlink.html#input-arguments","text":"levels [ Series ] Time series with level data of components that will be chain link aggregated. weights [ Series ] Time series with weights of the input components levels .","title":"Input arguments"},{"location":"DataManagement/Series/chainlink.html#output-arguments","text":"aggregateLevel [ Series ] Aggregate level series calculated by chain linking the levels components with weights . aggregateRate [ Series ] Aggregate rates of change relative with the end period of previous year set as the base period. info [ struct ] Output information struct with the following fields: .Rates - rates of change in the individual components with the end period of previous year set as the base period; .Weights - component weights; may potentially differ from the input weights because of normalization; see the option NormalizeWeights= .","title":"Output arguments"},{"location":"DataManagement/Series/chainlink.html#options","text":"Range=Inf [ Inf | Dater ] Date range on which the aggregation will be calculated; Inf means the entire range available in levels and weights . RebaseDates=[] [ empty | Dates ] Dates of observations whose average will be used to rebase the resulting level aggregate; empty dates means to rebasing is performed. NormalizeWeights=true [ true | false ] Normalize the input weights so that they sum up to 1 in each period.","title":"Options"},{"location":"DataManagement/Series/chainlink.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/chainlink.html#examples","text":"","title":"Examples"},{"location":"DataManagement/Series/convert.html","text":"convert Convert time series to another frequency Syntax outputSeries = convert(inputSeries, newFreq, ...) outputSeries = convert(inputSeries, newFreq, range, ...) Input Arguments inputSeries [ Series ] Input time series that will be converted to a new frequency, freq , aggregating or intrapolating the data. newFreq [ Frequency ] New frequency to which the input data will be converted; see Description for frequency formats allowed. range=Inf [ Dater ] Date range on which the input data will be converted; Inf means the conversion will be done on the entire time series range. Output Arguments outputSeries [ Series ] Output tseries created by converting the inputSeries to the new frequency (aggregating or interpolating). Options RemoveNaN=false [ true | false ] Exclude NaN values from agreggation. Missing=@default [ @default | numeric | \"previous\" | \"next\" ] Fill missing observations with this value before conversion: @default means no preprocessing; \"previous\" or \"next\" means fill in the nearest preceding or nearest following value available in the time series. Options for High- to Low-Frequency Aggregation Method=\"mean\" [ \"mean\" | \"sum\" | \"first\" | \"last\" | function_handle ] Aggregation method; \"first\" , \"last\" and \"random\" select the first, last or a random observation from the high-frequency periods contained in the correspoding low-frequency period. RemoveWeekends=false [ true | false ] For daily frequency time series only: remove all weekend observations before aggregation. Select=Inf [ numeric ] Select only these high-frequency observations within each low-frequency period; Inf means all observations will be used. Options for Low- to High-Frequency Interpolation Method=\"pchip\" [ string | \"quadSum\" | \"quadMean\" | \"flat\" | \"first\" | \"last\" ] Interpolation method; any option valid for the built-in function interp1 can be used, or 'QuadSum' or 'QuadMean' ; these two options use quadratic interpolation preserving the sum or the average of observations within each period. Position=\"center\" [ \"center\" | \"start\" | \"end\" ] Position of dates within each period in the low-frequency date grid. RemoveWeekends=false [ true | false ] For interpolation to daily frequency only: replace all weekend observations in the final time series (after interpolation) with NaN (or the default missing value as defined in the time series object property .MissingValue ). Description The function handle that you pass in through the Method option when you aggregate the data (convert higher frequency to lower frequency) should behave like the built-in functions mean , sum etc. In other words, it is expected to accept two input arguments: the data to be aggregated; the dimension along which the aggregation is calculated. The function will be called with the second input argument set to 1, as the data are processed en block columnwise. If this call fails, convert() will attempt to call the function with just one input argument, the data, but this is not a safe option under some circumstances since dimension mismatch may occur. Example -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"convert"},{"location":"DataManagement/Series/convert.html#convert","text":"Convert time series to another frequency","title":"convert"},{"location":"DataManagement/Series/convert.html#syntax","text":"outputSeries = convert(inputSeries, newFreq, ...) outputSeries = convert(inputSeries, newFreq, range, ...)","title":"Syntax"},{"location":"DataManagement/Series/convert.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be converted to a new frequency, freq , aggregating or intrapolating the data. newFreq [ Frequency ] New frequency to which the input data will be converted; see Description for frequency formats allowed. range=Inf [ Dater ] Date range on which the input data will be converted; Inf means the conversion will be done on the entire time series range.","title":"Input Arguments"},{"location":"DataManagement/Series/convert.html#output-arguments","text":"outputSeries [ Series ] Output tseries created by converting the inputSeries to the new frequency (aggregating or interpolating).","title":"Output Arguments"},{"location":"DataManagement/Series/convert.html#options","text":"RemoveNaN=false [ true | false ] Exclude NaN values from agreggation. Missing=@default [ @default | numeric | \"previous\" | \"next\" ] Fill missing observations with this value before conversion: @default means no preprocessing; \"previous\" or \"next\" means fill in the nearest preceding or nearest following value available in the time series.","title":"Options"},{"location":"DataManagement/Series/convert.html#options-for-high-to-low-frequency-aggregation","text":"Method=\"mean\" [ \"mean\" | \"sum\" | \"first\" | \"last\" | function_handle ] Aggregation method; \"first\" , \"last\" and \"random\" select the first, last or a random observation from the high-frequency periods contained in the correspoding low-frequency period. RemoveWeekends=false [ true | false ] For daily frequency time series only: remove all weekend observations before aggregation. Select=Inf [ numeric ] Select only these high-frequency observations within each low-frequency period; Inf means all observations will be used.","title":"Options for High- to Low-Frequency Aggregation"},{"location":"DataManagement/Series/convert.html#options-for-low-to-high-frequency-interpolation","text":"Method=\"pchip\" [ string | \"quadSum\" | \"quadMean\" | \"flat\" | \"first\" | \"last\" ] Interpolation method; any option valid for the built-in function interp1 can be used, or 'QuadSum' or 'QuadMean' ; these two options use quadratic interpolation preserving the sum or the average of observations within each period. Position=\"center\" [ \"center\" | \"start\" | \"end\" ] Position of dates within each period in the low-frequency date grid. RemoveWeekends=false [ true | false ] For interpolation to daily frequency only: replace all weekend observations in the final time series (after interpolation) with NaN (or the default missing value as defined in the time series object property .MissingValue ).","title":"Options for Low- to High-Frequency Interpolation"},{"location":"DataManagement/Series/convert.html#description","text":"The function handle that you pass in through the Method option when you aggregate the data (convert higher frequency to lower frequency) should behave like the built-in functions mean , sum etc. In other words, it is expected to accept two input arguments: the data to be aggregated; the dimension along which the aggregation is calculated. The function will be called with the second input argument set to 1, as the data are processed en block columnwise. If this call fails, convert() will attempt to call the function with just one input argument, the data, but this is not a safe option under some circumstances since dimension mismatch may occur.","title":"Description"},{"location":"DataManagement/Series/convert.html#example","text":"-[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"DataManagement/Series/empty.html","text":"Series.empty Create empty time series or empty existing time series Syntax x = Series.empty([0, size, ...]) x = Series.empty(0, size, ...) x = Series.empty(x) Input Arguments size [ numeric ] Size of new time series in 2nd and higher dimensions; first dimenstion (time) must be always 0. this [ Series ] Input time series that will be emptied. Output Arguments this [ Series ] Empty time series with the 2nd and higher dimensions the same size as the input time series, and comments preserved. Description Examples Plain Vanilla Example Create a 12-by-3-by-2 monthly time series, and then use Series.empty to create a new, empty series with now rows but the same size in 2nd and higher dimensions x = Series ( mm ( 2020 , 01 ), rand ( 12 , 3 , 2 )) x0 = Series . empty ( x )","title":"Series.empty"},{"location":"DataManagement/Series/empty.html#seriesempty","text":"Create empty time series or empty existing time series","title":"Series.empty"},{"location":"DataManagement/Series/empty.html#syntax","text":"x = Series.empty([0, size, ...]) x = Series.empty(0, size, ...) x = Series.empty(x)","title":"Syntax"},{"location":"DataManagement/Series/empty.html#input-arguments","text":"size [ numeric ] Size of new time series in 2nd and higher dimensions; first dimenstion (time) must be always 0. this [ Series ] Input time series that will be emptied.","title":"Input Arguments"},{"location":"DataManagement/Series/empty.html#output-arguments","text":"this [ Series ] Empty time series with the 2nd and higher dimensions the same size as the input time series, and comments preserved.","title":"Output Arguments"},{"location":"DataManagement/Series/empty.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/empty.html#examples","text":"","title":"Examples"},{"location":"DataManagement/Series/empty.html#plain-vanilla-example","text":"Create a 12-by-3-by-2 monthly time series, and then use Series.empty to create a new, empty series with now rows but the same size in 2nd and higher dimensions x = Series ( mm ( 2020 , 01 ), rand ( 12 , 3 , 2 )) x0 = Series . empty ( x )","title":"Plain Vanilla Example"},{"location":"DataManagement/Series/fillMissing.html","text":"fillMissings Fill missing time series observations Syntax outputSeries = fillMissing(inputSeries, range, method) outputSeries = fillMissing(inputSeries, range, method, specs) outputSeries = fillMissing(inputSeries, range, anotherSeries) Input Arguments inputSeries [ Series ] Input time series whose missing entries lying within the range will be filled with values determined by the method or from anotherSeries . range [ Dater | Inf ] Date range within which missing entries will be looked up in the inputSeries and filled with values determined by the method or from anotherSeries . method [ string | Series ] String specifying the method to obtain missing observations, or a time series with replacement values. The method can be any of the methods valid in the built-in fillmissing() function (see help fillmissing ) or one of the regression methods provided by IrisT: \"regressConstant\" , \"regressTrend\" or \"regressLogTrend\" for a regression on a constant, a regression on a constant and a linear time trend, and a log-regression on a constant and a time trend, respectively. specs [ * ] Some of the methods in the built-in fillmissing() function require addition specification (see help fillmissing ). anotherSeries [ Series ] Another time series whose values will be used to fill missing entries in the inputSeries . Output Arguments outputSeries [ Series ] Output time series whose missing observations found within the range have been filled with values given by the method or from anotherSeries . Description Example -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2019 [IrisToolbox] Solutions Team","title":"fillMissings"},{"location":"DataManagement/Series/fillMissing.html#fillmissings","text":"Fill missing time series observations","title":"fillMissings"},{"location":"DataManagement/Series/fillMissing.html#syntax","text":"outputSeries = fillMissing(inputSeries, range, method) outputSeries = fillMissing(inputSeries, range, method, specs) outputSeries = fillMissing(inputSeries, range, anotherSeries)","title":"Syntax"},{"location":"DataManagement/Series/fillMissing.html#input-arguments","text":"inputSeries [ Series ] Input time series whose missing entries lying within the range will be filled with values determined by the method or from anotherSeries . range [ Dater | Inf ] Date range within which missing entries will be looked up in the inputSeries and filled with values determined by the method or from anotherSeries . method [ string | Series ] String specifying the method to obtain missing observations, or a time series with replacement values. The method can be any of the methods valid in the built-in fillmissing() function (see help fillmissing ) or one of the regression methods provided by IrisT: \"regressConstant\" , \"regressTrend\" or \"regressLogTrend\" for a regression on a constant, a regression on a constant and a linear time trend, and a log-regression on a constant and a time trend, respectively. specs [ * ] Some of the methods in the built-in fillmissing() function require addition specification (see help fillmissing ). anotherSeries [ Series ] Another time series whose values will be used to fill missing entries in the inputSeries .","title":"Input Arguments"},{"location":"DataManagement/Series/fillMissing.html#output-arguments","text":"outputSeries [ Series ] Output time series whose missing observations found within the range have been filled with values given by the method or from anotherSeries .","title":"Output Arguments"},{"location":"DataManagement/Series/fillMissing.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/fillMissing.html#example","text":"-[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2019 [IrisToolbox] Solutions Team","title":"Example"},{"location":"DataManagement/Series/grow.html","text":"grow Cumulate level time series from differences or rates of growth Syntax outputSeries = grow(inputSeries, operator, changeSeries, dates) outputSeries = grow(inputSeries, operator, changeSeries, dates, shift) Input Arguments inputSeries [ Series ] Input time series including at least the initial condition for the level. operator [ \"diff\" | \"difflog\" | \"roc\" | \"pcr\" ] Function expressing the relationship between the resulting outputSeries and the input changeSeries . changeSeries [ Series | numeric ] Time series or numeric scalar specifying the change in the input time series (difference, difference of logs, gross rate of change, or percent change, see the input argument operator ). dates [ Dater ] Date range or a vector of dates on which the level series will be cumulated. shift=-1 [ numeric ] Negative number specifying the lag of the base period to which the change operator function applies. Output Arguments outputSeries [ Series ] Output time series constructed from the input time series, inputSeries , extended by its differences or growth rates, growth . Options Direction=\"forward\" [ \"forward\" | \"backward\" ] Direction of calculations in time; Direction=\"backward\" means that the calculations start from the last date in dates going backwards to the first one, and an inverse operator is applied. Description The function grow() calculates new values at dates (which may not constitute a continuous range, and be discrete time periods instead) using one of the the following formulas (depending on the operator ): $ x_t = x_{t-k} + g_t $ $ x_t = x_{t-k} \\cdot \\exp g_t $ $ x_t = x_{t-k} \\cdot g_t $ $ x_t = x_{t-k} \\cdot \\left( 1 + \\frac{g_t}{100} \\right) $ where $ k $ is a time lag specified by the input argument shift , and the values $ g_t $ are given by the second input series growth . Alternatively, the operator applied to $ x_{t-k} $ and $ g_t $ can be any user-specified function. Any values contained in the input time series inputSeries outside the dates are preserved in the output time series unchanged. Example Extend a quarterly time series x using the gross rates of growth calculated from another time series, y : x = grow(x, \"roc\", roc(y), qq(2020,1):qq(2030,4)); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"grow"},{"location":"DataManagement/Series/grow.html#grow","text":"Cumulate level time series from differences or rates of growth","title":"grow"},{"location":"DataManagement/Series/grow.html#syntax","text":"outputSeries = grow(inputSeries, operator, changeSeries, dates) outputSeries = grow(inputSeries, operator, changeSeries, dates, shift)","title":"Syntax"},{"location":"DataManagement/Series/grow.html#input-arguments","text":"inputSeries [ Series ] Input time series including at least the initial condition for the level. operator [ \"diff\" | \"difflog\" | \"roc\" | \"pcr\" ] Function expressing the relationship between the resulting outputSeries and the input changeSeries . changeSeries [ Series | numeric ] Time series or numeric scalar specifying the change in the input time series (difference, difference of logs, gross rate of change, or percent change, see the input argument operator ). dates [ Dater ] Date range or a vector of dates on which the level series will be cumulated. shift=-1 [ numeric ] Negative number specifying the lag of the base period to which the change operator function applies.","title":"Input Arguments"},{"location":"DataManagement/Series/grow.html#output-arguments","text":"outputSeries [ Series ] Output time series constructed from the input time series, inputSeries , extended by its differences or growth rates, growth .","title":"Output Arguments"},{"location":"DataManagement/Series/grow.html#options","text":"Direction=\"forward\" [ \"forward\" | \"backward\" ] Direction of calculations in time; Direction=\"backward\" means that the calculations start from the last date in dates going backwards to the first one, and an inverse operator is applied.","title":"Options"},{"location":"DataManagement/Series/grow.html#description","text":"The function grow() calculates new values at dates (which may not constitute a continuous range, and be discrete time periods instead) using one of the the following formulas (depending on the operator ): $ x_t = x_{t-k} + g_t $ $ x_t = x_{t-k} \\cdot \\exp g_t $ $ x_t = x_{t-k} \\cdot g_t $ $ x_t = x_{t-k} \\cdot \\left( 1 + \\frac{g_t}{100} \\right) $ where $ k $ is a time lag specified by the input argument shift , and the values $ g_t $ are given by the second input series growth . Alternatively, the operator applied to $ x_{t-k} $ and $ g_t $ can be any user-specified function. Any values contained in the input time series inputSeries outside the dates are preserved in the output time series unchanged.","title":"Description"},{"location":"DataManagement/Series/grow.html#example","text":"Extend a quarterly time series x using the gross rates of growth calculated from another time series, y : x = grow(x, \"roc\", roc(y), qq(2020,1):qq(2030,4)); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"DataManagement/Series/hpf.html","text":"hpf Hodrick-Prescott filter with conditioning information Syntax [T, C, cutoff, lambda] = hpf(X, ...) Syntax with output arguments swapped [C, T, cutoff, lambda] = hpf2(X, ...) Input arguments x [ Series ] Input time series that will be filtered. Output arguments t [ Series ] Low-frequency (trend) component. c [ Series ] High-frequency (cyclical or gap) component. cutoff [ numeric ] Cut-off periodicity; periodicities above the cut-off are attributed to trends, periodicities below the cut-off are attributed to gaps. lambda [ numeric ] Smoothing parameter actually used; this output argument is useful when lambda=@auto or when the option cutoff= is used instead of lambda= . Options cutoff=[ ] [ numeric ] Cut-off periodicity in periods (depending on the time series frequency); this option can be specified instead of lambda= ; the smoothing parameter will be then determined based on the cut-off periodicity. cutoffYear=[ ] [ numeric ] Cut-off periodicity in years; this option can be specified instead of lambda= ; the smoothing parameter will be then determined based on the cut-off periodicity. gamma=1 [ numeric | Series ] Weight or weights on the deviations of the trend from observations; it only makes sense to use this option to make the signal-to-noise ratio time-varying; see the optimization problem below. infoSet=2 [ 1 | 2 ] Information set assumption used in the filter: 1 runs a one-sided filter, 2 runs a two-sided filter. lambda=@auto [ numeric | @auto ] Smoothing parameter; needs to be specified for Series objects with indeterminate frequency; see Description for default values. level= [ Series ] Time series with hard tunes and soft tunes on the level of the trend. change= [ Series ] Time series with hard tunes and soft tunes on the change in the trend. log= [ true | false ] Logarithmize the data before filtering, de-logarithmize afterwards. Description The underlying optimization problem The function hpf solves a constrained optimization problem described by the following Lagrangian \\[ \\min_{\\bar y_t, \\omega_t, \\sigma_t} \\underbrace{ \\sum \\lambda \\left( \\Delta \\bar y_t - \\Delta \\bar y_{t-1} \\right)^2 + \\sum \\gamma_t \\left( \\bar y_t - y_t \\right)^2}_\\text{Plain HP with time-varying signal-to-noise ratio} + \\cdots \\] \\[ \\cdots + \\underbrace{\\sum u_t \\left( \\bar y_t - a_t \\right)^2}_\\text{Soft level tunes} + \\underbrace{\\sum v_t \\left( \\Delta \\bar y_t - b_t \\right)^2}_\\text{Soft growth tunes} + \\underbrace{\\sum \\omega_t \\left( \\bar y_t - c_t \\right)}_\\text{Hard level tunes} + \\underbrace{\\sum \\sigma_t \\left( \\Delta \\bar y_t - d_t \\right)}_\\text{Hard growth tunes} \\] where \\( \\(\\Delta\\) \\) is the first-difference operator; \\( \\(\\lambda\\) \\) is a (scalar) smoothing parameter; \\( \\(y_t\\) \\) are user-supplied observations; \\( \\(\\bar y_t\\) \\) is the fitted trend; \\( \\(\\gamma_t\\) \\) are user-supplied weights to modify the basic signal-to-noise ratio over time (the default setting is \\( \\(\\gamma_t=1\\) \\) ), entered in the option gamma= ; \\( \\(a_t\\) \\) and \\( \\(u_t\\) \\) are soft tunes on the level of the trend and the weights associated with these soft level tunes, respectively, entered together as complex numbers in the option level= ; \\( \\(b_t\\) \\) and \\( \\(v_t\\) \\) are soft tunes on the change in the level of the trend and the weights associated with these soft growth tunes, respectively, entered together as complex numbers in the option change= ; \\( \\(c_t\\) \\) are hard tunes on the level of the trend, entered as real numbers in the option level= ; \\( \\(d_t\\) \\) are hard tunes on the change in the level of the trend, entered as real numbers in the option change= ; \\( \\(\\omega_t\\) \\) are Lagrange multipliers on the hard level tunes (note that these are computed as part of the optimization problem, not entered by the user); \\( \\(\\sigma_t\\) \\) are Lagrange multipliers on the hard growth tunes (note that these are computed as part of the optimization problem, not entered by the user). Each of the summations in the above Lagrangian goes over those periods in which the respective bracketed terms are defined (observations or tunes exist). You can combine any number of any tunes in one run of hpf , including out-of-sample tunes (see below). Imposing tunes on trend level and trend change The hard tunes and soft tunes on the level of the trend are entered as time series through the option level= . The hard tunes and soft tunes on the change in the trend are entered as time series through the option change= . In the time series entered through level= and/or change= , you can combine any number of hard and soft tune. In each particular period, you can obviously specify only a hard tune or only a soft tune. You can think of hard tunes as a special case of soft tunes with infinitely large weights. A hard tune is specified as a plain real number (i.e. a number with a zero complex part). A soft tune must be entered as a complex number whose real part specifies the tune itself, and the imaginary part specifies the inverse of the weight, i.e. \\( \\(1/v_t\\) \\) or \\( \\(1/u_t\\) \\) , on that tune in that period. Note that if the weight goes to infinity, the imaginary part becomes zero and the tune becomes a hard tune. Out-of-sample tunes Tunes can be imposed also at dates before the first observation of the input series, or after the last observation. In other words, the time series in level= and/or change= can have a more extended range (at either side) than the filtered input series. Default smoothing parameters If the smoothing parameter lambda= is not specified (i.e. lambda=@auto ), a default value is computed. The default value is based on common practice and can be calculated using the date frequency of the input time series as \\( \\(\\lambda = 100 f^2\\) \\) , where \\( \\(f\\) \\) is the frequency (yearly=1, half-yearly=2, quarterly=4, monthly=12). This gives the following default values: 100 for yearly time series (cut-off periodicity of 19.79 years); 400 for half-yearly time series (cut-off periodicity of 14.02 years); 1,600 for quarterly time series (cut-off periodicity of 9.92 years); 3,600 for bi-monthly time series (cut-off periodicity of 8.11 years); 14,400 for monthly time series (cut-off periodicity of 5.73 years). Note that there is no default value for data with indeterminate or daily frequency: for these types of time series, you must always use the option lambda= . Examples","title":"hpf"},{"location":"DataManagement/Series/hpf.html#hpf","text":"Hodrick-Prescott filter with conditioning information","title":"hpf"},{"location":"DataManagement/Series/hpf.html#syntax","text":"[T, C, cutoff, lambda] = hpf(X, ...)","title":"Syntax"},{"location":"DataManagement/Series/hpf.html#syntax-with-output-arguments-swapped","text":"[C, T, cutoff, lambda] = hpf2(X, ...)","title":"Syntax with output arguments swapped"},{"location":"DataManagement/Series/hpf.html#input-arguments","text":"x [ Series ] Input time series that will be filtered.","title":"Input arguments"},{"location":"DataManagement/Series/hpf.html#output-arguments","text":"t [ Series ] Low-frequency (trend) component. c [ Series ] High-frequency (cyclical or gap) component. cutoff [ numeric ] Cut-off periodicity; periodicities above the cut-off are attributed to trends, periodicities below the cut-off are attributed to gaps. lambda [ numeric ] Smoothing parameter actually used; this output argument is useful when lambda=@auto or when the option cutoff= is used instead of lambda= .","title":"Output arguments"},{"location":"DataManagement/Series/hpf.html#options","text":"cutoff=[ ] [ numeric ] Cut-off periodicity in periods (depending on the time series frequency); this option can be specified instead of lambda= ; the smoothing parameter will be then determined based on the cut-off periodicity. cutoffYear=[ ] [ numeric ] Cut-off periodicity in years; this option can be specified instead of lambda= ; the smoothing parameter will be then determined based on the cut-off periodicity. gamma=1 [ numeric | Series ] Weight or weights on the deviations of the trend from observations; it only makes sense to use this option to make the signal-to-noise ratio time-varying; see the optimization problem below. infoSet=2 [ 1 | 2 ] Information set assumption used in the filter: 1 runs a one-sided filter, 2 runs a two-sided filter. lambda=@auto [ numeric | @auto ] Smoothing parameter; needs to be specified for Series objects with indeterminate frequency; see Description for default values. level= [ Series ] Time series with hard tunes and soft tunes on the level of the trend. change= [ Series ] Time series with hard tunes and soft tunes on the change in the trend. log= [ true | false ] Logarithmize the data before filtering, de-logarithmize afterwards.","title":"Options"},{"location":"DataManagement/Series/hpf.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/hpf.html#the-underlying-optimization-problem","text":"The function hpf solves a constrained optimization problem described by the following Lagrangian \\[ \\min_{\\bar y_t, \\omega_t, \\sigma_t} \\underbrace{ \\sum \\lambda \\left( \\Delta \\bar y_t - \\Delta \\bar y_{t-1} \\right)^2 + \\sum \\gamma_t \\left( \\bar y_t - y_t \\right)^2}_\\text{Plain HP with time-varying signal-to-noise ratio} + \\cdots \\] \\[ \\cdots + \\underbrace{\\sum u_t \\left( \\bar y_t - a_t \\right)^2}_\\text{Soft level tunes} + \\underbrace{\\sum v_t \\left( \\Delta \\bar y_t - b_t \\right)^2}_\\text{Soft growth tunes} + \\underbrace{\\sum \\omega_t \\left( \\bar y_t - c_t \\right)}_\\text{Hard level tunes} + \\underbrace{\\sum \\sigma_t \\left( \\Delta \\bar y_t - d_t \\right)}_\\text{Hard growth tunes} \\] where \\( \\(\\Delta\\) \\) is the first-difference operator; \\( \\(\\lambda\\) \\) is a (scalar) smoothing parameter; \\( \\(y_t\\) \\) are user-supplied observations; \\( \\(\\bar y_t\\) \\) is the fitted trend; \\( \\(\\gamma_t\\) \\) are user-supplied weights to modify the basic signal-to-noise ratio over time (the default setting is \\( \\(\\gamma_t=1\\) \\) ), entered in the option gamma= ; \\( \\(a_t\\) \\) and \\( \\(u_t\\) \\) are soft tunes on the level of the trend and the weights associated with these soft level tunes, respectively, entered together as complex numbers in the option level= ; \\( \\(b_t\\) \\) and \\( \\(v_t\\) \\) are soft tunes on the change in the level of the trend and the weights associated with these soft growth tunes, respectively, entered together as complex numbers in the option change= ; \\( \\(c_t\\) \\) are hard tunes on the level of the trend, entered as real numbers in the option level= ; \\( \\(d_t\\) \\) are hard tunes on the change in the level of the trend, entered as real numbers in the option change= ; \\( \\(\\omega_t\\) \\) are Lagrange multipliers on the hard level tunes (note that these are computed as part of the optimization problem, not entered by the user); \\( \\(\\sigma_t\\) \\) are Lagrange multipliers on the hard growth tunes (note that these are computed as part of the optimization problem, not entered by the user). Each of the summations in the above Lagrangian goes over those periods in which the respective bracketed terms are defined (observations or tunes exist). You can combine any number of any tunes in one run of hpf , including out-of-sample tunes (see below).","title":"The underlying optimization problem"},{"location":"DataManagement/Series/hpf.html#imposing-tunes-on-trend-level-and-trend-change","text":"The hard tunes and soft tunes on the level of the trend are entered as time series through the option level= . The hard tunes and soft tunes on the change in the trend are entered as time series through the option change= . In the time series entered through level= and/or change= , you can combine any number of hard and soft tune. In each particular period, you can obviously specify only a hard tune or only a soft tune. You can think of hard tunes as a special case of soft tunes with infinitely large weights. A hard tune is specified as a plain real number (i.e. a number with a zero complex part). A soft tune must be entered as a complex number whose real part specifies the tune itself, and the imaginary part specifies the inverse of the weight, i.e. \\( \\(1/v_t\\) \\) or \\( \\(1/u_t\\) \\) , on that tune in that period. Note that if the weight goes to infinity, the imaginary part becomes zero and the tune becomes a hard tune.","title":"Imposing tunes on trend level and trend change"},{"location":"DataManagement/Series/hpf.html#out-of-sample-tunes","text":"Tunes can be imposed also at dates before the first observation of the input series, or after the last observation. In other words, the time series in level= and/or change= can have a more extended range (at either side) than the filtered input series.","title":"Out-of-sample tunes"},{"location":"DataManagement/Series/hpf.html#default-smoothing-parameters","text":"If the smoothing parameter lambda= is not specified (i.e. lambda=@auto ), a default value is computed. The default value is based on common practice and can be calculated using the date frequency of the input time series as \\( \\(\\lambda = 100 f^2\\) \\) , where \\( \\(f\\) \\) is the frequency (yearly=1, half-yearly=2, quarterly=4, monthly=12). This gives the following default values: 100 for yearly time series (cut-off periodicity of 19.79 years); 400 for half-yearly time series (cut-off periodicity of 14.02 years); 1,600 for quarterly time series (cut-off periodicity of 9.92 years); 3,600 for bi-monthly time series (cut-off periodicity of 8.11 years); 14,400 for monthly time series (cut-off periodicity of 5.73 years). Note that there is no default value for data with indeterminate or daily frequency: for these types of time series, you must always use the option lambda= .","title":"Default smoothing parameters"},{"location":"DataManagement/Series/hpf.html#examples","text":"","title":"Examples"},{"location":"DataManagement/Series/linearTrend.html","text":"Series.linearTrend Create time series with linear trend Syntax x = Series.linearTrend(range) x = Series.linearTrend(range, step) x = Series.linearTrend(range, step, startValue) Input Arguments range [ Dater ] Date range on which the trend time series will be created. step=1 [ numeric ] Difference between two consecutive dates in the trend; if omitted, the increment of the trend will be 1. startValue=0 [ numeric ] Starting value for the trend; if omitted, the trend will startValue at zero. Output Arguments x [ Series ] Output time series with a linear trend. Description Example","title":"Series.linearTrend"},{"location":"DataManagement/Series/linearTrend.html#serieslineartrend","text":"Create time series with linear trend","title":"Series.linearTrend"},{"location":"DataManagement/Series/linearTrend.html#syntax","text":"x = Series.linearTrend(range) x = Series.linearTrend(range, step) x = Series.linearTrend(range, step, startValue)","title":"Syntax"},{"location":"DataManagement/Series/linearTrend.html#input-arguments","text":"range [ Dater ] Date range on which the trend time series will be created. step=1 [ numeric ] Difference between two consecutive dates in the trend; if omitted, the increment of the trend will be 1. startValue=0 [ numeric ] Starting value for the trend; if omitted, the trend will startValue at zero.","title":"Input Arguments"},{"location":"DataManagement/Series/linearTrend.html#output-arguments","text":"x [ Series ] Output time series with a linear trend.","title":"Output Arguments"},{"location":"DataManagement/Series/linearTrend.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/linearTrend.html#example","text":"","title":"Example"},{"location":"DataManagement/Series/moving.html","text":"moving Apply function to moving window of time series observations Syntax outputSeries = moving(inputSeries, ...) Input arguments inputSeries [ Series ] Input times series. Output arguments outputSeries [ Series ] Output time series with their observations constructed by applying the the function Function= to a moving window Window= of observations from the inputSeries . Options Function=@mean [ function_handle ] Function to be applied to moving window of observations. By default, the function is supposed to accept two input arguments: an array of data, and the dimension along which the function will be calculated (this is the way the standard built-int @mean , @sum , etc. functions work). Period=false [ true | false ] Force the calculations to be put in a loop period by period and refrain from using dimension as a second input argument into the Function . This options works only when Window= is not a complex number (in which case the calculations are always period by period). Under the default Period=false , the function is evaluated on a whole array of observations, and supplied a second input argument 1 to indicate the dimension along which the function is to be calculated. This is consistent with standard functions such as mean , sum , etc. If Period=true , the function Function= is evaluated on a column vector of observations constituting the moving window for the current period only (determined by the Window= specification), one period at a time. Range=Inf [ Dater | Inf ] Date range to which the inputSeries will be trimmed before running the calculations. Window=@auto [ numeric | @auto ] The moving window of observations to which the function Function= will applied to construct the observations of the outputSeries ; see Description and Examples. Description The moving window of observations can be specificied in three different ways: Moving window Option Window= Comment Moving year of observations @auto The window depends on the date frequency of the inputSeries ; only available for yearly, half-yearly, quarterly and monthly frequencies Exact specification of lags and leads Vector of real integers Negative for lags, positive for leads, zero for current period Fixed number of non-missing observations Complex number (scalar) Negative imaginary part means the number of observations going back in time (starting from current), positive imaginary part means going forward in time Exact specification of moving window Use a vector of integers to specify an exact composition of the moving window. Negative numbers mean lags (observations before the current observation), positive numbers mean leads (observations after the current observation), zero means the current observation: \\[ \\begin{gathered} \\mathit{window} = \\left[ a, b, c, \\dots \\right] \\\\[5pt] y_t = f\\left( \\left[ x_{t+a}, x_{t+b}, x_{t+c}, \\dots \\right] \\right) \\end{gathered} \\] If some of the observations are missing, they are still included in the window (typically a NaN for plain numeric time series), and the result may be a missing observation again. This depends on the function used, consider, for instance, the difference between @mean and @nanmean . Moving window depending on the availability of observations Use a complex number (with a real part denoting the offset and the imaginary part specifying the length of the window) to specify a window consisting of a fixed number of available (non-missing) observations from the current observation backward, or from the current observation forward (positive imaginary part). The a nonzero offset means that the available (non-missing) observation will be looked up starting not from the current observation, but from an observation before (a negative offset) or after (a positive offset). If \\(\\mathit{window}=a + bi\\) , the algorithm is as follows: For each period \\(t\\) , define the output value \\(y_t\\) by applying the function \\(f\\) to a vector of a total of \\(b\\) observations from the input series \\(x_t\\) constructed as described in steps 2 and 3. If the window length (the imaginary part) \\(b\\) is a negative number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going backward, i.e. \\(x_{t+a}, x_{t+a-1}, x_{t+a-2}, \\dots\\) , all the way to the very first observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going backward. If the window length (the imaginary part) \\(b\\) is a positive number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going forward, i.e. \\(x_{t+a}, x_{t+a+1}, x_{t+a+2}, \\dots\\) , all the way to the very last observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going forward. Examples Centered moving average and sum Calculate a centered moving average with a total length of the window being 5 observations: x = moving ( x , \"window\" , [ - 2 , - 1 , 0 , 1 , 2 ]) or more concisely x = moving ( x , \"window\" , - 2 : 2 ) Calculate a moving sum on the same window of observations: x = moving(x, \"window\", -2:2, \"function\", @sum) Weighted centered moving average Supply a user defined function to calculate a weighted centered moving average (with the window specification as in the previous example); we have to use the option Period=true in this case because our function weightedAverage assumes that its input argument is only a vector of 5 numbers (the moving window of observations corresponding to the current period). func = @( x ) 0.10 * x ( 1 ) + 0.15 * x ( 2 ) + 0.50 * x ( 3 ) + 0.15 * x ( 4 ) + 0.10 * x ( 5 ); y = moving ( x , \"window\" , - 2 : 2 , \"function\" , func , \"period\" , true ) This is though equivalent to a more compact expression y = 0.10 * x { - 2 } + 0.15 * x { - 1 } + 0.50 * x + 0.15 * x { 1 } + 0.10 * x { 2 } Average of 5 last available observations Create a daily series of random observations, and remove weekends; the time series will therefore have NaN s in two out of every seven observations: x = Series ( dd ( 2000 , 1 , 1 ): dd ( 2020 , 12 , 31 ), @ randn ); x = removeWeekends ( x ); Create a time series by calculating the average of the five most recent observations available (i.e. excluding any missing observations): y0 = moving ( x , \"window\" , - 5 i ) Create a time series by calculating the average of the five most recent observations available as before, but now starting from the previous month (not including the current observation); in other words, select the latest available five observations among \\(x_{t-1}, x_{t-2}, \\dots\\) y1 = moving ( x , \"window\" , - 1 - 5 i )","title":"moving"},{"location":"DataManagement/Series/moving.html#moving","text":"Apply function to moving window of time series observations","title":"moving"},{"location":"DataManagement/Series/moving.html#syntax","text":"outputSeries = moving(inputSeries, ...)","title":"Syntax"},{"location":"DataManagement/Series/moving.html#input-arguments","text":"inputSeries [ Series ] Input times series.","title":"Input arguments"},{"location":"DataManagement/Series/moving.html#output-arguments","text":"outputSeries [ Series ] Output time series with their observations constructed by applying the the function Function= to a moving window Window= of observations from the inputSeries .","title":"Output arguments"},{"location":"DataManagement/Series/moving.html#options","text":"Function=@mean [ function_handle ] Function to be applied to moving window of observations. By default, the function is supposed to accept two input arguments: an array of data, and the dimension along which the function will be calculated (this is the way the standard built-int @mean , @sum , etc. functions work). Period=false [ true | false ] Force the calculations to be put in a loop period by period and refrain from using dimension as a second input argument into the Function . This options works only when Window= is not a complex number (in which case the calculations are always period by period). Under the default Period=false , the function is evaluated on a whole array of observations, and supplied a second input argument 1 to indicate the dimension along which the function is to be calculated. This is consistent with standard functions such as mean , sum , etc. If Period=true , the function Function= is evaluated on a column vector of observations constituting the moving window for the current period only (determined by the Window= specification), one period at a time. Range=Inf [ Dater | Inf ] Date range to which the inputSeries will be trimmed before running the calculations. Window=@auto [ numeric | @auto ] The moving window of observations to which the function Function= will applied to construct the observations of the outputSeries ; see Description and Examples.","title":"Options"},{"location":"DataManagement/Series/moving.html#description","text":"The moving window of observations can be specificied in three different ways: Moving window Option Window= Comment Moving year of observations @auto The window depends on the date frequency of the inputSeries ; only available for yearly, half-yearly, quarterly and monthly frequencies Exact specification of lags and leads Vector of real integers Negative for lags, positive for leads, zero for current period Fixed number of non-missing observations Complex number (scalar) Negative imaginary part means the number of observations going back in time (starting from current), positive imaginary part means going forward in time","title":"Description"},{"location":"DataManagement/Series/moving.html#exact-specification-of-moving-window","text":"Use a vector of integers to specify an exact composition of the moving window. Negative numbers mean lags (observations before the current observation), positive numbers mean leads (observations after the current observation), zero means the current observation: \\[ \\begin{gathered} \\mathit{window} = \\left[ a, b, c, \\dots \\right] \\\\[5pt] y_t = f\\left( \\left[ x_{t+a}, x_{t+b}, x_{t+c}, \\dots \\right] \\right) \\end{gathered} \\] If some of the observations are missing, they are still included in the window (typically a NaN for plain numeric time series), and the result may be a missing observation again. This depends on the function used, consider, for instance, the difference between @mean and @nanmean .","title":"Exact specification of moving window"},{"location":"DataManagement/Series/moving.html#moving-window-depending-on-the-availability-of-observations","text":"Use a complex number (with a real part denoting the offset and the imaginary part specifying the length of the window) to specify a window consisting of a fixed number of available (non-missing) observations from the current observation backward, or from the current observation forward (positive imaginary part). The a nonzero offset means that the available (non-missing) observation will be looked up starting not from the current observation, but from an observation before (a negative offset) or after (a positive offset). If \\(\\mathit{window}=a + bi\\) , the algorithm is as follows: For each period \\(t\\) , define the output value \\(y_t\\) by applying the function \\(f\\) to a vector of a total of \\(b\\) observations from the input series \\(x_t\\) constructed as described in steps 2 and 3. If the window length (the imaginary part) \\(b\\) is a negative number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going backward, i.e. \\(x_{t+a}, x_{t+a-1}, x_{t+a-2}, \\dots\\) , all the way to the very first observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going backward. If the window length (the imaginary part) \\(b\\) is a positive number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going forward, i.e. \\(x_{t+a}, x_{t+a+1}, x_{t+a+2}, \\dots\\) , all the way to the very last observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going forward.","title":"Moving window depending on the availability of observations"},{"location":"DataManagement/Series/moving.html#examples","text":"","title":"Examples"},{"location":"DataManagement/Series/moving.html#centered-moving-average-and-sum","text":"Calculate a centered moving average with a total length of the window being 5 observations: x = moving ( x , \"window\" , [ - 2 , - 1 , 0 , 1 , 2 ]) or more concisely x = moving ( x , \"window\" , - 2 : 2 ) Calculate a moving sum on the same window of observations: x = moving(x, \"window\", -2:2, \"function\", @sum)","title":"Centered moving average and sum"},{"location":"DataManagement/Series/moving.html#weighted-centered-moving-average","text":"Supply a user defined function to calculate a weighted centered moving average (with the window specification as in the previous example); we have to use the option Period=true in this case because our function weightedAverage assumes that its input argument is only a vector of 5 numbers (the moving window of observations corresponding to the current period). func = @( x ) 0.10 * x ( 1 ) + 0.15 * x ( 2 ) + 0.50 * x ( 3 ) + 0.15 * x ( 4 ) + 0.10 * x ( 5 ); y = moving ( x , \"window\" , - 2 : 2 , \"function\" , func , \"period\" , true ) This is though equivalent to a more compact expression y = 0.10 * x { - 2 } + 0.15 * x { - 1 } + 0.50 * x + 0.15 * x { 1 } + 0.10 * x { 2 }","title":"Weighted centered moving average"},{"location":"DataManagement/Series/moving.html#average-of-5-last-available-observations","text":"Create a daily series of random observations, and remove weekends; the time series will therefore have NaN s in two out of every seven observations: x = Series ( dd ( 2000 , 1 , 1 ): dd ( 2020 , 12 , 31 ), @ randn ); x = removeWeekends ( x ); Create a time series by calculating the average of the five most recent observations available (i.e. excluding any missing observations): y0 = moving ( x , \"window\" , - 5 i ) Create a time series by calculating the average of the five most recent observations available as before, but now starting from the previous month (not including the current observation); in other words, select the latest available five observations among \\(x_{t-1}, x_{t-2}, \\dots\\) y1 = moving ( x , \"window\" , - 1 - 5 i )","title":"Average of 5 last available observations"},{"location":"DataManagement/Series/randomlyGrowing.html","text":"Series.randomlyGrowing Create randomly growing time series Syntax outputSeries = Series.randomlyGrowing(range) outputSeries = Series.randomlyGrowing(range, [mean, stdev], ...) Input Arguments range [ Dater ] Date range on which the randomly growing time series will be created. [mean=0, stdev=1] [ numeric ] The mean and std deviation of the Normal distribution from which the log-growth rate or the difference will be drawn; see Description. Output Arguments outputSeries [ Series ] Output time series. Options Comment=\"\" [ string ] Comment, or an array of comments (depending on the Dimensions option) that will be assigned to the outputSeries . Dimensions=1 [ numeric ] The size of the outputSeries in 2nd and higher dimensions. Exponentiate=true [ true | false ] Exponentiate the cumulative sum of random numbers to create the outputSeries . Initial=0 [ numeric ] Initial value for the cumulative sum of random numbers (before exponentiation when Exponentiate=true . Description The output series is created as follows: Generate a series of a total of N random numbers from \\(N(\\mu, \\sigma)\\) , where the mean \\(\\mu\\) and the std deviation \\(\\sigma\\) are determined by the input arguments mean and stdev , respectively, and N is the number of periods in the range . Replace the first random number in the series with Initial , and calculate the cumulative sum of these random numbers. When Exponentiate=true , exponentiate the cumulated series. Example x = Series . randomlyGrowing ( qq ( 2020 , 1 ): qq ( 2030 , 4 ), [ 0.01 , 0.02 ])","title":"Series.randomlyGrowing"},{"location":"DataManagement/Series/randomlyGrowing.html#seriesrandomlygrowing","text":"Create randomly growing time series","title":"Series.randomlyGrowing"},{"location":"DataManagement/Series/randomlyGrowing.html#syntax","text":"outputSeries = Series.randomlyGrowing(range) outputSeries = Series.randomlyGrowing(range, [mean, stdev], ...)","title":"Syntax"},{"location":"DataManagement/Series/randomlyGrowing.html#input-arguments","text":"range [ Dater ] Date range on which the randomly growing time series will be created. [mean=0, stdev=1] [ numeric ] The mean and std deviation of the Normal distribution from which the log-growth rate or the difference will be drawn; see Description.","title":"Input Arguments"},{"location":"DataManagement/Series/randomlyGrowing.html#output-arguments","text":"outputSeries [ Series ] Output time series.","title":"Output Arguments"},{"location":"DataManagement/Series/randomlyGrowing.html#options","text":"Comment=\"\" [ string ] Comment, or an array of comments (depending on the Dimensions option) that will be assigned to the outputSeries . Dimensions=1 [ numeric ] The size of the outputSeries in 2nd and higher dimensions. Exponentiate=true [ true | false ] Exponentiate the cumulative sum of random numbers to create the outputSeries . Initial=0 [ numeric ] Initial value for the cumulative sum of random numbers (before exponentiation when Exponentiate=true .","title":"Options"},{"location":"DataManagement/Series/randomlyGrowing.html#description","text":"The output series is created as follows: Generate a series of a total of N random numbers from \\(N(\\mu, \\sigma)\\) , where the mean \\(\\mu\\) and the std deviation \\(\\sigma\\) are determined by the input arguments mean and stdev , respectively, and N is the number of periods in the range . Replace the first random number in the series with Initial , and calculate the cumulative sum of these random numbers. When Exponentiate=true , exponentiate the cumulated series.","title":"Description"},{"location":"DataManagement/Series/randomlyGrowing.html#example","text":"x = Series . randomlyGrowing ( qq ( 2020 , 1 ): qq ( 2030 , 4 ), [ 0.01 , 0.02 ])","title":"Example"},{"location":"DataManagement/Series/rebase.html","text":"rebase Rebase times series data to specified period Syntax [outputSeries, priorValue, reciprocal] = rebase(inputSeries, basePeriod, baseValue, ___) Input arguments inputSeries [ Series ] Input time series that will be rebased. basePeriod [ Dater | \"allStart\" | \"allEnd\" ] - Date relative to which the input data will be rebased; 'allStart' means the first date for which all time series columns have a NaN observation; 'allEnd' means the last such date. The basePeriod may be a vector of dates, in which case the mean or geometric mean of the corresponding values will be calculated. baseValue [ numeric ] The new value that the outputSeries will see in the basePeriod . Options Mode=\"auto\" [ \"auto\" | \"additive\" | \"multiplicative\" ] Rebasing mode; if Mode=\"auto\" , the rebasing mode will be based on the baseValue : \"additive\" for baseValue=0 , \"multiplicative\" otherwise; Reciprocal=[] [ empty | Series ] A reciprocal series that will be rebased so that the sum or the product (depending on the Mode= ) of the inputSeries and the Reciprocal is preserved. The Reciprocal= series must be the same size as the inputSeries . Output arguments outputSeries [ Series ] Rebased output time series. priorValue [ numeric ] The value of the inputSeries in basePeriod before rebasing. reciprocal [ empty | Series ] Rebased reciprocal series. Description Example","title":"rebase"},{"location":"DataManagement/Series/rebase.html#rebase","text":"Rebase times series data to specified period","title":"rebase"},{"location":"DataManagement/Series/rebase.html#syntax","text":"[outputSeries, priorValue, reciprocal] = rebase(inputSeries, basePeriod, baseValue, ___)","title":"Syntax"},{"location":"DataManagement/Series/rebase.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be rebased. basePeriod [ Dater | \"allStart\" | \"allEnd\" ] - Date relative to which the input data will be rebased; 'allStart' means the first date for which all time series columns have a NaN observation; 'allEnd' means the last such date. The basePeriod may be a vector of dates, in which case the mean or geometric mean of the corresponding values will be calculated. baseValue [ numeric ] The new value that the outputSeries will see in the basePeriod .","title":"Input arguments"},{"location":"DataManagement/Series/rebase.html#options","text":"Mode=\"auto\" [ \"auto\" | \"additive\" | \"multiplicative\" ] Rebasing mode; if Mode=\"auto\" , the rebasing mode will be based on the baseValue : \"additive\" for baseValue=0 , \"multiplicative\" otherwise; Reciprocal=[] [ empty | Series ] A reciprocal series that will be rebased so that the sum or the product (depending on the Mode= ) of the inputSeries and the Reciprocal is preserved. The Reciprocal= series must be the same size as the inputSeries .","title":"Options"},{"location":"DataManagement/Series/rebase.html#output-arguments","text":"outputSeries [ Series ] Rebased output time series. priorValue [ numeric ] The value of the inputSeries in basePeriod before rebasing. reciprocal [ empty | Series ] Rebased reciprocal series.","title":"Output arguments"},{"location":"DataManagement/Series/rebase.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/rebase.html#example","text":"","title":"Example"},{"location":"DataManagement/Series/regress.html","text":"regress Ordinary or weighted least-square regression Syntax [res, stdEst, res, stdRes, fit, dates, covEst] = regress(lhs, rhs, ...) Input arguments lhs [ Series ] Time series of dependent (LHS) variables; can be a multivariate time series object for multiple dependent variables (sharing the same explanatory variables). rhs [ Series ] Time series of explanatory (RHS) variables; can be a multivariate time series object for multiple explanatory variables. Output arguments est [ numeric ] Vector of estimated regression parameters. stdEst [ numeric ] Vector of std errors of the parameter estimates. res [ Series ] Time series of the regression residuals. stdRes [ numeric ] Estimate of the std deviation of the regression residuals. fit [ Series ] Time series of fitted values for the LHS variable(s). Dates [ numeric ] The dates of observations actually used in the regression. covEst [ numeric ] Covariance matrix of the regression parameter estimates. Options Dates=Inf [ Dater | Inf ] Dates on which the regression will be run; Dates=Inf means the entire range available will be used. Intercept=false [ true | false ] Include an intercept in the regression; Intercept=true means the intercept will be placed last in the matrix of explanatory variables. Weights=[] [ Series | empty ] Time series of regression weights on the observations in individual periods; Weights=[] means equal unit weight on all observations. Description This function calls the built-in lscov function. Example Generate random explanatory variables x and y and noise e , construct a dependent variable a , and estimate two regressions, one excluding the intercept (not included in the \"true\" relationship), the other including the intercept. x = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); y = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); e = Series ( qq ( 2020 , 1 ), 0.1 * randn ( 1000 , 1 )); a = 0.5 * x - 0.5 * y + e ; [ est1 , stdEst2 ] = regress ( a , [ x , y ]) [ est2 , stdEst2 ] = regress ( a , [ x , y ], intercept = true )","title":"regress"},{"location":"DataManagement/Series/regress.html#regress","text":"Ordinary or weighted least-square regression","title":"regress"},{"location":"DataManagement/Series/regress.html#syntax","text":"[res, stdEst, res, stdRes, fit, dates, covEst] = regress(lhs, rhs, ...)","title":"Syntax"},{"location":"DataManagement/Series/regress.html#input-arguments","text":"lhs [ Series ] Time series of dependent (LHS) variables; can be a multivariate time series object for multiple dependent variables (sharing the same explanatory variables). rhs [ Series ] Time series of explanatory (RHS) variables; can be a multivariate time series object for multiple explanatory variables.","title":"Input arguments"},{"location":"DataManagement/Series/regress.html#output-arguments","text":"est [ numeric ] Vector of estimated regression parameters. stdEst [ numeric ] Vector of std errors of the parameter estimates. res [ Series ] Time series of the regression residuals. stdRes [ numeric ] Estimate of the std deviation of the regression residuals. fit [ Series ] Time series of fitted values for the LHS variable(s). Dates [ numeric ] The dates of observations actually used in the regression. covEst [ numeric ] Covariance matrix of the regression parameter estimates.","title":"Output arguments"},{"location":"DataManagement/Series/regress.html#options","text":"Dates=Inf [ Dater | Inf ] Dates on which the regression will be run; Dates=Inf means the entire range available will be used. Intercept=false [ true | false ] Include an intercept in the regression; Intercept=true means the intercept will be placed last in the matrix of explanatory variables. Weights=[] [ Series | empty ] Time series of regression weights on the observations in individual periods; Weights=[] means equal unit weight on all observations.","title":"Options"},{"location":"DataManagement/Series/regress.html#description","text":"This function calls the built-in lscov function.","title":"Description"},{"location":"DataManagement/Series/regress.html#example","text":"Generate random explanatory variables x and y and noise e , construct a dependent variable a , and estimate two regressions, one excluding the intercept (not included in the \"true\" relationship), the other including the intercept. x = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); y = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); e = Series ( qq ( 2020 , 1 ), 0.1 * randn ( 1000 , 1 )); a = 0.5 * x - 0.5 * y + e ; [ est1 , stdEst2 ] = regress ( a , [ x , y ]) [ est2 , stdEst2 ] = regress ( a , [ x , y ], intercept = true )","title":"Example"},{"location":"DataManagement/Series/rmse.html","text":"rmse Calculate RMSE for given observations and predictions Syntax [rmse, error] = rmse(inputSeries, prediction, ...) Input arguments actual [ Series ] Input time series with actual observations. prediction [ Series ] Input time series with predictions, possibly including multiple prediction horizons in individual columns; this is typically the outcome of running a Kalman filter with the option Ahead= . Options Range=Inf [ Dater | Inf ] Date range on which the prediction errors will be calculated; Inf means all observations available will be included in the calculations. Output arguments rootMSE [ numeric ] Numeric array with root mean squared errors for each column of the prediction time series. error [ Series ] - Time series with prediction errors from which the RMSEs are calculated; error is simply the difference between actual and the individual columns in prediction . Description Example","title":"rmse"},{"location":"DataManagement/Series/rmse.html#rmse","text":"Calculate RMSE for given observations and predictions","title":"rmse"},{"location":"DataManagement/Series/rmse.html#syntax","text":"[rmse, error] = rmse(inputSeries, prediction, ...)","title":"Syntax"},{"location":"DataManagement/Series/rmse.html#input-arguments","text":"actual [ Series ] Input time series with actual observations. prediction [ Series ] Input time series with predictions, possibly including multiple prediction horizons in individual columns; this is typically the outcome of running a Kalman filter with the option Ahead= .","title":"Input arguments"},{"location":"DataManagement/Series/rmse.html#options","text":"Range=Inf [ Dater | Inf ] Date range on which the prediction errors will be calculated; Inf means all observations available will be included in the calculations.","title":"Options"},{"location":"DataManagement/Series/rmse.html#output-arguments","text":"rootMSE [ numeric ] Numeric array with root mean squared errors for each column of the prediction time series. error [ Series ] - Time series with prediction errors from which the RMSEs are calculated; error is simply the difference between actual and the individual columns in prediction .","title":"Output arguments"},{"location":"DataManagement/Series/rmse.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/rmse.html#example","text":"","title":"Example"},{"location":"DataManagement/Series/seasonDummy.html","text":"Series.seasonDummy Create time series with seasonal dummies Syntax outputSeries = Series.seasonDummy(range, dummyPeriods, ...) Input Arguments range [ Dater ] Date range on which the time series will be created. dummyPeriods [ numeric ] Numeric periods in which the new outputSeries will be assigned the value 1 in each year of the range ; otherwise, the values will 0 ; the dummyPeriods are frequency specific and depend on the date frequency of the range , e.g. the dummyPeriods represent quarters for a quarterly range , months for a monthly range , etc. Any further input arguments (third, fourth, etc.) will be pased into the Series constructor as the third, fourth, etc. input arguments (i.e. the comments , userData , etc.) Output Arguments outputSeries [ Series ] New time series with the value 1 in the dummyPeriods in each year within the range , and with 0 otherwise. Description Examples x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), 1 ) x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), [ 1 , 7 ])","title":"Series.seasonDummy"},{"location":"DataManagement/Series/seasonDummy.html#seriesseasondummy","text":"Create time series with seasonal dummies","title":"Series.seasonDummy"},{"location":"DataManagement/Series/seasonDummy.html#syntax","text":"outputSeries = Series.seasonDummy(range, dummyPeriods, ...)","title":"Syntax"},{"location":"DataManagement/Series/seasonDummy.html#input-arguments","text":"range [ Dater ] Date range on which the time series will be created. dummyPeriods [ numeric ] Numeric periods in which the new outputSeries will be assigned the value 1 in each year of the range ; otherwise, the values will 0 ; the dummyPeriods are frequency specific and depend on the date frequency of the range , e.g. the dummyPeriods represent quarters for a quarterly range , months for a monthly range , etc. Any further input arguments (third, fourth, etc.) will be pased into the Series constructor as the third, fourth, etc. input arguments (i.e. the comments , userData , etc.)","title":"Input Arguments"},{"location":"DataManagement/Series/seasonDummy.html#output-arguments","text":"outputSeries [ Series ] New time series with the value 1 in the dummyPeriods in each year within the range , and with 0 otherwise.","title":"Output Arguments"},{"location":"DataManagement/Series/seasonDummy.html#description","text":"","title":"Description"},{"location":"DataManagement/Series/seasonDummy.html#examples","text":"x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), 1 ) x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), [ 1 , 7 ])","title":"Examples"},{"location":"DataManagement/databank/index.html","text":"Overview of databank functions IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks. Categorical list of functions Creating, converting, importing, and exporting databanks Function Description databank.toArray Create numeric array from time series data databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series Getting information about databanks Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields databank.range Find a range that encompasses the ranges of all or selected databank time series Processing databanks Function Description databank.addMissingFields databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy Copy fields of source databank to target databank databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields Manipulating model databanks Function Description databank.minusControl Create simulation-minus-control database","title":"Overview of databank functions"},{"location":"DataManagement/databank/index.html#overview-of-databank-functions","text":"IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks.","title":"Overview of databank functions"},{"location":"DataManagement/databank/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"DataManagement/databank/index.html#creating-converting-importing-and-exporting-databanks","text":"Function Description databank.toArray Create numeric array from time series data databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series","title":"Creating, converting, importing, and exporting databanks"},{"location":"DataManagement/databank/index.html#getting-information-about-databanks","text":"Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields databank.range Find a range that encompasses the ranges of all or selected databank time series","title":"Getting information about databanks"},{"location":"DataManagement/databank/index.html#processing-databanks","text":"Function Description databank.addMissingFields databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy Copy fields of source databank to target databank databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields","title":"Processing databanks"},{"location":"DataManagement/databank/index.html#manipulating-model-databanks","text":"Function Description databank.minusControl Create simulation-minus-control database","title":"Manipulating model databanks"},{"location":"DataManagement/databank/addMissingFields.html","text":"addMissingFields Create fields missing from a list, and assign them a default value Syntax db = databank.addMissingFields(db, names, value) Input arguments db [ struct | Dictionary ] Input databank that will be checked for names , and new fields will be created for the names missing, assigned a default value . names [ string ] List of field names; any field listed in names that does not exist in the db will be created in db and assigned the default value . values [ * ] A default value for fields that are missing from the names . Output arguments db [ struct | Dictionary ] Output databank will all the names guaranteed to exist in it. Description Examples Make sure that field names \"a\", \"b\", and \"c\" all exist in a databank; if not, create them and assign NaN : d = struct (); d . a = 1 ; d = databank . addMissingFields ( d , [ \"a\" , \"b\" , \"c\" ], NaN );","title":"addMissingFields"},{"location":"DataManagement/databank/addMissingFields.html#addmissingfields","text":"Create fields missing from a list, and assign them a default value","title":"addMissingFields"},{"location":"DataManagement/databank/addMissingFields.html#syntax","text":"db = databank.addMissingFields(db, names, value)","title":"Syntax"},{"location":"DataManagement/databank/addMissingFields.html#input-arguments","text":"db [ struct | Dictionary ] Input databank that will be checked for names , and new fields will be created for the names missing, assigned a default value . names [ string ] List of field names; any field listed in names that does not exist in the db will be created in db and assigned the default value . values [ * ] A default value for fields that are missing from the names .","title":"Input arguments"},{"location":"DataManagement/databank/addMissingFields.html#output-arguments","text":"db [ struct | Dictionary ] Output databank will all the names guaranteed to exist in it.","title":"Output arguments"},{"location":"DataManagement/databank/addMissingFields.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/addMissingFields.html#examples","text":"Make sure that field names \"a\", \"b\", and \"c\" all exist in a databank; if not, create them and assign NaN : d = struct (); d . a = 1 ; d = databank . addMissingFields ( d , [ \"a\" , \"b\" , \"c\" ], NaN );","title":"Examples"},{"location":"DataManagement/databank/apply.html","text":"databank.apply Apply function to a selection of databank fields Syntax [outputDb, appliedToNames, newNames] = databank.apply(inputDb, func, ...) Input arguments inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb . Output arguments outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb . Options StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields. TargetDb=@default [ @default | struct | Dictionary ] Databank to which the transformed fields will be added; TargetDb=@default means they will be kept in the inputDb . WhenError=\"keep\" [ \"keep\" | \"remove\" | \"error\" ] What to do when the function func fails with an error on a field: \"keep\" means the field will be kept in the outputDb unchanged; \"remove\" means the field will be removed from the outputDb ; \"error\" means the execution of databank.apply will stop with an error. Description Example Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 ); Example Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"apply"},{"location":"DataManagement/databank/apply.html#databankapply","text":"Apply function to a selection of databank fields","title":"databank.apply"},{"location":"DataManagement/databank/apply.html#syntax","text":"[outputDb, appliedToNames, newNames] = databank.apply(inputDb, func, ...)","title":"Syntax"},{"location":"DataManagement/databank/apply.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb .","title":"Input arguments"},{"location":"DataManagement/databank/apply.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb .","title":"Output arguments"},{"location":"DataManagement/databank/apply.html#options","text":"StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields. TargetDb=@default [ @default | struct | Dictionary ] Databank to which the transformed fields will be added; TargetDb=@default means they will be kept in the inputDb . WhenError=\"keep\" [ \"keep\" | \"remove\" | \"error\" ] What to do when the function func fails with an error on a field: \"keep\" means the field will be kept in the outputDb unchanged; \"remove\" means the field will be removed from the outputDb ; \"error\" means the execution of databank.apply will stop with an error.","title":"Options"},{"location":"DataManagement/databank/apply.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/apply.html#example","text":"Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 );","title":"Example"},{"location":"DataManagement/databank/apply.html#example_1","text":"Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"Example"},{"location":"DataManagement/databank/clip.html","text":"databank.clip Clip all time series in databank to a new range Syntax outputDatabank = databank.clip(inputDatabank, newStart, newEnd) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered. Output Arguments outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range. Description Example Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"databank.clip"},{"location":"DataManagement/databank/clip.html#databankclip","text":"Clip all time series in databank to a new range","title":"databank.clip"},{"location":"DataManagement/databank/clip.html#syntax","text":"outputDatabank = databank.clip(inputDatabank, newStart, newEnd)","title":"Syntax"},{"location":"DataManagement/databank/clip.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered.","title":"Input Arguments"},{"location":"DataManagement/databank/clip.html#output-arguments","text":"outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range.","title":"Output Arguments"},{"location":"DataManagement/databank/clip.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/clip.html#example","text":"Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"Example"},{"location":"DataManagement/databank/copy.html","text":"databank.copy Copy fields of source databank to target databank Syntax targetDb = databank.copy(sourceDb, ...) Input Arguments sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb . Options SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle ] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform={} [ empty | function_handle | cell ] Transformation function or functions applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed; if a cell array of functions, each function will be applied consecutively. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank. Output Arguments targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over. Description Example","title":"databank.copy"},{"location":"DataManagement/databank/copy.html#databankcopy","text":"Copy fields of source databank to target databank","title":"databank.copy"},{"location":"DataManagement/databank/copy.html#syntax","text":"targetDb = databank.copy(sourceDb, ...)","title":"Syntax"},{"location":"DataManagement/databank/copy.html#input-arguments","text":"sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb .","title":"Input Arguments"},{"location":"DataManagement/databank/copy.html#options","text":"SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle ] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform={} [ empty | function_handle | cell ] Transformation function or functions applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed; if a cell array of functions, each function will be applied consecutively. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank.","title":"Options"},{"location":"DataManagement/databank/copy.html#output-arguments","text":"targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over.","title":"Output Arguments"},{"location":"DataManagement/databank/copy.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/copy.html#example","text":"","title":"Example"},{"location":"DataManagement/databank/eval.html","text":"databank.eval Evaluate an expression within a databank context Syntax [output, output, ...] = databank.eval(inputDb, expression, expression, ...) outputs = databank.eval(inputDb, expressions) outputDb = databank.eval(inputDb, expressionsDb) Input Arguments inputDb [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDb fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDb fields. expressionsDb [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated. Output Arguments output [ * ] Result of the expression evaluated in the inputDb workspace. outputs [ cell ] Results of the expressions evaluated in the inputDb workspace. outputDb [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDb workspace. Description Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDb fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDb . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDb fields. To include round-bracket references to inputDb fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis. Example d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"databank.eval"},{"location":"DataManagement/databank/eval.html#databankeval","text":"Evaluate an expression within a databank context","title":"databank.eval"},{"location":"DataManagement/databank/eval.html#syntax","text":"[output, output, ...] = databank.eval(inputDb, expression, expression, ...) outputs = databank.eval(inputDb, expressions) outputDb = databank.eval(inputDb, expressionsDb)","title":"Syntax"},{"location":"DataManagement/databank/eval.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDb fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDb fields. expressionsDb [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated.","title":"Input Arguments"},{"location":"DataManagement/databank/eval.html#output-arguments","text":"output [ * ] Result of the expression evaluated in the inputDb workspace. outputs [ cell ] Results of the expressions evaluated in the inputDb workspace. outputDb [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDb workspace.","title":"Output Arguments"},{"location":"DataManagement/databank/eval.html#description","text":"Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDb fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDb . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDb fields. To include round-bracket references to inputDb fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis.","title":"Description"},{"location":"DataManagement/databank/eval.html#example","text":"d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"Example"},{"location":"DataManagement/databank/fieldNames.html","text":"databank.fieldNames List of databank field names as a row vector of strings Syntax list = databank.fieldNames(db) Input Arguments db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object. Output Arguments list [ string ] List of all field names contained in the input db , arranged as a row vector of strings. Description The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop. Example d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"databank.fieldNames"},{"location":"DataManagement/databank/fieldNames.html#databankfieldnames","text":"List of databank field names as a row vector of strings","title":"databank.fieldNames"},{"location":"DataManagement/databank/fieldNames.html#syntax","text":"list = databank.fieldNames(db)","title":"Syntax"},{"location":"DataManagement/databank/fieldNames.html#input-arguments","text":"db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object.","title":"Input Arguments"},{"location":"DataManagement/databank/fieldNames.html#output-arguments","text":"list [ string ] List of all field names contained in the input db , arranged as a row vector of strings.","title":"Output Arguments"},{"location":"DataManagement/databank/fieldNames.html#description","text":"The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop.","title":"Description"},{"location":"DataManagement/databank/fieldNames.html#example","text":"d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"Example"},{"location":"DataManagement/databank/filterFields.html","text":"databank.filterFields Get the names of databank fields that pass name or value tests Syntax list = databank.filterFields(inputDb, ...) Input Arguments inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values. Output Arguments list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests. Options __ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test. Description Example","title":"databank.filterFields"},{"location":"DataManagement/databank/filterFields.html#databankfilterfields","text":"Get the names of databank fields that pass name or value tests","title":"databank.filterFields"},{"location":"DataManagement/databank/filterFields.html#syntax","text":"list = databank.filterFields(inputDb, ...)","title":"Syntax"},{"location":"DataManagement/databank/filterFields.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values.","title":"Input Arguments"},{"location":"DataManagement/databank/filterFields.html#output-arguments","text":"list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests.","title":"Output Arguments"},{"location":"DataManagement/databank/filterFields.html#options","text":"__ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test.","title":"Options"},{"location":"DataManagement/databank/filterFields.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/filterFields.html#example","text":"","title":"Example"},{"location":"DataManagement/databank/fromCSV.html","text":"databank.fromCSV Create databank by loading CSV file Syntax outputDb = databank.fromCSV(fileName, ...) TL;DR db = databank.fromCSV(\"data.csv\") db = databank.fromCSV(\"data.csv\", skipRows=1:5) db = databank.fromCSV( ... \"data.csv\" ... , dateFormat=\"yyyy/m/d\" ... , enforceFrequency=Frequency.QUARTERY ... ) Input Arguments fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined. Output Arguments outputDb [ struct | Dictionary ] Database created from the input CSV file(s). Options AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Postprocess=[] [ function_handle | empty ] Apply this function to all fields (regardless of the type/class of the data) created within this run of databank.fromCSV . Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series. Description Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example). Structure of CSV Data Files The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | Example Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"databank.fromCSV"},{"location":"DataManagement/databank/fromCSV.html#databankfromcsv","text":"Create databank by loading CSV file","title":"databank.fromCSV"},{"location":"DataManagement/databank/fromCSV.html#syntax","text":"outputDb = databank.fromCSV(fileName, ...)","title":"Syntax"},{"location":"DataManagement/databank/fromCSV.html#tldr","text":"db = databank.fromCSV(\"data.csv\") db = databank.fromCSV(\"data.csv\", skipRows=1:5) db = databank.fromCSV( ... \"data.csv\" ... , dateFormat=\"yyyy/m/d\" ... , enforceFrequency=Frequency.QUARTERY ... )","title":"TL;DR"},{"location":"DataManagement/databank/fromCSV.html#input-arguments","text":"fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined.","title":"Input Arguments"},{"location":"DataManagement/databank/fromCSV.html#output-arguments","text":"outputDb [ struct | Dictionary ] Database created from the input CSV file(s).","title":"Output Arguments"},{"location":"DataManagement/databank/fromCSV.html#options","text":"AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Postprocess=[] [ function_handle | empty ] Apply this function to all fields (regardless of the type/class of the data) created within this run of databank.fromCSV . Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series.","title":"Options"},{"location":"DataManagement/databank/fromCSV.html#description","text":"Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example).","title":"Description"},{"location":"DataManagement/databank/fromCSV.html#structure-of-csv-data-files","text":"The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | |","title":"Structure of CSV Data Files"},{"location":"DataManagement/databank/fromCSV.html#example","text":"Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"DataManagement/databank/list.html","text":"databank.list List databank fields adding date range to time series fields Syntax databank.list(db) Input Arguments db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields. Description Example d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"databank.list"},{"location":"DataManagement/databank/list.html#databanklist","text":"List databank fields adding date range to time series fields","title":"databank.list"},{"location":"DataManagement/databank/list.html#syntax","text":"databank.list(db)","title":"Syntax"},{"location":"DataManagement/databank/list.html#input-arguments","text":"db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields.","title":"Input Arguments"},{"location":"DataManagement/databank/list.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/list.html#example","text":"d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"Example"},{"location":"DataManagement/databank/merge.html","text":"databank.merge Merge two or more databanks Syntax outputDb = databank.merge(method, primaryDb [, otherDb ], ___) Shortcut syntax for databank.merge(\"horzcat\", ___) outputDb = databank.horzcat(primaryDb, [, otherDb], ___) Input arguments method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb . Output arguments outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method . Options MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" . Description The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown. Example","title":"databank.merge"},{"location":"DataManagement/databank/merge.html#databankmerge","text":"Merge two or more databanks","title":"databank.merge"},{"location":"DataManagement/databank/merge.html#syntax","text":"outputDb = databank.merge(method, primaryDb [, otherDb ], ___)","title":"Syntax"},{"location":"DataManagement/databank/merge.html#shortcut-syntax-for-databankmergehorzcat-___","text":"outputDb = databank.horzcat(primaryDb, [, otherDb], ___)","title":"Shortcut syntax for databank.merge(\"horzcat\", ___)"},{"location":"DataManagement/databank/merge.html#input-arguments","text":"method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb .","title":"Input arguments"},{"location":"DataManagement/databank/merge.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method .","title":"Output arguments"},{"location":"DataManagement/databank/merge.html#options","text":"MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" .","title":"Options"},{"location":"DataManagement/databank/merge.html#description","text":"The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown.","title":"Description"},{"location":"DataManagement/databank/merge.html#example","text":"","title":"Example"},{"location":"DataManagement/databank/minusControl.html","text":"databank.minusControl Create simulation-minus-control database Syntax [outputDb, controlDb] = databank.minusControl(model, inputDb, ...) [outputDb, controlDb] = databank.minusControl(model, inputDb, controlDb, ...) Input arguments __ model [ model ] Model object on which the databases inputDb and controlDb __ are based. inputDb [ struct ] Simulation (or any other kind of) databank from which the controlDb will be subtracted. ^__ controlDb [ struct ] Control database that will be subtracted form the inputDb ; if omitted a steady-state databank for the model is created and used in the place of the control databank. Output arguments outputData [ struct ] Simulation-minus-control database, in which all log variables are inputDb.x/controlDb.x , and all other variables are inputDb.x-controlDb.x . controlDb [ struct ] Control database that has been subtracted from the inputDb database to create outputDb . Options Range=Inf [ Dater | Inf ] This range is used in two places: if a controlDb is not supplied, the model steady-state databank is created with the Range= input argument (meaning the control databank will exist on this range plus any necessary presample and postsample periods); if opt.Range refers to -Inf or Inf , then the control databank is created on an all-encompassing range of the inputDb . each model variable time series is clipped to the Range= before being included in the outputDb . Description Example Run a shock simulation in full levels using a steady-state (or balanced-growth-path) database as input, and then compute the deviations from the steady state: d = steadydb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , prependInput = true ); s = databank . minusControl ( m , s , d ); or simply s = databank . minusControl ( m , s ); The above block of code is equivalent to this one: d = zerodb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , deviation = true , prependInput = true );","title":"databank.minusControl"},{"location":"DataManagement/databank/minusControl.html#databankminuscontrol","text":"Create simulation-minus-control database","title":"databank.minusControl"},{"location":"DataManagement/databank/minusControl.html#syntax","text":"[outputDb, controlDb] = databank.minusControl(model, inputDb, ...) [outputDb, controlDb] = databank.minusControl(model, inputDb, controlDb, ...)","title":"Syntax"},{"location":"DataManagement/databank/minusControl.html#input-arguments","text":"__ model [ model ] Model object on which the databases inputDb and controlDb __ are based. inputDb [ struct ] Simulation (or any other kind of) databank from which the controlDb will be subtracted. ^__ controlDb [ struct ] Control database that will be subtracted form the inputDb ; if omitted a steady-state databank for the model is created and used in the place of the control databank.","title":"Input arguments"},{"location":"DataManagement/databank/minusControl.html#output-arguments","text":"outputData [ struct ] Simulation-minus-control database, in which all log variables are inputDb.x/controlDb.x , and all other variables are inputDb.x-controlDb.x . controlDb [ struct ] Control database that has been subtracted from the inputDb database to create outputDb .","title":"Output arguments"},{"location":"DataManagement/databank/minusControl.html#options","text":"Range=Inf [ Dater | Inf ] This range is used in two places: if a controlDb is not supplied, the model steady-state databank is created with the Range= input argument (meaning the control databank will exist on this range plus any necessary presample and postsample periods); if opt.Range refers to -Inf or Inf , then the control databank is created on an all-encompassing range of the inputDb . each model variable time series is clipped to the Range= before being included in the outputDb .","title":"Options"},{"location":"DataManagement/databank/minusControl.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/minusControl.html#example","text":"Run a shock simulation in full levels using a steady-state (or balanced-growth-path) database as input, and then compute the deviations from the steady state: d = steadydb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , prependInput = true ); s = databank . minusControl ( m , s , d ); or simply s = databank . minusControl ( m , s ); The above block of code is equivalent to this one: d = zerodb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , deviation = true , prependInput = true );","title":"Example"},{"location":"DataManagement/databank/range.html","text":"databank.range Find a range that encompasses the ranges of all or selected databank time series Syntax [range, listFreq] = databank.range(inputDb, ...) Input Arguments inputDb [ struct | Dictionary ] Input databank; can be either a struct, or a Dictionary. Output Arguments range [ Dater | cell ] Range that encompasses the observations of the time series in the input database; if time series with different frequencies are contained in the inputDb then the ranges, one for each of the frequency, are returned in a cell array. listFreq [ numeric ] Vector of date frequencies coresponding to the returned ranges. Options SourceNames=@all [ string | Rexp | @all ] List of time series that will be included in the range search or a regular expression that will be matched to compose the list; @all means all time series objects existing in the input databases will be included. StartDate=\"unbalanced\" [ \"unbalanced\" ] StartDate=\"unbalanced\" means the output range will start at the earliest start date among all them time series included in the search; StartDate=\"balanced\" means the range will start at the latest start date. EndDate=\"unbalanced\" [ \"unbalanced\" | \"balanced\" ] EndDate=\"unbalanced\" means the range will end at the latest end date among all the time series included in the search; EndDate=\"balanced\" means the range will end at the earliest end date. Description Example","title":"databank.range"},{"location":"DataManagement/databank/range.html#databankrange","text":"Find a range that encompasses the ranges of all or selected databank time series","title":"databank.range"},{"location":"DataManagement/databank/range.html#syntax","text":"[range, listFreq] = databank.range(inputDb, ...)","title":"Syntax"},{"location":"DataManagement/databank/range.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank; can be either a struct, or a Dictionary.","title":"Input Arguments"},{"location":"DataManagement/databank/range.html#output-arguments","text":"range [ Dater | cell ] Range that encompasses the observations of the time series in the input database; if time series with different frequencies are contained in the inputDb then the ranges, one for each of the frequency, are returned in a cell array. listFreq [ numeric ] Vector of date frequencies coresponding to the returned ranges.","title":"Output Arguments"},{"location":"DataManagement/databank/range.html#options","text":"SourceNames=@all [ string | Rexp | @all ] List of time series that will be included in the range search or a regular expression that will be matched to compose the list; @all means all time series objects existing in the input databases will be included. StartDate=\"unbalanced\" [ \"unbalanced\" ] StartDate=\"unbalanced\" means the output range will start at the earliest start date among all them time series included in the search; StartDate=\"balanced\" means the range will start at the latest start date. EndDate=\"unbalanced\" [ \"unbalanced\" | \"balanced\" ] EndDate=\"unbalanced\" means the range will end at the latest end date among all the time series included in the search; EndDate=\"balanced\" means the range will end at the earliest end date.","title":"Options"},{"location":"DataManagement/databank/range.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/range.html#example","text":"","title":"Example"},{"location":"DataManagement/databank/retrieveColumns.html","text":"databank.retrieveColumns Retrieve selected columns from databank fields Syntax outputDb = function(inputDb, refs,...) Input Arguments inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd). Output Arguments outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails . Options WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb . Description Example","title":"databank.retrieveColumns"},{"location":"DataManagement/databank/retrieveColumns.html#databankretrievecolumns","text":"Retrieve selected columns from databank fields","title":"databank.retrieveColumns"},{"location":"DataManagement/databank/retrieveColumns.html#syntax","text":"outputDb = function(inputDb, refs,...)","title":"Syntax"},{"location":"DataManagement/databank/retrieveColumns.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd).","title":"Input Arguments"},{"location":"DataManagement/databank/retrieveColumns.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails .","title":"Output Arguments"},{"location":"DataManagement/databank/retrieveColumns.html#options","text":"WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb .","title":"Options"},{"location":"DataManagement/databank/retrieveColumns.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/retrieveColumns.html#example","text":"","title":"Example"},{"location":"DataManagement/databank/toArray.html","text":"databank.toArray Create numeric array from time series data Syntax [outputArray, names, dates] = databank.toArray(inputDb, names, dates, columns) Input arguments inputDb [ struct | Dictionary ] Input databank from which the time series data will be retrieved and converted to a numeric array. names [ string | @all ] List of time series names whose data will be retrieved from the inputDb ; names=@all means all time series fields will be included. dates [ Dater | \"unbalanced\" | \"balanced\" ] Dates for which the time series data will be retrieved; the date frequency of the dates must be consistent with the date frequency of all time series listed in names . dates=Inf is the same as dates=\"unbalanced\" . dates=\"unbalanced\" means the dates will be automatically determined to cover an unbalanced panel of data (the earliest available observation among all time series to the latest). dates=\"balanced\" means the dates will automatically determined to cover a balanced panel of data (the earliest data at which data are available for all time series to the latest date at which data are available for all time series). columns=1 [ numeric ] Column or columns that will be retrieved from the time series data; if multiple columns are specified, the data will be flattened in 2nd dimension; columns=1 if omitted. Output arguments outputArray [ numeric ] Numeric array created from the time series data from the fields listed in names and dates specified in dates . names [ string ] The names of the time series included in the outputArray ; useful when the input argument names=@all . dates [ Dater ] The dates for which the time series data were retrieved and included in the outputArray ; useful when the input argument dates=Inf . Description Examples","title":"databank.toArray"},{"location":"DataManagement/databank/toArray.html#databanktoarray","text":"Create numeric array from time series data","title":"databank.toArray"},{"location":"DataManagement/databank/toArray.html#syntax","text":"[outputArray, names, dates] = databank.toArray(inputDb, names, dates, columns)","title":"Syntax"},{"location":"DataManagement/databank/toArray.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank from which the time series data will be retrieved and converted to a numeric array. names [ string | @all ] List of time series names whose data will be retrieved from the inputDb ; names=@all means all time series fields will be included. dates [ Dater | \"unbalanced\" | \"balanced\" ] Dates for which the time series data will be retrieved; the date frequency of the dates must be consistent with the date frequency of all time series listed in names . dates=Inf is the same as dates=\"unbalanced\" . dates=\"unbalanced\" means the dates will be automatically determined to cover an unbalanced panel of data (the earliest available observation among all time series to the latest). dates=\"balanced\" means the dates will automatically determined to cover a balanced panel of data (the earliest data at which data are available for all time series to the latest date at which data are available for all time series). columns=1 [ numeric ] Column or columns that will be retrieved from the time series data; if multiple columns are specified, the data will be flattened in 2nd dimension; columns=1 if omitted.","title":"Input arguments"},{"location":"DataManagement/databank/toArray.html#output-arguments","text":"outputArray [ numeric ] Numeric array created from the time series data from the fields listed in names and dates specified in dates . names [ string ] The names of the time series included in the outputArray ; useful when the input argument names=@all . dates [ Dater ] The dates for which the time series data were retrieved and included in the outputArray ; useful when the input argument dates=Inf .","title":"Output arguments"},{"location":"DataManagement/databank/toArray.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/toArray.html#examples","text":"","title":"Examples"},{"location":"DataManagement/databank/toCSV.html","text":"databank.toCSV Write databank to CSV file Syntax fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date. Output Arguments fieldsSaved [ string ] List of databank fields that have been written to the output file fileName . Options NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. TargetNames=[] [ empty | function ] Function transforming the databank field names to the names under which the data are saved in the CSV file; TargetNames=[] means no transformation. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field. Description Example Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field. Example D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"databank.toCSV"},{"location":"DataManagement/databank/toCSV.html#databanktocsv","text":"Write databank to CSV file","title":"databank.toCSV"},{"location":"DataManagement/databank/toCSV.html#syntax","text":"fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...)","title":"Syntax"},{"location":"DataManagement/databank/toCSV.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date.","title":"Input Arguments"},{"location":"DataManagement/databank/toCSV.html#output-arguments","text":"fieldsSaved [ string ] List of databank fields that have been written to the output file fileName .","title":"Output Arguments"},{"location":"DataManagement/databank/toCSV.html#options","text":"NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. TargetNames=[] [ empty | function ] Function transforming the databank field names to the names under which the data are saved in the CSV file; TargetNames=[] means no transformation. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field.","title":"Options"},{"location":"DataManagement/databank/toCSV.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/toCSV.html#example","text":"Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field.","title":"Example"},{"location":"DataManagement/databank/toCSV.html#example_1","text":"D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"Example"},{"location":"DataManagement/databank/withEmpty.html","text":"databank.withEmpty Create databank with empty time series Syntax outputDb = databank.withEmpty(names, ...) Input Arguments __ names [ char | cellstr | string ] List of names under which new empty time series will be created. Output Arguments __ outputDb [ struct ] Databank with the new empty time series created or added. Options AddToDatabank=struct() [ struct ] Add the new empty time series to this databank. Description Example","title":"databank.withEmpty"},{"location":"DataManagement/databank/withEmpty.html#databankwithempty","text":"Create databank with empty time series","title":"databank.withEmpty"},{"location":"DataManagement/databank/withEmpty.html#syntax","text":"outputDb = databank.withEmpty(names, ...)","title":"Syntax"},{"location":"DataManagement/databank/withEmpty.html#input-arguments","text":"__ names [ char | cellstr | string ] List of names under which new empty time series will be created.","title":"Input Arguments"},{"location":"DataManagement/databank/withEmpty.html#output-arguments","text":"__ outputDb [ struct ] Databank with the new empty time series created or added.","title":"Output Arguments"},{"location":"DataManagement/databank/withEmpty.html#options","text":"AddToDatabank=struct() [ struct ] Add the new empty time series to this databank.","title":"Options"},{"location":"DataManagement/databank/withEmpty.html#description","text":"","title":"Description"},{"location":"DataManagement/databank/withEmpty.html#example","text":"","title":"Example"},{"location":"Reporting/index.html","text":"Overview of reporting tools","title":"Overview of reporting tools"},{"location":"Reporting/index.html#overview-of-reporting-tools","text":"","title":"Overview of reporting tools"},{"location":"Reporting/databank.Chartpack/index.html","text":"Overview of databank.Chartpack objects Categorical list of functions Creating new chartpacks Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields Defining the content Function Description add Add new chart to a databank.Chartpack object clear Clear all charts from the chartpack Drawing the charts Function Description draw Render charts defined in Chartpack","title":"Overview of databank.Chartpack objects"},{"location":"Reporting/databank.Chartpack/index.html#overview-of-databankchartpack-objects","text":"","title":"Overview of databank.Chartpack objects"},{"location":"Reporting/databank.Chartpack/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"Reporting/databank.Chartpack/index.html#creating-new-chartpacks","text":"Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields","title":"Creating new chartpacks"},{"location":"Reporting/databank.Chartpack/index.html#defining-the-content","text":"Function Description add Add new chart to a databank.Chartpack object clear Clear all charts from the chartpack","title":"Defining the content"},{"location":"Reporting/databank.Chartpack/index.html#drawing-the-charts","text":"Function Description draw Render charts defined in Chartpack","title":"Drawing the charts"},{"location":"Reporting/databank.Chartpack/Chartpack.html","text":"databank.Chartpack Create a new Chartpack object for plotting databank fields Syntax ch = databank.Chartpack() Output Arguments ch [ databank.Chartpack ] New empty databank.Chartpack object Customizable properties After creating a new Chartpack object, set the following properties to customize the way the charts are produced and styled: Customize visual aspects of individual charts PlotFunc=@plot [ @plot ] Plot function used to create each of the charts. Highlight=[] [ Dater | cell | empty ] Date range, or a cell array of date ranges, that will be highlighted in each chart. Customize data plotted Range=Inf [ Dater | Inf ] Date range or horizontal axis range on which the charts will be created. Range=Inf means each chart will encompass the range necessary to accommodate the entire time series plotted. Round=Inf [ numeric ] Round the data to this number of decimal places before plotting them. Transform=[] [ function | empty ] Function that will be applied to each data input before it gets plotted, except input data entered with a \"^\" at the beginning of their expression string. Customize chart captions CaptionFromComment=false [ true | false ] If chart caption is missing, use the time series comments to create the captions. Newline=\"//\" [ string ] Separator between lines in the captions of the charts. ShowFormulas=false [ true | false ] Add formulas from the input strings to the chart captions; the formula is always used for the chart caption whenever the caption is not supplied in the input string and the time series does not have a non-empty comment (or CaptionFromComment=false ). ShowTransform=false [ true | false ] Add the Transform function to the chart captions. Customize figure windows Tiles=@auto [ numeric | @auto ] Number of rows and columns of tiles within one figure window. Tiles=@auto means the layout will be determined automatically based on the total number of charts, respecting also the option MaxTilesPerWindow . MaxTilesPerWindow=40 [ numeric ] Maximum number of tiles (charts) in each figure window. ShowFigure=Inf [ numeric ] After drawing all figures, switch to this one to be shown on top; ShowFigure=Inf means the last figure window plotted. Customize graphics objects FigureSettings={} [ cell ] Cell array of settings passed to the standard Matlab figure constructor. AxesSettings={} [ cell ] Cell array of settings passed to the standard Matlab axes constructor. PlotSettings={} [ cell ] Cell array of settings passed to the plot functions as extra input arguments at the end. TitleSettings={} [ cell ] Cell array of settings passed to the title constructor as extra input arguments at the end.","title":"databank.Chartpack"},{"location":"Reporting/databank.Chartpack/Chartpack.html#databankchartpack","text":"Create a new Chartpack object for plotting databank fields","title":"databank.Chartpack"},{"location":"Reporting/databank.Chartpack/Chartpack.html#syntax","text":"ch = databank.Chartpack()","title":"Syntax"},{"location":"Reporting/databank.Chartpack/Chartpack.html#output-arguments","text":"ch [ databank.Chartpack ] New empty databank.Chartpack object","title":"Output Arguments"},{"location":"Reporting/databank.Chartpack/Chartpack.html#customizable-properties","text":"After creating a new Chartpack object, set the following properties to customize the way the charts are produced and styled:","title":"Customizable properties"},{"location":"Reporting/databank.Chartpack/Chartpack.html#customize-visual-aspects-of-individual-charts","text":"PlotFunc=@plot [ @plot ] Plot function used to create each of the charts. Highlight=[] [ Dater | cell | empty ] Date range, or a cell array of date ranges, that will be highlighted in each chart.","title":"Customize visual aspects of individual charts"},{"location":"Reporting/databank.Chartpack/Chartpack.html#customize-data-plotted","text":"Range=Inf [ Dater | Inf ] Date range or horizontal axis range on which the charts will be created. Range=Inf means each chart will encompass the range necessary to accommodate the entire time series plotted. Round=Inf [ numeric ] Round the data to this number of decimal places before plotting them. Transform=[] [ function | empty ] Function that will be applied to each data input before it gets plotted, except input data entered with a \"^\" at the beginning of their expression string.","title":"Customize data plotted"},{"location":"Reporting/databank.Chartpack/Chartpack.html#customize-chart-captions","text":"CaptionFromComment=false [ true | false ] If chart caption is missing, use the time series comments to create the captions. Newline=\"//\" [ string ] Separator between lines in the captions of the charts. ShowFormulas=false [ true | false ] Add formulas from the input strings to the chart captions; the formula is always used for the chart caption whenever the caption is not supplied in the input string and the time series does not have a non-empty comment (or CaptionFromComment=false ). ShowTransform=false [ true | false ] Add the Transform function to the chart captions.","title":"Customize chart captions"},{"location":"Reporting/databank.Chartpack/Chartpack.html#customize-figure-windows","text":"Tiles=@auto [ numeric | @auto ] Number of rows and columns of tiles within one figure window. Tiles=@auto means the layout will be determined automatically based on the total number of charts, respecting also the option MaxTilesPerWindow . MaxTilesPerWindow=40 [ numeric ] Maximum number of tiles (charts) in each figure window. ShowFigure=Inf [ numeric ] After drawing all figures, switch to this one to be shown on top; ShowFigure=Inf means the last figure window plotted.","title":"Customize figure windows"},{"location":"Reporting/databank.Chartpack/Chartpack.html#customize-graphics-objects","text":"FigureSettings={} [ cell ] Cell array of settings passed to the standard Matlab figure constructor. AxesSettings={} [ cell ] Cell array of settings passed to the standard Matlab axes constructor. PlotSettings={} [ cell ] Cell array of settings passed to the plot functions as extra input arguments at the end. TitleSettings={} [ cell ] Cell array of settings passed to the title constructor as extra input arguments at the end.","title":"Customize graphics objects"},{"location":"Reporting/databank.Chartpack/add.html","text":"add Add new chart to a databank.Chartpack object Syntax add(ch, inputString, ...) ch < inputString ch < [inputString, inputString, inputString] Input arguments inputString [ string ] String, or an array of strings, specifying the expression to be plotted in a new chart, optionally with a caption preceding the expression and separated by a colon. Output arguments No output arguments are needed because the databank.Chartpack object ch is a handle object, and updating handle objects does not require capturing them as output arguments. Options ApplyTransform=true [ true | false ] Apply the function specified in the option Transform to the data in this chart; ApplyTransform=false can be also achieved by using a hat sign ^ at the beginning of the expression in the inputString . Expansion=@parent [ cell | empty | @parent ] Replace a substring in the expression with a mutliple strings, creating multiple expression to be plotted in the same chart; overrides the property Expansion defined at the level of the databank.Chartpack object. Transform=@parent [ function | empty | @parent ] Function that will be applied to this data input before it gets plotted; overrides the property Transform defined at the level of the databank.Chartpack object.","title":"add"},{"location":"Reporting/databank.Chartpack/add.html#add","text":"Add new chart to a databank.Chartpack object","title":"add"},{"location":"Reporting/databank.Chartpack/add.html#syntax","text":"add(ch, inputString, ...) ch < inputString ch < [inputString, inputString, inputString]","title":"Syntax"},{"location":"Reporting/databank.Chartpack/add.html#input-arguments","text":"inputString [ string ] String, or an array of strings, specifying the expression to be plotted in a new chart, optionally with a caption preceding the expression and separated by a colon.","title":"Input arguments"},{"location":"Reporting/databank.Chartpack/add.html#output-arguments","text":"No output arguments are needed because the databank.Chartpack object ch is a handle object, and updating handle objects does not require capturing them as output arguments.","title":"Output arguments"},{"location":"Reporting/databank.Chartpack/add.html#options","text":"ApplyTransform=true [ true | false ] Apply the function specified in the option Transform to the data in this chart; ApplyTransform=false can be also achieved by using a hat sign ^ at the beginning of the expression in the inputString . Expansion=@parent [ cell | empty | @parent ] Replace a substring in the expression with a mutliple strings, creating multiple expression to be plotted in the same chart; overrides the property Expansion defined at the level of the databank.Chartpack object. Transform=@parent [ function | empty | @parent ] Function that will be applied to this data input before it gets plotted; overrides the property Transform defined at the level of the databank.Chartpack object.","title":"Options"},{"location":"Reporting/databank.Chartpack/clear.html","text":"clear Clear all charts from the chartpack Syntax clear(ch) Input arguments ch [ Chartpack ] Chartpack object from which all existing charts will be cleared; all settings assigned by the user will be preserved. Description The clear function is useful when you wish to reuse a Chartpack objects with particular settings for another set of charts. Examples","title":"clear"},{"location":"Reporting/databank.Chartpack/clear.html#clear","text":"Clear all charts from the chartpack","title":"clear"},{"location":"Reporting/databank.Chartpack/clear.html#syntax","text":"clear(ch)","title":"Syntax"},{"location":"Reporting/databank.Chartpack/clear.html#input-arguments","text":"ch [ Chartpack ] Chartpack object from which all existing charts will be cleared; all settings assigned by the user will be preserved.","title":"Input arguments"},{"location":"Reporting/databank.Chartpack/clear.html#description","text":"The clear function is useful when you wish to reuse a Chartpack objects with particular settings for another set of charts.","title":"Description"},{"location":"Reporting/databank.Chartpack/clear.html#examples","text":"","title":"Examples"},{"location":"Reporting/databank.Chartpack/draw.html","text":"draw Render charts defined in Chartpack Syntax info = draw(ch, inputDb) Input arguments ch [ Chartpack ] Chartpack object whose charts will be rendered on the screen. inputDb [ struct | Dictionary ] Input databank within which the expressions defining the charts will be evaluated, and the results plotted. Output arguments info [ struct ] Output information structure with the following fields: .FigureHandles - handles to all figure objects created; .AxesHandles - cell array of handles to all axes objects created, grouped by figures; .PlotHandles - cell array of cell arrays of handles to all objects plotted within axes, grouped by figures and by axes; .TitleHandles - cell array of handles to all title objects created, grouped by figures; .SubtitleHandles - cell array of handles to all subtitle objects created, grouped by figures; Description Examples","title":"draw"},{"location":"Reporting/databank.Chartpack/draw.html#draw","text":"Render charts defined in Chartpack","title":"draw"},{"location":"Reporting/databank.Chartpack/draw.html#syntax","text":"info = draw(ch, inputDb)","title":"Syntax"},{"location":"Reporting/databank.Chartpack/draw.html#input-arguments","text":"ch [ Chartpack ] Chartpack object whose charts will be rendered on the screen. inputDb [ struct | Dictionary ] Input databank within which the expressions defining the charts will be evaluated, and the results plotted.","title":"Input arguments"},{"location":"Reporting/databank.Chartpack/draw.html#output-arguments","text":"info [ struct ] Output information structure with the following fields: .FigureHandles - handles to all figure objects created; .AxesHandles - cell array of handles to all axes objects created, grouped by figures; .PlotHandles - cell array of cell arrays of handles to all objects plotted within axes, grouped by figures and by axes; .TitleHandles - cell array of handles to all title objects created, grouped by figures; .SubtitleHandles - cell array of handles to all subtitle objects created, grouped by figures;","title":"Output arguments"},{"location":"Reporting/databank.Chartpack/draw.html#description","text":"","title":"Description"},{"location":"Reporting/databank.Chartpack/draw.html#examples","text":"","title":"Examples"},{"location":"Reporting/rephrase/index.html","text":"Overview of the rephrase.js reporting package","title":"Overview of the `rephrase.js` reporting package"},{"location":"Reporting/rephrase/index.html#overview-of-the-rephrasejs-reporting-package","text":"","title":"Overview of the rephrase.js reporting package"},{"location":"Setup/index.html","text":"Setup and dependencies","title":"Setup and dependencies"},{"location":"Setup/index.html#setup-and-dependencies","text":"","title":"Setup and dependencies"},{"location":"StructuralModeling/index.html","text":"Overview of structural modeling tools","title":"Overview of structural modeling tools"},{"location":"StructuralModeling/index.html#overview-of-structural-modeling-tools","text":"","title":"Overview of structural modeling tools"},{"location":"StructuralModeling/Explanatory/index.html","text":"Overview of explanatory equation objects Categorical list of functions Constructing explanatory equation objects Function Description Getting information about explanatory equations Function Description collectResidualNames Collect names of LHS variables Estimating parameters Function Description regress.md Estimate parameters and residual models in Explanatory object","title":"Overview of explanatory equation objects"},{"location":"StructuralModeling/Explanatory/index.html#overview-of-explanatory-equation-objects","text":"","title":"Overview of explanatory equation objects"},{"location":"StructuralModeling/Explanatory/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"StructuralModeling/Explanatory/index.html#constructing-explanatory-equation-objects","text":"Function Description","title":"Constructing explanatory equation objects"},{"location":"StructuralModeling/Explanatory/index.html#getting-information-about-explanatory-equations","text":"Function Description collectResidualNames Collect names of LHS variables","title":"Getting information about explanatory equations"},{"location":"StructuralModeling/Explanatory/index.html#estimating-parameters","text":"Function Description regress.md Estimate parameters and residual models in Explanatory object","title":"Estimating parameters"},{"location":"StructuralModeling/Explanatory/collectResidualNames.html","text":"collectLhsNames Collect names of LHS variables Syntax residualNames = collectRhsNames(this) Input Arguments this [ Explanatory ] Explanatory object or array from which the names of all residuals will be collected and returned. Output Arguments residualNames [ string ] The names of all residuals collected from this Explanatory object or array. Description Examples x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); collectResidualNames ( x ) ans = 1x2 string array \"res_a\" \"res_b\" x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); x ( 1 ). ResidualNamePattern = [ \"shock_\" , \"_f2\" ]; collectResidualNames ( x ) ans = 1x2 string array \"shock_a_f2\" \"res_b\"","title":"collectLhsNames"},{"location":"StructuralModeling/Explanatory/collectResidualNames.html#collectlhsnames","text":"Collect names of LHS variables","title":"collectLhsNames"},{"location":"StructuralModeling/Explanatory/collectResidualNames.html#syntax","text":"residualNames = collectRhsNames(this)","title":"Syntax"},{"location":"StructuralModeling/Explanatory/collectResidualNames.html#input-arguments","text":"this [ Explanatory ] Explanatory object or array from which the names of all residuals will be collected and returned.","title":"Input Arguments"},{"location":"StructuralModeling/Explanatory/collectResidualNames.html#output-arguments","text":"residualNames [ string ] The names of all residuals collected from this Explanatory object or array.","title":"Output Arguments"},{"location":"StructuralModeling/Explanatory/collectResidualNames.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Explanatory/collectResidualNames.html#examples","text":"x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); collectResidualNames ( x ) ans = 1x2 string array \"res_a\" \"res_b\" x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); x ( 1 ). ResidualNamePattern = [ \"shock_\" , \"_f2\" ]; collectResidualNames ( x ) ans = 1x2 string array \"shock_a_f2\" \"res_b\"","title":"Examples"},{"location":"StructuralModeling/Explanatory/regress.html","text":"regress Estimate parameters and residual models in Explanatory object Syntax [expy, outputDb, info] = regress(expy, inputDb, fittedRange, ...) Input Arguments expy [ Explanatory ] Explanatory object or array whose parameters (associated with regression terms) will be estimated by running a single-equation linear regression; only those parameters that have the corresonding element in .Fixed set to NaN will be estimated.k inputDb [ struct | Dictionary ] Input databank from which the time series for each variable in the Explanatory object or array will be retrieved. fittedRange [ DateWrapper ] Date range on which the linear regression(s) will be fitted; this range does not include the pre-sample initial condition if there are lags in the Explanatory object or array. Output Arguments expy [ Explanatory ] Output Explanatory object or array with the parameters estimated. outputDb [ struct | Dictionary ] Output databank inclusive of the fitted values and residuals (whose names will be created using the .FittedNamePattern and .ResidualNamePattern . info [ struct ] Information structure with the following fields: .FittedRange - A K-by-N cell array with the dates of the fitted periods for each of the K equations and each of the N data pages or parameter variants. .ExitFlagsResidualModels - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the residual models; NaN means no residual model was estimated. .ExitFlagsParameters - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the parameters; NaN means the parameters were estimated by linear regression with no iterative procedure. Options AppendInput=false [ true | false ] Append post-sample data from the inputDb to the outputDb . __ MissingObservations=\"warning\" [ \"error\" | \"warning\" | \"silent\" ] Action taken when some within-sample observations are missing: \"error\" means an error message will be thrown; \"warning\" means these observations will be excluded from the estimation sample with a warning; \"silent\" means these observations will be excluded from the estimation sample silently. PrependInput=false [ true | false ] Prepend pre-sample data from the inputDb to the outputDb . Description Example Create an Explanatory object from a string inclusive of three regression terms, i.e. additive terms preceded by +@* or -@* : expy0 = Explanatory . fromString ( \"difflog(x) = @ + @*difflog(x{-1}) + @*log(z)\" ); expy0 . Parameters Assign some parameters to the three regression terms: expy0 . Parameters = [ 0.002 , 0.8 , 1 ]; Simulate the equation period by period, using random shocks (names 'res_x' by default) and random observations for z : rng ( 981 ); d0 = struct (); d0 . x = Series ( qq ( 2020 , 1 ), ones ( 40 , 1 )); d0 . z = Series ( qq ( 2020 , 1 ), exp ( randn ( 40 , 1 ) / 10 )); d0 . res_x = Series ( qq ( 2020 , 1 ), randn ( 40 , 1 ) / 50 ); d1 = simulate ( expy0 , d0 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); Estimate the parameters using the simulated data, and compare the parameter estimates and the estimated residuals with their \"true\" values: [ expy2 , d2 ] = regress ( expy0 , d1 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); [ expy0 . Parameters ; expy2 . Parameters ] plot ([ d0 . res_x , d2 . res_x ]);","title":"regress"},{"location":"StructuralModeling/Explanatory/regress.html#regress","text":"Estimate parameters and residual models in Explanatory object","title":"regress"},{"location":"StructuralModeling/Explanatory/regress.html#syntax","text":"[expy, outputDb, info] = regress(expy, inputDb, fittedRange, ...)","title":"Syntax"},{"location":"StructuralModeling/Explanatory/regress.html#input-arguments","text":"expy [ Explanatory ] Explanatory object or array whose parameters (associated with regression terms) will be estimated by running a single-equation linear regression; only those parameters that have the corresonding element in .Fixed set to NaN will be estimated.k inputDb [ struct | Dictionary ] Input databank from which the time series for each variable in the Explanatory object or array will be retrieved. fittedRange [ DateWrapper ] Date range on which the linear regression(s) will be fitted; this range does not include the pre-sample initial condition if there are lags in the Explanatory object or array.","title":"Input Arguments"},{"location":"StructuralModeling/Explanatory/regress.html#output-arguments","text":"expy [ Explanatory ] Output Explanatory object or array with the parameters estimated. outputDb [ struct | Dictionary ] Output databank inclusive of the fitted values and residuals (whose names will be created using the .FittedNamePattern and .ResidualNamePattern . info [ struct ] Information structure with the following fields: .FittedRange - A K-by-N cell array with the dates of the fitted periods for each of the K equations and each of the N data pages or parameter variants. .ExitFlagsResidualModels - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the residual models; NaN means no residual model was estimated. .ExitFlagsParameters - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the parameters; NaN means the parameters were estimated by linear regression with no iterative procedure.","title":"Output Arguments"},{"location":"StructuralModeling/Explanatory/regress.html#options","text":"AppendInput=false [ true | false ] Append post-sample data from the inputDb to the outputDb . __ MissingObservations=\"warning\" [ \"error\" | \"warning\" | \"silent\" ] Action taken when some within-sample observations are missing: \"error\" means an error message will be thrown; \"warning\" means these observations will be excluded from the estimation sample with a warning; \"silent\" means these observations will be excluded from the estimation sample silently. PrependInput=false [ true | false ] Prepend pre-sample data from the inputDb to the outputDb .","title":"Options"},{"location":"StructuralModeling/Explanatory/regress.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Explanatory/regress.html#example","text":"Create an Explanatory object from a string inclusive of three regression terms, i.e. additive terms preceded by +@* or -@* : expy0 = Explanatory . fromString ( \"difflog(x) = @ + @*difflog(x{-1}) + @*log(z)\" ); expy0 . Parameters Assign some parameters to the three regression terms: expy0 . Parameters = [ 0.002 , 0.8 , 1 ]; Simulate the equation period by period, using random shocks (names 'res_x' by default) and random observations for z : rng ( 981 ); d0 = struct (); d0 . x = Series ( qq ( 2020 , 1 ), ones ( 40 , 1 )); d0 . z = Series ( qq ( 2020 , 1 ), exp ( randn ( 40 , 1 ) / 10 )); d0 . res_x = Series ( qq ( 2020 , 1 ), randn ( 40 , 1 ) / 50 ); d1 = simulate ( expy0 , d0 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); Estimate the parameters using the simulated data, and compare the parameter estimates and the estimated residuals with their \"true\" values: [ expy2 , d2 ] = regress ( expy0 , d1 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); [ expy0 . Parameters ; expy2 . Parameters ] plot ([ d0 . res_x , d2 . res_x ]);","title":"Example"},{"location":"StructuralModeling/LinearSystem/index.html","text":"Overview of linear state-space system objects","title":"Overview of linear state-space system objects"},{"location":"StructuralModeling/LinearSystem/index.html#overview-of-linear-state-space-system-objects","text":"","title":"Overview of linear state-space system objects"},{"location":"StructuralModeling/Model/index.html","text":"Overview of structural model objects Categorical list of functions Constructing model objects Function Description Model.fromFile Create new Model object from model source file(s) Model.fromSnippet Create new Model object from snippet of code within m-file Model.fromString Create new Model object from string array Getting information about models Function Description analyticGradients Evaluate analytic/symbolic derivatives of model equations access Access properties of Model objects table Create table based on selected indicators from Model object solutionMatrices Access first-order state-space (solution) matrices Assigning values within models Function Description replaceNames Replace model names with some other names reset Reset specific values within model object rescaleStd Rescale all std deviations by the same factor Solving and simulating models Function Description checkSteady Check if equations hold for currently assigned steady-state values simulate Run a model simulation solve Calculate first-order solution matrices steady Compute steady state or balance-growth path of the model system System matrices for the unsolved model Estimating and filtering model quantities Function Description estimate.md Estimate model parameters by optimizing selected objective function kalmanFilter Kalman smoother and estimator of out-of-likelihood parameters","title":"Overview of structural model objects"},{"location":"StructuralModeling/Model/index.html#overview-of-structural-model-objects","text":"","title":"Overview of structural model objects"},{"location":"StructuralModeling/Model/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"StructuralModeling/Model/index.html#constructing-model-objects","text":"Function Description Model.fromFile Create new Model object from model source file(s) Model.fromSnippet Create new Model object from snippet of code within m-file Model.fromString Create new Model object from string array","title":"Constructing model objects"},{"location":"StructuralModeling/Model/index.html#getting-information-about-models","text":"Function Description analyticGradients Evaluate analytic/symbolic derivatives of model equations access Access properties of Model objects table Create table based on selected indicators from Model object solutionMatrices Access first-order state-space (solution) matrices","title":"Getting information about models"},{"location":"StructuralModeling/Model/index.html#assigning-values-within-models","text":"Function Description replaceNames Replace model names with some other names reset Reset specific values within model object rescaleStd Rescale all std deviations by the same factor","title":"Assigning values within models"},{"location":"StructuralModeling/Model/index.html#solving-and-simulating-models","text":"Function Description checkSteady Check if equations hold for currently assigned steady-state values simulate Run a model simulation solve Calculate first-order solution matrices steady Compute steady state or balance-growth path of the model system System matrices for the unsolved model","title":"Solving and simulating models"},{"location":"StructuralModeling/Model/index.html#estimating-and-filtering-model-quantities","text":"Function Description estimate.md Estimate model parameters by optimizing selected objective function kalmanFilter Kalman smoother and estimator of out-of-likelihood parameters","title":"Estimating and filtering model quantities"},{"location":"StructuralModeling/Model/access.html","text":"access Access properties of Model objects Syntax output = access(model, what) Input arguments model [ Model ] Model objects that will be queried about what . what [ string ] One of the valid queries into the model object properties listed below. Output arguments output [ * ] Response to the query about what . Valid queries \"transition-variables\" \"transition-shocks\" \"measurement-variables\" \"measurement-shocks\" \"parameters\" \"exogenous-variables\" Return a string array of all the names of the respective type in order of their apperance in the declaration sections of the source model file(s). fileName Returns a string, or an array of strings, with the name(s) of model source files on which this model objects is based. preprocessor , postprocessor Returns an array of Explanatory objects with the equations defined in thea !preprocessor or !postprocessor section of the model source. Description Example","title":"access"},{"location":"StructuralModeling/Model/access.html#access","text":"Access properties of Model objects","title":"access"},{"location":"StructuralModeling/Model/access.html#syntax","text":"output = access(model, what)","title":"Syntax"},{"location":"StructuralModeling/Model/access.html#input-arguments","text":"model [ Model ] Model objects that will be queried about what . what [ string ] One of the valid queries into the model object properties listed below.","title":"Input arguments"},{"location":"StructuralModeling/Model/access.html#output-arguments","text":"output [ * ] Response to the query about what .","title":"Output arguments"},{"location":"StructuralModeling/Model/access.html#valid-queries","text":"\"transition-variables\" \"transition-shocks\" \"measurement-variables\" \"measurement-shocks\" \"parameters\" \"exogenous-variables\" Return a string array of all the names of the respective type in order of their apperance in the declaration sections of the source model file(s). fileName Returns a string, or an array of strings, with the name(s) of model source files on which this model objects is based. preprocessor , postprocessor Returns an array of Explanatory objects with the equations defined in thea !preprocessor or !postprocessor section of the model source.","title":"Valid queries"},{"location":"StructuralModeling/Model/access.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Model/access.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Model/analyticGradients.html","text":"analyticGradients Evaluate analytic/symbolic derivatives of model equations Syntax [dynamic, steady] = analyticGradients(model) Input arguments model [ Model ] Model object whose equations will be analytically/symbolically differentiated w.r.t to the model variables present in the respective equation. Output arguments dynamic [ cell ] A cell array with the derivatives of the dynamic versions of the model equations w.r.t. the variables present in each respective equation See Description for details. steady [ cell ] A cell array with the derivatives of the steady versions of the model equations (if provided by the user) w.r.t. the variables present in each respective equation See Description for details. Description Each of the dynamic and steady output arguments is a 2-by-N cell array, where N is the number of equations in the model (counting also measurement trends and dynamic links); the {1, i} element is a 1-by-K array of strings with the analytic/symbolic derivatives of the i-th equation w.r.t. a total of K variables (including their lags and leads) that are present in the respective equation. The list of the K variables in then in the {2, i} element. If an equation does not have a steady-state version, the corresponding elements of the steady cell array are returned empty. Examples","title":"analyticGradients"},{"location":"StructuralModeling/Model/analyticGradients.html#analyticgradients","text":"Evaluate analytic/symbolic derivatives of model equations","title":"analyticGradients"},{"location":"StructuralModeling/Model/analyticGradients.html#syntax","text":"[dynamic, steady] = analyticGradients(model)","title":"Syntax"},{"location":"StructuralModeling/Model/analyticGradients.html#input-arguments","text":"model [ Model ] Model object whose equations will be analytically/symbolically differentiated w.r.t to the model variables present in the respective equation.","title":"Input arguments"},{"location":"StructuralModeling/Model/analyticGradients.html#output-arguments","text":"dynamic [ cell ] A cell array with the derivatives of the dynamic versions of the model equations w.r.t. the variables present in each respective equation See Description for details. steady [ cell ] A cell array with the derivatives of the steady versions of the model equations (if provided by the user) w.r.t. the variables present in each respective equation See Description for details.","title":"Output arguments"},{"location":"StructuralModeling/Model/analyticGradients.html#description","text":"Each of the dynamic and steady output arguments is a 2-by-N cell array, where N is the number of equations in the model (counting also measurement trends and dynamic links); the {1, i} element is a 1-by-K array of strings with the analytic/symbolic derivatives of the i-th equation w.r.t. a total of K variables (including their lags and leads) that are present in the respective equation. The list of the K variables in then in the {2, i} element. If an equation does not have a steady-state version, the corresponding elements of the steady cell array are returned empty.","title":"Description"},{"location":"StructuralModeling/Model/analyticGradients.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Model/checkSteady.html","text":"checkSteady Check if equations hold for currently assigned steady-state values","title":"checkSteady"},{"location":"StructuralModeling/Model/checkSteady.html#checksteady","text":"Check if equations hold for currently assigned steady-state values","title":"checkSteady"},{"location":"StructuralModeling/Model/estimate.html","text":"estimate Estimate model parameters by optimizing selected objective function Syntax Input arguments marked with a ~ sign may be omitted. [Summary, Poster, Table, Hess, MEst, V, Delta, PDelta] ... = estimate(M, D, Range, EstimSpec, ~SystemPriors, ...) Input arguments M [ model ] - Model object with single parameterization. D [ struct | cell ] - Input database or datapack from which the measurement variables will be taken. Range [ struct | char ] - Date range on which the data likelihood will be evaluated. EstimSpec [ struct ] - Struct with the list of paremeters that will be estimated, and the parameter prior specifications (see below). ~SystemPriors [ systempriors | empty ] - System priors object, systempriors ; may be omitted. Output arguments Summary [ table ] - Table with summary information. Poster [ poster ] - Posterior, poster , object; this object also gives you access to the value of the objective function at optimum or at any point in the parameter space, see the poster/eval function. Table [ numeric ] - Summary table with a starting value, point estimate, std error estimate, and lower and upper bounds for each parameter. Hess [ cell ] - Hess{1} is the total hessian of the objective function; Hess{2} is the contributions of the priors to the hessian. MEst [ model ] - Model object solved with the estimated parameters (including out-of-likelihood parameters and common variance factor). The remaining three output arguments, V , delta , PDelta , are the same as the model/loglik output arguments of the same names. Options CheckSteady=false [ true | false | cell ] - Check steady state in each iteration; works only in non-linear models. EvalLikelihood=true [ true | false ] - In each iteration, evaluate likelihood (or another data based criterion), and include it to the overall objective function to be optimised. EvalParameterPriors=true [ true | false ] - In each iteration, evaluate parameter prior density, and include it to the overall objective function to be optimised. EvalSystemPriors=true [ true | false ] - In each iteration, evaluate system prior density, and include it to the overall objective function to be optimised. Filter={ } [ cell ] - Cell array of options that will be passed on to the Kalman filter including the type of objective function; see help on model/filter for the options available. InitVal='struct' [ 'Model' | 'Struct' | struct ] - If Struct use the values in the input struct est to start the iteration; if Model use the currently assigned parameter values in the input model, m . MaxIter=500 [ numeric ] - Maximum number of iterations allowed. MaxFunEvals=2000 [ numeric ] - Maximum number of objective function calls allowed. NoSolution='Error' [ 'Error' | 'Penalty' | numeric ] - Specifies what happens if solution or steady state fails to solve in an iteration: NoSolution='Error' stops the execution with an error message, NoSolution='Penalty' returns an extreme value, 1e10 , back to the minimization routine; or a user-supplied penalty can be specified as a numeric scalar greater than 1e10 . OptimSet={ } [ cell ] - Cell array used to create the Optimization Toolbox options structure; works only with the option Solver='Default' . Summary='Table' [ 'Table' | 'Struct' ] - Format of the Summary output argument. Solve=true [ true | false | cellstr ] - Re-compute solution in each iteration; you can specify a cell array with options for the solve function. Solver='Default' [ 'Default' | cell | function_handle ] - Minimization procedure. 'Default' : The Optimization Toolbox function fminunc or fmincon will be called depending on the presence or absence of lower and/or upper bounds. function_handle or cell: Enter a function handle to your own optimization procedure, or a cell array with a function handle and additional input arguments (see below). SState=false [ true | false | cell | function_handle ] - Re-compute steady state in each iteration; you can specify a cell array with options for the sstate( ) function, or a function handle whose behaviour is described below. TolFun=1e-6 [ numeric ] - Termination tolerance on the objective function. TolX=1e-6 [ numeric ] - Termination tolerance on the estimated parameters. Description The parameters that are to be estimated are specified in the input parameter estimation database, E in which you can provide the following specifications for each parameter: E.parameter_name = { start, lower, upper, logpriorFunc }; where start is the value from which the numerical optimization will start, lower is the lower bound, upper is the upper bound, and logpriorFunc is a function handle expected to return the log of the prior density. You can use the logdist package to create function handles for some of the basic prior distributions. You can use NaN for start if you wish to use the value currently assigned in the model object. You can use -Inf and Inf for the bounds, or leave the bounds empty or not specify them at all. You can leave the prior distribution empty or not specify it at all. Estimating Nonlinear Models By default, only the first-order solution, but not the steady state is updated (recomputed) in each iteration before the likelihood is evaluated. This behavior is controled by two options, Solve= ( true by default) and Sstate= ( false by default). If some of the estimated parameters do affect the steady state of the model, the option Sstate= needs to be set to true or to a cell array with steady-state options, as in the function sstate , otherwise the results will be groslly inaccurate or a valid first-order solution will be impossible to find. When steady state is recomputed in each iteration, you may also want to use the option Chksstate= to require that a steady-state check for all model equations be performed. User-supplied Optimization (Minimization) Routine You can supply a function handle to your own minimization routine through the option Solver= . This routine will be used instead of the Optim Tbx's fminunc or fmincon functions. The user-supplied function is expected to take at least five input arguments and return three output arguments: [pEst, ObjEst, Hess] = yourminfunc(F, P0, PLow, PHigh, OptimSet) with the following input arguments: F is a function handle to the function minimised; P0 is a 1-by-N vector of initial parameter values; PLow is a 1-by-N vector of lower bounds (with -Inf indicating no lower bound); PHigh is a 1-by-N vector of upper bounds (with Inf indicating no upper bounds); OptimSet is a cell array with name-value pairs entered by the user through the option 'OptimSet=' . This option can be used to modify various settings related to the optimization routine, such as tolerance, number of iterations, etc. Of course, you may simply ignore it and leave this input argument unused; and the following output arguments: pEst is a 1-by-N vector of estimated parameters; ObjEst is the value of the objective function at optimum; Hess is a N-by-N approximate Hessian matrix at optimum. If you need to use extra input arguments in your minimization function, enter a cell array instead of a plain function handle: {@yourminfunc, Arg1, Arg2, ...} In that case, the solver will be called the following way: [pEst, ObjEst, Hess] = yourminfunc(F, P0, PLow, PHigh, Opt, Arg1, Arg2, ...) User-Supplied Steady-State Solver You can supply a function handle to your own steady-state solver (i.e. a function that finds the steady state for given parameters) through the Sstate= option. The function is expected to take one input argument, the model object with newly assigned parameters, and return at least two output arguments, the model object with a new steady state (or balanced-growth path) and a success flag. The flag is true if the steady state has been successfully computed, and false if not: [m, success] = mysstatesolver(m) It is your responsibility to add the growth characteristics if some of the model variables drift over time. In other words, you need to take care of the imaginary parts of the steady state values in the model object returned by the solver. Alternatively, you can also run the steady-state solver with extra input arguments (with the model object still being the first input argument). In that case, you need to set the option Sstate=' to a cell array with the function handle in the first cell, and the other input arguments afterwards, e.g. 'Sstate=', {@mysstatesolver, 1, 'a', x} The actual function call will have the following form: [m, success] = mysstatesolver(m, 1, 'a', x) Examples","title":"estimate"},{"location":"StructuralModeling/Model/estimate.html#estimate","text":"Estimate model parameters by optimizing selected objective function","title":"estimate"},{"location":"StructuralModeling/Model/estimate.html#syntax","text":"Input arguments marked with a ~ sign may be omitted. [Summary, Poster, Table, Hess, MEst, V, Delta, PDelta] ... = estimate(M, D, Range, EstimSpec, ~SystemPriors, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/estimate.html#input-arguments","text":"M [ model ] - Model object with single parameterization. D [ struct | cell ] - Input database or datapack from which the measurement variables will be taken. Range [ struct | char ] - Date range on which the data likelihood will be evaluated. EstimSpec [ struct ] - Struct with the list of paremeters that will be estimated, and the parameter prior specifications (see below). ~SystemPriors [ systempriors | empty ] - System priors object, systempriors ; may be omitted.","title":"Input arguments"},{"location":"StructuralModeling/Model/estimate.html#output-arguments","text":"Summary [ table ] - Table with summary information. Poster [ poster ] - Posterior, poster , object; this object also gives you access to the value of the objective function at optimum or at any point in the parameter space, see the poster/eval function. Table [ numeric ] - Summary table with a starting value, point estimate, std error estimate, and lower and upper bounds for each parameter. Hess [ cell ] - Hess{1} is the total hessian of the objective function; Hess{2} is the contributions of the priors to the hessian. MEst [ model ] - Model object solved with the estimated parameters (including out-of-likelihood parameters and common variance factor). The remaining three output arguments, V , delta , PDelta , are the same as the model/loglik output arguments of the same names.","title":"Output arguments"},{"location":"StructuralModeling/Model/estimate.html#options","text":"CheckSteady=false [ true | false | cell ] - Check steady state in each iteration; works only in non-linear models. EvalLikelihood=true [ true | false ] - In each iteration, evaluate likelihood (or another data based criterion), and include it to the overall objective function to be optimised. EvalParameterPriors=true [ true | false ] - In each iteration, evaluate parameter prior density, and include it to the overall objective function to be optimised. EvalSystemPriors=true [ true | false ] - In each iteration, evaluate system prior density, and include it to the overall objective function to be optimised. Filter={ } [ cell ] - Cell array of options that will be passed on to the Kalman filter including the type of objective function; see help on model/filter for the options available. InitVal='struct' [ 'Model' | 'Struct' | struct ] - If Struct use the values in the input struct est to start the iteration; if Model use the currently assigned parameter values in the input model, m . MaxIter=500 [ numeric ] - Maximum number of iterations allowed. MaxFunEvals=2000 [ numeric ] - Maximum number of objective function calls allowed. NoSolution='Error' [ 'Error' | 'Penalty' | numeric ] - Specifies what happens if solution or steady state fails to solve in an iteration: NoSolution='Error' stops the execution with an error message, NoSolution='Penalty' returns an extreme value, 1e10 , back to the minimization routine; or a user-supplied penalty can be specified as a numeric scalar greater than 1e10 . OptimSet={ } [ cell ] - Cell array used to create the Optimization Toolbox options structure; works only with the option Solver='Default' . Summary='Table' [ 'Table' | 'Struct' ] - Format of the Summary output argument. Solve=true [ true | false | cellstr ] - Re-compute solution in each iteration; you can specify a cell array with options for the solve function. Solver='Default' [ 'Default' | cell | function_handle ] - Minimization procedure. 'Default' : The Optimization Toolbox function fminunc or fmincon will be called depending on the presence or absence of lower and/or upper bounds. function_handle or cell: Enter a function handle to your own optimization procedure, or a cell array with a function handle and additional input arguments (see below). SState=false [ true | false | cell | function_handle ] - Re-compute steady state in each iteration; you can specify a cell array with options for the sstate( ) function, or a function handle whose behaviour is described below. TolFun=1e-6 [ numeric ] - Termination tolerance on the objective function. TolX=1e-6 [ numeric ] - Termination tolerance on the estimated parameters.","title":"Options"},{"location":"StructuralModeling/Model/estimate.html#description","text":"The parameters that are to be estimated are specified in the input parameter estimation database, E in which you can provide the following specifications for each parameter: E.parameter_name = { start, lower, upper, logpriorFunc }; where start is the value from which the numerical optimization will start, lower is the lower bound, upper is the upper bound, and logpriorFunc is a function handle expected to return the log of the prior density. You can use the logdist package to create function handles for some of the basic prior distributions. You can use NaN for start if you wish to use the value currently assigned in the model object. You can use -Inf and Inf for the bounds, or leave the bounds empty or not specify them at all. You can leave the prior distribution empty or not specify it at all. Estimating Nonlinear Models By default, only the first-order solution, but not the steady state is updated (recomputed) in each iteration before the likelihood is evaluated. This behavior is controled by two options, Solve= ( true by default) and Sstate= ( false by default). If some of the estimated parameters do affect the steady state of the model, the option Sstate= needs to be set to true or to a cell array with steady-state options, as in the function sstate , otherwise the results will be groslly inaccurate or a valid first-order solution will be impossible to find. When steady state is recomputed in each iteration, you may also want to use the option Chksstate= to require that a steady-state check for all model equations be performed. User-supplied Optimization (Minimization) Routine You can supply a function handle to your own minimization routine through the option Solver= . This routine will be used instead of the Optim Tbx's fminunc or fmincon functions. The user-supplied function is expected to take at least five input arguments and return three output arguments: [pEst, ObjEst, Hess] = yourminfunc(F, P0, PLow, PHigh, OptimSet) with the following input arguments: F is a function handle to the function minimised; P0 is a 1-by-N vector of initial parameter values; PLow is a 1-by-N vector of lower bounds (with -Inf indicating no lower bound); PHigh is a 1-by-N vector of upper bounds (with Inf indicating no upper bounds); OptimSet is a cell array with name-value pairs entered by the user through the option 'OptimSet=' . This option can be used to modify various settings related to the optimization routine, such as tolerance, number of iterations, etc. Of course, you may simply ignore it and leave this input argument unused; and the following output arguments: pEst is a 1-by-N vector of estimated parameters; ObjEst is the value of the objective function at optimum; Hess is a N-by-N approximate Hessian matrix at optimum. If you need to use extra input arguments in your minimization function, enter a cell array instead of a plain function handle: {@yourminfunc, Arg1, Arg2, ...} In that case, the solver will be called the following way: [pEst, ObjEst, Hess] = yourminfunc(F, P0, PLow, PHigh, Opt, Arg1, Arg2, ...) User-Supplied Steady-State Solver You can supply a function handle to your own steady-state solver (i.e. a function that finds the steady state for given parameters) through the Sstate= option. The function is expected to take one input argument, the model object with newly assigned parameters, and return at least two output arguments, the model object with a new steady state (or balanced-growth path) and a success flag. The flag is true if the steady state has been successfully computed, and false if not: [m, success] = mysstatesolver(m) It is your responsibility to add the growth characteristics if some of the model variables drift over time. In other words, you need to take care of the imaginary parts of the steady state values in the model object returned by the solver. Alternatively, you can also run the steady-state solver with extra input arguments (with the model object still being the first input argument). In that case, you need to set the option Sstate=' to a cell array with the function handle in the first cell, and the other input arguments afterwards, e.g. 'Sstate=', {@mysstatesolver, 1, 'a', x} The actual function call will have the following form: [m, success] = mysstatesolver(m, 1, 'a', x)","title":"Description"},{"location":"StructuralModeling/Model/estimate.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Model/fromFile.html","text":"Model.fromFile Create new Model object from model source file(s) Syntax m = Model.fromFile(fileName, ...) Input arguments fileName [ string ] Name(s) of model source file(s) that will be loaded, parsed, and converted to a new Model object. Output arguments m [ Model ] New Model object based on the input model source file or files listed in fileNames . General options Assign=struct( ) [ struct | empty ] Assign model parameters and/or steady states from this database at the time the model objects is being created. AutoDeclareParameters=false [ true | false ] If true , disregard any parameter declaration sections in the model file, and determine the list of parameters automatically as residual names found in equations but not declared. BaseYear=@config [ numeric | @config ] Base year for constructing deterministic time trends; @config means the base year will be read from iris configuration. Comment='' [ char ] Text comment attached to the model object. CheckSyntax=true [ true | false ] Perform syntax checks on model equations; setting CheckSyntax=false may help reduce load time for larger model objects (provided the model file is known to be free of syntax errors). Epsilon=eps^(1/4) [ numeric ] The minimum relative step size for numerical differentiation. Linear=false [ true | false ] Indicate linear models. MakeBkw=@auto [ @auto | @all | string ] Variables included in the list will be made part of the vector of backward-looking variables; @auto means the variables that do not have any lag in model equations will be put in the vector of forward-looking variables. AllowMultiple=false [ true | false ] Allow each variable, shock, or parameter name to be declared (and assigned) more than once in the model file. Optimal={ } [ cell ] Specify optimal policy options, see Optimal for policy options models below; only applicable when the keyword min is used in the model source file. OrderLinks=true [ true | false ] Reorder !links so that they can be executed sequentially. RemoveLeads=false [ true | false ] Remove all leads (aka forward-looking variables) from the state-space vector and keep included only current dates and lags; the leads are not a necessary part of the model solution and can dropped e.g. for memory efficiency reasons in larger model objects. SteadyOnly=false [ true | false ] Read in only the steady-state versions of equations (if available). Std=@auto [ numeric | @auto ] Default standard deviation for model shocks; @auto means 1 for linear models and log(1.01) for nonlinear models. UserData=[ ] [ ... ] Attach user data to the model object. Options for optimal policy models The following options for optimal policy models need to be nested within the 'Optimal=' option. MultiplierPrefix='Mu_' [ char ] Prefix used to create names for lagrange multipliers associated with the optimal policy problem; the prefix is followed by the equation number. Nonnegative=[] [ string ] List of variables constrained to be nonnegative. Type=\"discretion\" [ \"commitment\" | \"discretion\" ] Type of optimal policy; \"discretion\" means leads (expectations) are taken as given and not differentiated w.r.t. whereas \"commitment\" means both lags and leads are differentiated w.r.t. Description Loading a model file The Model.fromFile constructor can be used to read in a model source file named fileNames , and create a model object m based on these. If fileNames is an array of more than one file names then all these files get combined together in order of appearance. Examples Plain vanilla model constructor Read in a model source file named some.model , and declare the model as linear: m = Model . fromFile ( \"some.model\" , Linear = true ); Construct model object and immedidately assign parameters Read in a model source file named some.model , declare the model as linear, and assign some of the model parameters: m = Model . fromFile ( \"some.model\" , linear = true , assign = p ); Note that this is equivalent to m = Model . fromFile ( \"some.model\" , linear = true ); m = assign ( m , p ); unless some of the parameters passed in to the Model.fromFile constructor are needed to evaluate Matlab expressions inside the model source files, such as conditions in the !if or !switch expressions, or angle bracket expressions <...> .","title":"Model.fromFile"},{"location":"StructuralModeling/Model/fromFile.html#modelfromfile","text":"Create new Model object from model source file(s)","title":"Model.fromFile"},{"location":"StructuralModeling/Model/fromFile.html#syntax","text":"m = Model.fromFile(fileName, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/fromFile.html#input-arguments","text":"fileName [ string ] Name(s) of model source file(s) that will be loaded, parsed, and converted to a new Model object.","title":"Input arguments"},{"location":"StructuralModeling/Model/fromFile.html#output-arguments","text":"m [ Model ] New Model object based on the input model source file or files listed in fileNames .","title":"Output arguments"},{"location":"StructuralModeling/Model/fromFile.html#general-options","text":"Assign=struct( ) [ struct | empty ] Assign model parameters and/or steady states from this database at the time the model objects is being created. AutoDeclareParameters=false [ true | false ] If true , disregard any parameter declaration sections in the model file, and determine the list of parameters automatically as residual names found in equations but not declared. BaseYear=@config [ numeric | @config ] Base year for constructing deterministic time trends; @config means the base year will be read from iris configuration. Comment='' [ char ] Text comment attached to the model object. CheckSyntax=true [ true | false ] Perform syntax checks on model equations; setting CheckSyntax=false may help reduce load time for larger model objects (provided the model file is known to be free of syntax errors). Epsilon=eps^(1/4) [ numeric ] The minimum relative step size for numerical differentiation. Linear=false [ true | false ] Indicate linear models. MakeBkw=@auto [ @auto | @all | string ] Variables included in the list will be made part of the vector of backward-looking variables; @auto means the variables that do not have any lag in model equations will be put in the vector of forward-looking variables. AllowMultiple=false [ true | false ] Allow each variable, shock, or parameter name to be declared (and assigned) more than once in the model file. Optimal={ } [ cell ] Specify optimal policy options, see Optimal for policy options models below; only applicable when the keyword min is used in the model source file. OrderLinks=true [ true | false ] Reorder !links so that they can be executed sequentially. RemoveLeads=false [ true | false ] Remove all leads (aka forward-looking variables) from the state-space vector and keep included only current dates and lags; the leads are not a necessary part of the model solution and can dropped e.g. for memory efficiency reasons in larger model objects. SteadyOnly=false [ true | false ] Read in only the steady-state versions of equations (if available). Std=@auto [ numeric | @auto ] Default standard deviation for model shocks; @auto means 1 for linear models and log(1.01) for nonlinear models. UserData=[ ] [ ... ] Attach user data to the model object.","title":"General options"},{"location":"StructuralModeling/Model/fromFile.html#options-for-optimal-policy-models","text":"The following options for optimal policy models need to be nested within the 'Optimal=' option. MultiplierPrefix='Mu_' [ char ] Prefix used to create names for lagrange multipliers associated with the optimal policy problem; the prefix is followed by the equation number. Nonnegative=[] [ string ] List of variables constrained to be nonnegative. Type=\"discretion\" [ \"commitment\" | \"discretion\" ] Type of optimal policy; \"discretion\" means leads (expectations) are taken as given and not differentiated w.r.t. whereas \"commitment\" means both lags and leads are differentiated w.r.t.","title":"Options for optimal policy models"},{"location":"StructuralModeling/Model/fromFile.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Model/fromFile.html#loading-a-model-file","text":"The Model.fromFile constructor can be used to read in a model source file named fileNames , and create a model object m based on these. If fileNames is an array of more than one file names then all these files get combined together in order of appearance.","title":"Loading a model file"},{"location":"StructuralModeling/Model/fromFile.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Model/fromFile.html#plain-vanilla-model-constructor","text":"Read in a model source file named some.model , and declare the model as linear: m = Model . fromFile ( \"some.model\" , Linear = true );","title":"Plain vanilla model constructor"},{"location":"StructuralModeling/Model/fromFile.html#construct-model-object-and-immedidately-assign-parameters","text":"Read in a model source file named some.model , declare the model as linear, and assign some of the model parameters: m = Model . fromFile ( \"some.model\" , linear = true , assign = p ); Note that this is equivalent to m = Model . fromFile ( \"some.model\" , linear = true ); m = assign ( m , p ); unless some of the parameters passed in to the Model.fromFile constructor are needed to evaluate Matlab expressions inside the model source files, such as conditions in the !if or !switch expressions, or angle bracket expressions <...> .","title":"Construct model object and immedidately assign parameters"},{"location":"StructuralModeling/Model/fromSnippet.html","text":"Model.fromSnippet Create new Model object from snippet of code within m-file Syntax m = Model.fromSnippet(snippetName, ...) Input arguments snippetName [ string ] Name(s) of snippet(s) of code embedded in the same m-file as the call to this function. Output arguments m [ Model ] New Model object based on the snippet(s) of code. Options The options are the same as in Model.fromFile . Description The snippet of model source code is placed within the very m-file (script or function) from where the Model.fromSnippet is called. In that file, the snippet needs to be enclosed within Matlab block comment signs, and inside those, within a start and and end mark as follows: %{ snippetName>>> ... ... % Here goes the model source code ... <<<snippetName %} Note there is no space between the name of the snippet and the start and end markes, >>> and <<< , respectively. The snippet can be placed anywhere in the m-file, before or after the Model.fromSnippet function. Examples m = Model . fromSnippet ( \"example\" , Linear = true ); m . rho_x = 0.8 ; %{ example>>> !variables x !parameters rho_x !shocks eps_x !equations x = rho_x*x{-1} + eps_x; <<<example %} m = solve ( m ); m = steady ( m );","title":"Model.fromSnippet"},{"location":"StructuralModeling/Model/fromSnippet.html#modelfromsnippet","text":"Create new Model object from snippet of code within m-file","title":"Model.fromSnippet"},{"location":"StructuralModeling/Model/fromSnippet.html#syntax","text":"m = Model.fromSnippet(snippetName, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/fromSnippet.html#input-arguments","text":"snippetName [ string ] Name(s) of snippet(s) of code embedded in the same m-file as the call to this function.","title":"Input arguments"},{"location":"StructuralModeling/Model/fromSnippet.html#output-arguments","text":"m [ Model ] New Model object based on the snippet(s) of code.","title":"Output arguments"},{"location":"StructuralModeling/Model/fromSnippet.html#options","text":"The options are the same as in Model.fromFile .","title":"Options"},{"location":"StructuralModeling/Model/fromSnippet.html#description","text":"The snippet of model source code is placed within the very m-file (script or function) from where the Model.fromSnippet is called. In that file, the snippet needs to be enclosed within Matlab block comment signs, and inside those, within a start and and end mark as follows: %{ snippetName>>> ... ... % Here goes the model source code ... <<<snippetName %} Note there is no space between the name of the snippet and the start and end markes, >>> and <<< , respectively. The snippet can be placed anywhere in the m-file, before or after the Model.fromSnippet function.","title":"Description"},{"location":"StructuralModeling/Model/fromSnippet.html#examples","text":"m = Model . fromSnippet ( \"example\" , Linear = true ); m . rho_x = 0.8 ; %{ example>>> !variables x !parameters rho_x !shocks eps_x !equations x = rho_x*x{-1} + eps_x; <<<example %} m = solve ( m ); m = steady ( m );","title":"Examples"},{"location":"StructuralModeling/Model/fromString.html","text":"Model.fromString Create new Model object from string array Syntax m = Model.fromString(inputString, ...) Input arguments inputString [ string ] Input string array whose elements will be joined as lines of model source codemodel source code. Output arguments m [ Model ] New Model object based on the inputString . Options The options are the same as in Model.fromFile . Description Examples m = Model . fromString ([ \"!variables x\" \"!shocks eps\" \"!parameters rho\" \"!equations x = rho*x{-1} + eps;\" ], \"linear\" , true ); m = solve ( m ); m = steady ( m );","title":"Model.fromString"},{"location":"StructuralModeling/Model/fromString.html#modelfromstring","text":"Create new Model object from string array","title":"Model.fromString"},{"location":"StructuralModeling/Model/fromString.html#syntax","text":"m = Model.fromString(inputString, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/fromString.html#input-arguments","text":"inputString [ string ] Input string array whose elements will be joined as lines of model source codemodel source code.","title":"Input arguments"},{"location":"StructuralModeling/Model/fromString.html#output-arguments","text":"m [ Model ] New Model object based on the inputString .","title":"Output arguments"},{"location":"StructuralModeling/Model/fromString.html#options","text":"The options are the same as in Model.fromFile .","title":"Options"},{"location":"StructuralModeling/Model/fromString.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Model/fromString.html#examples","text":"m = Model . fromString ([ \"!variables x\" \"!shocks eps\" \"!parameters rho\" \"!equations x = rho*x{-1} + eps;\" ], \"linear\" , true ); m = solve ( m ); m = steady ( m );","title":"Examples"},{"location":"StructuralModeling/Model/kalmanFilter.html","text":"kalmanFilter Kalman smoother and estimator of out-of-likelihood parameters Syntax [outputDb, outputModel, info] = kalmanFilter(inputModel, inputData, filterRange, ...) Input arguments inputModel [ Model ] A solved Model object whose state-space representation will be used to run a linear Kalman filter on the inputData observations. inputData [ struct | Dictionary ] Input databank from which the observations for measurement variables on the filterRange will be taken. filterRange [ numeric | char ] The range on which the Kalman filter will be run. Output arguments outputDb [ struct | Dictionary ] Output databank (possibly a nested databank) with the requested data; the type of output data are requested through the option Output= . outputModel [ Model ] Model object with the std deviation of shocks updated (if Relative=true ) and/or the out-of-likelihood parameters updated (if OutOfLik= is non-empty). info [ struct ] Output information struct with the following fields: .V - Estimated variance scale factor if the Relative= options is true; otherwise V is 1. .Delta - Struct with the estimates of out-of-likelihood parameters. .PE - Databank with prediction errors for measurement variables. .SCov - Sample covariance matrix of smoothed shocks; the covariance matrix is computed using shock estimates in periods that are included in the option ObjRange= and, at the same time, contain at least one observation of measurement variables. .init - Initial conditions used in the Kalman filter; init{1} is the initial mean of the vector of transformed state variables, init{2} is the MSE matrix. Options to control output data returned \"FlattenOutput=true \" [ true | false ] Make the outputDb as flat as possible by removing nested levels if they are empty or squeezing them if they only contain one field. MatrixFormat=\"namedMatrix\" [ \"namedMatrix\" | \"numeric\" ] Format (class) output matrices included in the output info struct: \"namedMatrix\" - return NamedMatrix objects where the individual rows and columns have variable names attached \"numeric\" - return plain numeric arrays MeanOnly=false [ true | false ] Return the mean data (point estimates) only in the outputDb . OutputData=\"smooth\" [ string | \"predict\" | \"filter\" | \"smooth\" ] Choose which Kalman filter steps will be included in the outputDb : \"smooth\" - include data from the backward smoother (two-sided filtering) \"update\" - include data from the updating steep (one-sided filtering) \"predict\" - include data from the prediction step ReturnMedian=true [ true | false ] Return a databank with the median estimates of the model variables; the meians are calculated by delogarithmizing the log-variables; the medianss for other variables is identical to the means. This option only works when MeanOnly=false . ReturnBreakdown=false [ true | false ] Return contributions of prediction errors in measurement variables to the estimates of all variables and shocks. This option only works when MeanOnly=false . ReturnMse=true [ true | false ] Return MSE matrices for predetermined state variables; these can be used for settin up initial condition in subsequent call to another kalmanFilter() . This option only works when MeanOnly=false . ReturnStd=true [ true | false ] Return databank with std devs of model variables. This option only works when MeanOnly=false . Options to control the calculation within the Kalman filter Ahead=1 [ numeric ] Calculate predictions up to Ahead periods ahead. ChkFmse=false [ true | false ] Check the condition number of the forecast MSE matrix in each step of the Kalman filter, and return immediately if the matrix is ill-conditioned; see also the option FmseCondTol= . Condition={ } [ char | cellstr | empty ] List of conditioning measurement variables. Condition time t|t-1 prediction errors (that enter the likelihood function) on time t observations of these measurement variables. Deviation=false [ true | false ] Treat input and output data as deviations from balanced-growth path. Dtrends=@auto [ @auto | true | false ] Measurement data contain deterministic trends; @auto means DTrends= will be set consistently with Deviation= . FmseCondTol=eps( ) [ numeric ] Tolerance for the FMSE condition number test; not used unless ChkFmse=true . InitCond='Stochastic' [ 'fixed' | 'optimal' | 'stochastic' | struct ] The method or data that will be used initialise the Kalman filter; user-supplied initial condition must be a databank with the mean values (in which case the MSE of the initial condition will be set to zero) or a nested databank containing sub-databanks named .mean and .mse . InitUnit='FixedUnknown' [ 'ApproxDiffuse' | 'FixedUknown' ] Method of initializing unit root variables; see Description. LastSmooth=Inf [ numeric ] Last date up to which to smooth data backward from the end of the filterRange; Inf means the smoother will run on the entire filterRange. OutOfLik={ } [ cellstr | empty ] List of parameters in deterministic trends that will be estimated by concentrating them out of the likelihood function. ObjFunc='-LogLik' [ '-LogLik' | 'PredErr' ] Objective function computed; can be either minus the log likelihood function or weighted sum of prediction errors. ObjRange=Inf [ DateWrapper | Inf ] The objective function will be computed on the specified filterRange only; Inf means the entire filter filterRange. Relative=true [ true | false ] Std devs of shocks assigned in the model object will be treated as relative std devs, and a common variance scale factor will be estimated. Weighting=[ ] [ numeric | empty ] Weighting vector or matrix for prediction errors when ObjFunc='PredErr' ; empty means prediction errors are weighted equally. Options for time-varying std deviations, correlations and means of shocks Multiply=[ ] [ struct | empty ] Databank with time series of possibly time-varying multipliers for std deviations of shocks; the numbers supplied will be multiplied by the std deviations assigned in the model object to calculate the std deviations used in the filter. See Description. Override=[ ] [ struct | empty ] Databank with time series for possibly time-varying paths for std deviations, correlations coefficients, or medians of shocks; these paths will override the values assigned in the model object. See Description. Options for models with nonlinear equations simulated in prediction step Simulate=false [ false | cell ] Use the backend algorithms from the simulate function to run nonlinear simulation for each prediction step; specify options that will be passed into simulate when running a prediction step. Description Run a Kalman filter based on the inputModel The option Ahead= cannot be combined with one another, or with multiple data sets, or with multiple parameterisations. Initial Conditions in Time Domain By default (with InitCond='Stochastic' ), the Kalman filter starts from the model-implied asymptotic distribution. You can change this behaviour by setting the option InitCond= to one of the following four different values: 'Fixed' -- the filter starts from the model-implied asymptotic mean (steady state) but with no initial uncertainty. The initial condition is treated as a vector of fixed, non-stochastic, numbers. 'Optimal' -- the filter starts from a vector of fixed numbers that is estimated optimally (likelihood maximising). databank (i.e. struct with fields for individual model variables) -- a databank through which you supply the mean for all the required initial conditions, see help on model/get for how to view the list of required initial conditions. mean-mse struct (i.e. struct with fields .mean and .mse ) -- a struct through which you supply the mean and MSE for all the required initial conditions. Initialization of Unit Root (Nonstationary, Diffuse) Processes Two methods are available to initialize unit-root (nonstationary, diffuse) elements in the state vector. In either case, the Kalman filter works with a system where the state vector is transformed so that its transition matrix is upper diagonal, with unit roots concentrated in the top left corner. Fixed unknown quantities. This is the default method (for backward compatibility reasons), and corresponds to setting InitUnit='FixedUnknown' . The initial conditions for unit-root processes are treated as fixed unknown elements, and uses a Rosenberg (1973) algorithm to compute the optimal estimates of these. The algorithm is completely described in section 3.4.4. of Harvey (1990) \"Forecasting, Structural Time Series Models and the Kalman Filter\", Cambridge University Press. Approximate diffuse. The other method is used when InitUnit='ApproxDiffuse' . This alternative method treats the initial conditions for unit-root processes as a diffuse distribution (with infinitely large variances) approximating the true diffuse distribution by scaling up the appropriate elements of the initial covariance matrix (by a sufficiently large factor in proportion to the remaining parts of the matrix). This method is described e.g. in Harvey & Phillips (1979) \"Maximum Likelihood Estimation of Regression Models with Autoregressive- Moving Average Disturbances\" Biometrika 66(1). Contributions of measurement variables to estimates of all variables Use the option ReturnCont=true to request the decomposition of measurement variables, transition variables, and shocks into the contributions of each individual measurement variable. The resulting output databank will include one extra subdatabank called .cont . In the .cont subdatabank, each time series will have Ny columns where Ny is the number of measurement variables in the model. The k-th column will be the contribution of the observations on the k-th measurement variable. The contributions are additive for linearised variables, and multiplicative for log-linearised variables (log variables). The difference between the actual path for a particular variable and the sum of the contributions (or their product in the case of log varibles) is due to the effect of constant terms and deterministic trends. Time variation in std deviations, correlations and means of shocks The options Multiply= and Override= modify the std deviations, correlation coefficients or medians of shocks within the filter range, allowing them also to vary over time. Create a time series and specify observations for each std deviation, correlation coefficient, or median (mean) that you want to deviate from the values currently assigned in the model object. The time series supplied do not need to stretch over the entire filter range: in the periods not specified, the values currently assigned in the model object will be assumed. The option Override= simply overrides the std deviations, correlations or medians (means) of the shocks whenever specified. The option Mutliply= can be used to supply multipliers for std deviations. The numbers entered will be multiplied by the std deviations to obtain the final std deviations used in the filter. To alter the median (mean) of a shock, supply a time series named after the shock itself. To alter the std deviation of a shock, use the name of that std deviation, i.e. std_xxx where xxx is the name of the shock. To alter the correlation coefficient between two shocks, use the name of that correlation coefficient, i.e. corr_xxx__yyy where xxx and yyy are the names of the shocks (mind the double underscore between xxx and yyy ). Example","title":"kalmanFilter"},{"location":"StructuralModeling/Model/kalmanFilter.html#kalmanfilter","text":"Kalman smoother and estimator of out-of-likelihood parameters","title":"kalmanFilter"},{"location":"StructuralModeling/Model/kalmanFilter.html#syntax","text":"[outputDb, outputModel, info] = kalmanFilter(inputModel, inputData, filterRange, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/kalmanFilter.html#input-arguments","text":"inputModel [ Model ] A solved Model object whose state-space representation will be used to run a linear Kalman filter on the inputData observations. inputData [ struct | Dictionary ] Input databank from which the observations for measurement variables on the filterRange will be taken. filterRange [ numeric | char ] The range on which the Kalman filter will be run.","title":"Input arguments"},{"location":"StructuralModeling/Model/kalmanFilter.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank (possibly a nested databank) with the requested data; the type of output data are requested through the option Output= . outputModel [ Model ] Model object with the std deviation of shocks updated (if Relative=true ) and/or the out-of-likelihood parameters updated (if OutOfLik= is non-empty). info [ struct ] Output information struct with the following fields: .V - Estimated variance scale factor if the Relative= options is true; otherwise V is 1. .Delta - Struct with the estimates of out-of-likelihood parameters. .PE - Databank with prediction errors for measurement variables. .SCov - Sample covariance matrix of smoothed shocks; the covariance matrix is computed using shock estimates in periods that are included in the option ObjRange= and, at the same time, contain at least one observation of measurement variables. .init - Initial conditions used in the Kalman filter; init{1} is the initial mean of the vector of transformed state variables, init{2} is the MSE matrix.","title":"Output arguments"},{"location":"StructuralModeling/Model/kalmanFilter.html#options-to-control-output-data-returned","text":"\"FlattenOutput=true \" [ true | false ] Make the outputDb as flat as possible by removing nested levels if they are empty or squeezing them if they only contain one field. MatrixFormat=\"namedMatrix\" [ \"namedMatrix\" | \"numeric\" ] Format (class) output matrices included in the output info struct: \"namedMatrix\" - return NamedMatrix objects where the individual rows and columns have variable names attached \"numeric\" - return plain numeric arrays MeanOnly=false [ true | false ] Return the mean data (point estimates) only in the outputDb . OutputData=\"smooth\" [ string | \"predict\" | \"filter\" | \"smooth\" ] Choose which Kalman filter steps will be included in the outputDb : \"smooth\" - include data from the backward smoother (two-sided filtering) \"update\" - include data from the updating steep (one-sided filtering) \"predict\" - include data from the prediction step ReturnMedian=true [ true | false ] Return a databank with the median estimates of the model variables; the meians are calculated by delogarithmizing the log-variables; the medianss for other variables is identical to the means. This option only works when MeanOnly=false . ReturnBreakdown=false [ true | false ] Return contributions of prediction errors in measurement variables to the estimates of all variables and shocks. This option only works when MeanOnly=false . ReturnMse=true [ true | false ] Return MSE matrices for predetermined state variables; these can be used for settin up initial condition in subsequent call to another kalmanFilter() . This option only works when MeanOnly=false . ReturnStd=true [ true | false ] Return databank with std devs of model variables. This option only works when MeanOnly=false .","title":"Options to control output data returned"},{"location":"StructuralModeling/Model/kalmanFilter.html#options-to-control-the-calculation-within-the-kalman-filter","text":"Ahead=1 [ numeric ] Calculate predictions up to Ahead periods ahead. ChkFmse=false [ true | false ] Check the condition number of the forecast MSE matrix in each step of the Kalman filter, and return immediately if the matrix is ill-conditioned; see also the option FmseCondTol= . Condition={ } [ char | cellstr | empty ] List of conditioning measurement variables. Condition time t|t-1 prediction errors (that enter the likelihood function) on time t observations of these measurement variables. Deviation=false [ true | false ] Treat input and output data as deviations from balanced-growth path. Dtrends=@auto [ @auto | true | false ] Measurement data contain deterministic trends; @auto means DTrends= will be set consistently with Deviation= . FmseCondTol=eps( ) [ numeric ] Tolerance for the FMSE condition number test; not used unless ChkFmse=true . InitCond='Stochastic' [ 'fixed' | 'optimal' | 'stochastic' | struct ] The method or data that will be used initialise the Kalman filter; user-supplied initial condition must be a databank with the mean values (in which case the MSE of the initial condition will be set to zero) or a nested databank containing sub-databanks named .mean and .mse . InitUnit='FixedUnknown' [ 'ApproxDiffuse' | 'FixedUknown' ] Method of initializing unit root variables; see Description. LastSmooth=Inf [ numeric ] Last date up to which to smooth data backward from the end of the filterRange; Inf means the smoother will run on the entire filterRange. OutOfLik={ } [ cellstr | empty ] List of parameters in deterministic trends that will be estimated by concentrating them out of the likelihood function. ObjFunc='-LogLik' [ '-LogLik' | 'PredErr' ] Objective function computed; can be either minus the log likelihood function or weighted sum of prediction errors. ObjRange=Inf [ DateWrapper | Inf ] The objective function will be computed on the specified filterRange only; Inf means the entire filter filterRange. Relative=true [ true | false ] Std devs of shocks assigned in the model object will be treated as relative std devs, and a common variance scale factor will be estimated. Weighting=[ ] [ numeric | empty ] Weighting vector or matrix for prediction errors when ObjFunc='PredErr' ; empty means prediction errors are weighted equally.","title":"Options to control the calculation within the Kalman filter"},{"location":"StructuralModeling/Model/kalmanFilter.html#options-for-time-varying-std-deviations-correlations-and-means-of-shocks","text":"Multiply=[ ] [ struct | empty ] Databank with time series of possibly time-varying multipliers for std deviations of shocks; the numbers supplied will be multiplied by the std deviations assigned in the model object to calculate the std deviations used in the filter. See Description. Override=[ ] [ struct | empty ] Databank with time series for possibly time-varying paths for std deviations, correlations coefficients, or medians of shocks; these paths will override the values assigned in the model object. See Description.","title":"Options for time-varying std deviations, correlations and means of shocks"},{"location":"StructuralModeling/Model/kalmanFilter.html#options-for-models-with-nonlinear-equations-simulated-in-prediction-step","text":"Simulate=false [ false | cell ] Use the backend algorithms from the simulate function to run nonlinear simulation for each prediction step; specify options that will be passed into simulate when running a prediction step.","title":"Options for models with nonlinear equations simulated in prediction step"},{"location":"StructuralModeling/Model/kalmanFilter.html#description","text":"Run a Kalman filter based on the inputModel The option Ahead= cannot be combined with one another, or with multiple data sets, or with multiple parameterisations.","title":"Description"},{"location":"StructuralModeling/Model/kalmanFilter.html#initial-conditions-in-time-domain","text":"By default (with InitCond='Stochastic' ), the Kalman filter starts from the model-implied asymptotic distribution. You can change this behaviour by setting the option InitCond= to one of the following four different values: 'Fixed' -- the filter starts from the model-implied asymptotic mean (steady state) but with no initial uncertainty. The initial condition is treated as a vector of fixed, non-stochastic, numbers. 'Optimal' -- the filter starts from a vector of fixed numbers that is estimated optimally (likelihood maximising). databank (i.e. struct with fields for individual model variables) -- a databank through which you supply the mean for all the required initial conditions, see help on model/get for how to view the list of required initial conditions. mean-mse struct (i.e. struct with fields .mean and .mse ) -- a struct through which you supply the mean and MSE for all the required initial conditions.","title":"Initial Conditions in Time Domain"},{"location":"StructuralModeling/Model/kalmanFilter.html#initialization-of-unit-root-nonstationary-diffuse-processes","text":"Two methods are available to initialize unit-root (nonstationary, diffuse) elements in the state vector. In either case, the Kalman filter works with a system where the state vector is transformed so that its transition matrix is upper diagonal, with unit roots concentrated in the top left corner. Fixed unknown quantities. This is the default method (for backward compatibility reasons), and corresponds to setting InitUnit='FixedUnknown' . The initial conditions for unit-root processes are treated as fixed unknown elements, and uses a Rosenberg (1973) algorithm to compute the optimal estimates of these. The algorithm is completely described in section 3.4.4. of Harvey (1990) \"Forecasting, Structural Time Series Models and the Kalman Filter\", Cambridge University Press. Approximate diffuse. The other method is used when InitUnit='ApproxDiffuse' . This alternative method treats the initial conditions for unit-root processes as a diffuse distribution (with infinitely large variances) approximating the true diffuse distribution by scaling up the appropriate elements of the initial covariance matrix (by a sufficiently large factor in proportion to the remaining parts of the matrix). This method is described e.g. in Harvey & Phillips (1979) \"Maximum Likelihood Estimation of Regression Models with Autoregressive- Moving Average Disturbances\" Biometrika 66(1).","title":"Initialization of Unit Root (Nonstationary, Diffuse) Processes"},{"location":"StructuralModeling/Model/kalmanFilter.html#contributions-of-measurement-variables-to-estimates-of-all-variables","text":"Use the option ReturnCont=true to request the decomposition of measurement variables, transition variables, and shocks into the contributions of each individual measurement variable. The resulting output databank will include one extra subdatabank called .cont . In the .cont subdatabank, each time series will have Ny columns where Ny is the number of measurement variables in the model. The k-th column will be the contribution of the observations on the k-th measurement variable. The contributions are additive for linearised variables, and multiplicative for log-linearised variables (log variables). The difference between the actual path for a particular variable and the sum of the contributions (or their product in the case of log varibles) is due to the effect of constant terms and deterministic trends.","title":"Contributions of measurement variables to estimates of all variables"},{"location":"StructuralModeling/Model/kalmanFilter.html#time-variation-in-std-deviations-correlations-and-means-of-shocks","text":"The options Multiply= and Override= modify the std deviations, correlation coefficients or medians of shocks within the filter range, allowing them also to vary over time. Create a time series and specify observations for each std deviation, correlation coefficient, or median (mean) that you want to deviate from the values currently assigned in the model object. The time series supplied do not need to stretch over the entire filter range: in the periods not specified, the values currently assigned in the model object will be assumed. The option Override= simply overrides the std deviations, correlations or medians (means) of the shocks whenever specified. The option Mutliply= can be used to supply multipliers for std deviations. The numbers entered will be multiplied by the std deviations to obtain the final std deviations used in the filter. To alter the median (mean) of a shock, supply a time series named after the shock itself. To alter the std deviation of a shock, use the name of that std deviation, i.e. std_xxx where xxx is the name of the shock. To alter the correlation coefficient between two shocks, use the name of that correlation coefficient, i.e. corr_xxx__yyy where xxx and yyy are the names of the shocks (mind the double underscore between xxx and yyy ).","title":"Time variation in std deviations, correlations and means of shocks"},{"location":"StructuralModeling/Model/kalmanFilter.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Model/replaceNames.html","text":"replaceNames Replace model names with some other names Syntax model = replaceNames(model, oldNames, newNames) Input arguments model [ Model ] Model object in which some names (variables, shocks, parameters) will be replaced with new names. oldNames [ string ] List of existing model names that will be replace with newNames . newNames [ string ] List of new names that will replace the oldNames in the model . The lenght of the newNames list must be the same as oldNames . The new names must be such that the entire list of all the model names after replacement has all names unique. Output arguments model [ Model ] Model object with the newNames assigned. Description Use this function to rename some of the model names (variables, shocks, parameters). The replacement affects the names under which model quantities are being assigned, read in from input databanks, or written out to output databanks in functions like Model/simulate . The internal representation of the model variables, shocks and parameters in the model equations is independent of their names. Examples Run the same univariate model for multiple variables Create a model object from the following","title":"replaceNames"},{"location":"StructuralModeling/Model/replaceNames.html#replacenames","text":"Replace model names with some other names","title":"replaceNames"},{"location":"StructuralModeling/Model/replaceNames.html#syntax","text":"model = replaceNames(model, oldNames, newNames)","title":"Syntax"},{"location":"StructuralModeling/Model/replaceNames.html#input-arguments","text":"model [ Model ] Model object in which some names (variables, shocks, parameters) will be replaced with new names. oldNames [ string ] List of existing model names that will be replace with newNames . newNames [ string ] List of new names that will replace the oldNames in the model . The lenght of the newNames list must be the same as oldNames . The new names must be such that the entire list of all the model names after replacement has all names unique.","title":"Input arguments"},{"location":"StructuralModeling/Model/replaceNames.html#output-arguments","text":"model [ Model ] Model object with the newNames assigned.","title":"Output arguments"},{"location":"StructuralModeling/Model/replaceNames.html#description","text":"Use this function to rename some of the model names (variables, shocks, parameters). The replacement affects the names under which model quantities are being assigned, read in from input databanks, or written out to output databanks in functions like Model/simulate . The internal representation of the model variables, shocks and parameters in the model equations is independent of their names.","title":"Description"},{"location":"StructuralModeling/Model/replaceNames.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Model/replaceNames.html#run-the-same-univariate-model-for-multiple-variables","text":"Create a model object from the following","title":"Run the same univariate model for multiple variables"},{"location":"StructuralModeling/Model/rescaleStd.html","text":"rescaleStd Rescale all std deviations by the same factor Syntax model = rescaleStd(model, factor) Input arguments model [ Model ] Model object whose std deviations will be rescaled. factor [ numeric ] Factor by which all std deviations in the model object model will be rescaled. Output arguments model [ Model ] Model object with all of std deviations rescaled. Description Example","title":"rescaleStd"},{"location":"StructuralModeling/Model/rescaleStd.html#rescalestd","text":"Rescale all std deviations by the same factor","title":"rescaleStd"},{"location":"StructuralModeling/Model/rescaleStd.html#syntax","text":"model = rescaleStd(model, factor)","title":"Syntax"},{"location":"StructuralModeling/Model/rescaleStd.html#input-arguments","text":"model [ Model ] Model object whose std deviations will be rescaled. factor [ numeric ] Factor by which all std deviations in the model object model will be rescaled.","title":"Input arguments"},{"location":"StructuralModeling/Model/rescaleStd.html#output-arguments","text":"model [ Model ] Model object with all of std deviations rescaled.","title":"Output arguments"},{"location":"StructuralModeling/Model/rescaleStd.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Model/rescaleStd.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Model/reset.html","text":"reset Reset specific values within model object Syntax model = reset(model) model = reset(model, request) Input Arguments model [ Model ] Model object in which the requested type(s) of values will be reset. request [ \"corr\" | \"plainparameters\" | \"parameters\" | \"steady\" | \"std\" | \"stdcorr\" ] Type(s) of values that will be reset; if omitted, everything will be reset. Output Arguments model [ Model ] Model object with the requested values reset. Description \"corr\" - Reset all cross-correlation coefficients to 0 . \"plainParameters\" - Reset all plain parameters (not including std_ or corr_ ) to NaN . \"parameters\" - Reset all parameters to NaN . \"steady\" - Reset all steady state values to NaN . \"std\" - Reset all std deviations ( std_ ) to 1 (in linear models) or log(1.01) (in non-linear models). \"stdCorr\" - Equivalent to \"Std\" and \"Corr\" . Examples","title":"reset"},{"location":"StructuralModeling/Model/reset.html#reset","text":"Reset specific values within model object","title":"reset"},{"location":"StructuralModeling/Model/reset.html#syntax","text":"model = reset(model) model = reset(model, request)","title":"Syntax"},{"location":"StructuralModeling/Model/reset.html#input-arguments","text":"model [ Model ] Model object in which the requested type(s) of values will be reset. request [ \"corr\" | \"plainparameters\" | \"parameters\" | \"steady\" | \"std\" | \"stdcorr\" ] Type(s) of values that will be reset; if omitted, everything will be reset.","title":"Input Arguments"},{"location":"StructuralModeling/Model/reset.html#output-arguments","text":"model [ Model ] Model object with the requested values reset.","title":"Output Arguments"},{"location":"StructuralModeling/Model/reset.html#description","text":"\"corr\" - Reset all cross-correlation coefficients to 0 . \"plainParameters\" - Reset all plain parameters (not including std_ or corr_ ) to NaN . \"parameters\" - Reset all parameters to NaN . \"steady\" - Reset all steady state values to NaN . \"std\" - Reset all std deviations ( std_ ) to 1 (in linear models) or log(1.01) (in non-linear models). \"stdCorr\" - Equivalent to \"Std\" and \"Corr\" .","title":"Description"},{"location":"StructuralModeling/Model/reset.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Model/simulate.html","text":"simulate Run a model simulation Syntax [outputDb, outputInfo, frameDb] = simulate(model, inputDb, range, ___) Input arguments model [ Model ] Model object with a valid solution avalaible for each of its parameter variants. inputDb [ struct | Dictionary ] Input databank from which the following data will be retrieved: initial conditions for the lags of transition variables; use access(model, \"initials\") to get the list of the necessary initial conditions; shocks within the simulation range; if shocks are missing, the default zero value is used in the simulation; data points for the transition variables exogenized in the simulation Plan (entered optionally through the plan= option); initial paths for transition variables in nonlinear simulations ( method=\"stacked\" or method=\"period\" ) when the initial iteration is requested to be taken from the input data and not the default first-order simulation, startIterationsFrom=\"data\" . range [ DateWrapper | numeric ] Simulation range; the simulation range is always from the first date to the last date specified in the range . Output arguments outputDb [ struct | Dictionary ] Databank (struct or Dictionary) with the simulation results; if options prependInput= or appendInput= are not used, the time series in outputDb span the simulation range plus all necessary initial conditions for those variables that have lags in the model. outputInfo [ struct ] Info struct with details on the simulation; the outputInfo struct contains the following fields: .FrameColumns .FrameDates .BaseRange .ExtendedRange .Success .ExitFlags .DiscrepancyTables .ProgressBar frameDb [ cell ] Only returned nonempty when method=\"stacked\" : Nested cell arrays with databanks containing the simulation results of each individual frame; the frameDb{i}{j} element is the output databank from simulating the j-th frame in the i-th variant or data page. Options method=\"firstOrder\" [ \"firstOrder\" | \"stacked\" | \"period\" ] Simulation method: method=\"firstOrder\" - use a first-order approximate solution; method=\"stacked\" - solve the model numerically as a stacked-time system of nonlinear-equations using a quasi-Newton method. method=\"period\" - solve the model numerically as a system of nonlinear-equations period by period using a quasi-Newton method; in forward-looking models, the model-consistent expectations are replaced with the values found in the inputDb The nonlinear simulation methods also further use the solver= option to specify the settings for the nonlinear solver. deviation=false [ true | false ] If true, both the input data and the output data are (and are expected to be) in the form of deviations from steady state: for variables not declared as log-variables , the deviations from steady state are calculated as a plain difference: \\(x_t - \\bar x_t\\) for variables declared as log-variables , the deviations from steady state are calculated as a ratio: \\(x_t / \\bar x_t\\) . prependInput=false [ true | false ] If true , the data from inputDb preceding the simulation range will be included in the output time series returned in outputDb . appendInput=false [ true | false ] If true , the data from inputDb succeeding the simulation range will be included in the output time series returned in outputDb . solver=@auto [ @auto | string | cell ] The name of the numerical solver to use for solving nonlinear simulations ( method=\"stacked\" or method=\"period\" ), optionally also with solver settings; see Description. Description Numerical solver settings in nonlinear simulations When method=\"stacked\" or method=\"period\" , the model is solved as a nonlinear system of equations using an IrisT quasi-Newton solver. There are two basic varieties of the numerical solver in IrisT: a quasi-Newton, called \"iris-newton\" ; this is a traditional Newton algorithm with optional step size optimization; a quasi-Newton-steepest-descent, called \"iris-qnsd\" ; this solver combines the quasi-Newton step with a Cauchy (steepest descent) step and regularizes the Jacobian matrix in the process. For most simulations, the \"iris-newton\" (which is the default choice) is the appropriate choice; however, you can still modify some of the settings by specifying a cell array whose first element is the name of the solver ( \"newton\" or \"qnsd\" ) followed by any number of name-value pairs for the individual settings; for instance: outputDb = simulate ( ... model , inputDb , range ... , method = \"stacked\" ... , solver ={ \"iris-newton\" , \"maxIterations\" , 100 , \"functionTolerance\" , 1e-5 } ... ); See Numerical solver settings for the description of all settings. Example","title":"simulate"},{"location":"StructuralModeling/Model/simulate.html#simulate","text":"Run a model simulation","title":"simulate"},{"location":"StructuralModeling/Model/simulate.html#syntax","text":"[outputDb, outputInfo, frameDb] = simulate(model, inputDb, range, ___)","title":"Syntax"},{"location":"StructuralModeling/Model/simulate.html#input-arguments","text":"model [ Model ] Model object with a valid solution avalaible for each of its parameter variants. inputDb [ struct | Dictionary ] Input databank from which the following data will be retrieved: initial conditions for the lags of transition variables; use access(model, \"initials\") to get the list of the necessary initial conditions; shocks within the simulation range; if shocks are missing, the default zero value is used in the simulation; data points for the transition variables exogenized in the simulation Plan (entered optionally through the plan= option); initial paths for transition variables in nonlinear simulations ( method=\"stacked\" or method=\"period\" ) when the initial iteration is requested to be taken from the input data and not the default first-order simulation, startIterationsFrom=\"data\" . range [ DateWrapper | numeric ] Simulation range; the simulation range is always from the first date to the last date specified in the range .","title":"Input arguments"},{"location":"StructuralModeling/Model/simulate.html#output-arguments","text":"outputDb [ struct | Dictionary ] Databank (struct or Dictionary) with the simulation results; if options prependInput= or appendInput= are not used, the time series in outputDb span the simulation range plus all necessary initial conditions for those variables that have lags in the model. outputInfo [ struct ] Info struct with details on the simulation; the outputInfo struct contains the following fields: .FrameColumns .FrameDates .BaseRange .ExtendedRange .Success .ExitFlags .DiscrepancyTables .ProgressBar frameDb [ cell ] Only returned nonempty when method=\"stacked\" : Nested cell arrays with databanks containing the simulation results of each individual frame; the frameDb{i}{j} element is the output databank from simulating the j-th frame in the i-th variant or data page.","title":"Output arguments"},{"location":"StructuralModeling/Model/simulate.html#options","text":"method=\"firstOrder\" [ \"firstOrder\" | \"stacked\" | \"period\" ] Simulation method: method=\"firstOrder\" - use a first-order approximate solution; method=\"stacked\" - solve the model numerically as a stacked-time system of nonlinear-equations using a quasi-Newton method. method=\"period\" - solve the model numerically as a system of nonlinear-equations period by period using a quasi-Newton method; in forward-looking models, the model-consistent expectations are replaced with the values found in the inputDb The nonlinear simulation methods also further use the solver= option to specify the settings for the nonlinear solver. deviation=false [ true | false ] If true, both the input data and the output data are (and are expected to be) in the form of deviations from steady state: for variables not declared as log-variables , the deviations from steady state are calculated as a plain difference: \\(x_t - \\bar x_t\\) for variables declared as log-variables , the deviations from steady state are calculated as a ratio: \\(x_t / \\bar x_t\\) . prependInput=false [ true | false ] If true , the data from inputDb preceding the simulation range will be included in the output time series returned in outputDb . appendInput=false [ true | false ] If true , the data from inputDb succeeding the simulation range will be included in the output time series returned in outputDb . solver=@auto [ @auto | string | cell ] The name of the numerical solver to use for solving nonlinear simulations ( method=\"stacked\" or method=\"period\" ), optionally also with solver settings; see Description.","title":"Options"},{"location":"StructuralModeling/Model/simulate.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Model/simulate.html#numerical-solver-settings-in-nonlinear-simulations","text":"When method=\"stacked\" or method=\"period\" , the model is solved as a nonlinear system of equations using an IrisT quasi-Newton solver. There are two basic varieties of the numerical solver in IrisT: a quasi-Newton, called \"iris-newton\" ; this is a traditional Newton algorithm with optional step size optimization; a quasi-Newton-steepest-descent, called \"iris-qnsd\" ; this solver combines the quasi-Newton step with a Cauchy (steepest descent) step and regularizes the Jacobian matrix in the process. For most simulations, the \"iris-newton\" (which is the default choice) is the appropriate choice; however, you can still modify some of the settings by specifying a cell array whose first element is the name of the solver ( \"newton\" or \"qnsd\" ) followed by any number of name-value pairs for the individual settings; for instance: outputDb = simulate ( ... model , inputDb , range ... , method = \"stacked\" ... , solver ={ \"iris-newton\" , \"maxIterations\" , 100 , \"functionTolerance\" , 1e-5 } ... ); See Numerical solver settings for the description of all settings.","title":"Numerical solver settings in nonlinear simulations"},{"location":"StructuralModeling/Model/simulate.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Model/solutionMatrices.html","text":"solutionMatrices Access first-order state-space (solution) matrices Syntax output = solutionMatrices(model, ...) Input Arguments model [ Model ] Solved model object. Output Arguments T [ numeric ] Transition matrix. R [ numeric ] Matrix at the shock vector in transition equations. K [ numeric ] Constant vector in transition equations. Z [ numeric ] Matrix mapping transition variables to measurement variables. H [ numeric ] Matrix at the shock vector in measurement equations. D [ numeric ] Constant vector in measurement equations. U [ numeric ] Transformation matrix for predetermined variables. Omg [ numeric ] Covariance matrix of shocks. Options Triangular=true [ true | false ] - If true, the state-space form returned has the transition matrix T quasi triangular and the vector of predetermined variables transformed accordingly; this is the default form used in IRIS calculations. If false, the state-space system is based on the original vector of transition variables. Description The state-space representation has the following form: [xf;alpha] = T*alpha(-1) + K + R*e y = Z*alpha + D + H*e xb = U*alpha Cov[e] = Omg where xb is an nb-by-1 vector of predetermined (backward-looking) transition variables and their auxiliary lags, xf is an nf-by-1 vector of non-predetermined (forward-looking) variables and their auxiliary leads, alpha is a transformation of xb , e is an ne-by-1 vector of shocks, and y is an ny-by-1 vector of measurement variables. Furthermore, we denote the total number of transition variables, and their auxiliary lags and leads, nx = nb + nf. The transition matrix, T , is, in general, rectangular nx-by-nb. Furthremore, the transformed state vector alpha is chosen so that the lower nb-by-nb part of T is quasi upper triangular. You can use the get(m, 'xiVector') function to learn about the order of appearance of transition variables and their auxiliary lags and leads in the vectors xb and xf . The first nf names are the vector xf , the remaining nb names are the vector xb . Example","title":"solutionMatrices"},{"location":"StructuralModeling/Model/solutionMatrices.html#solutionmatrices","text":"Access first-order state-space (solution) matrices","title":"solutionMatrices"},{"location":"StructuralModeling/Model/solutionMatrices.html#syntax","text":"output = solutionMatrices(model, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/solutionMatrices.html#input-arguments","text":"model [ Model ] Solved model object.","title":"Input Arguments"},{"location":"StructuralModeling/Model/solutionMatrices.html#output-arguments","text":"T [ numeric ] Transition matrix. R [ numeric ] Matrix at the shock vector in transition equations. K [ numeric ] Constant vector in transition equations. Z [ numeric ] Matrix mapping transition variables to measurement variables. H [ numeric ] Matrix at the shock vector in measurement equations. D [ numeric ] Constant vector in measurement equations. U [ numeric ] Transformation matrix for predetermined variables. Omg [ numeric ] Covariance matrix of shocks.","title":"Output Arguments"},{"location":"StructuralModeling/Model/solutionMatrices.html#options","text":"Triangular=true [ true | false ] - If true, the state-space form returned has the transition matrix T quasi triangular and the vector of predetermined variables transformed accordingly; this is the default form used in IRIS calculations. If false, the state-space system is based on the original vector of transition variables.","title":"Options"},{"location":"StructuralModeling/Model/solutionMatrices.html#description","text":"The state-space representation has the following form: [xf;alpha] = T*alpha(-1) + K + R*e y = Z*alpha + D + H*e xb = U*alpha Cov[e] = Omg where xb is an nb-by-1 vector of predetermined (backward-looking) transition variables and their auxiliary lags, xf is an nf-by-1 vector of non-predetermined (forward-looking) variables and their auxiliary leads, alpha is a transformation of xb , e is an ne-by-1 vector of shocks, and y is an ny-by-1 vector of measurement variables. Furthermore, we denote the total number of transition variables, and their auxiliary lags and leads, nx = nb + nf. The transition matrix, T , is, in general, rectangular nx-by-nb. Furthremore, the transformed state vector alpha is chosen so that the lower nb-by-nb part of T is quasi upper triangular. You can use the get(m, 'xiVector') function to learn about the order of appearance of transition variables and their auxiliary lags and leads in the vectors xb and xf . The first nf names are the vector xf , the remaining nb names are the vector xb .","title":"Description"},{"location":"StructuralModeling/Model/solutionMatrices.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Model/solve.html","text":"solve Calculate first-order solution matrices Syntax m = solve(model, ...) Input arguments model [ Model ] Model object with all active parameters assigned; nonlinear models must also have the steady state values assigned for all variables. Output arguments model [ Model ] Model with a newly computed solution for each parameter variant. Options Expand=0 [ numeric | NaN ] Number of periods ahead up to which the model solution will be expanded; if NaN the matrices needed to support solution expansion are not calculated and stored at all and the model cannot be used later in simulations or forecasts with anticipated shocks or plans. Eqtn=@all [ @all | \"measurement\" | \"transition\" ] Update existing solution in the measurement block, or the transition block, or both. Error=false [ true | false ] Throw an error if no unique stable solution exists; if false , a warning message only will be displayed. PreferredSchur=\"schur\" [ \"schur\" | \"qz\" ] The preferred form of Schur decomposition for purely backward looking models; PreferredSchur=\"schur\" means plain Schur decomposition (faster), PreferredSchur=\"qz\" means generalized Schur decomposition (unnecessary for backward looking models but consistent with forward looking model solutions). Progress=false [ true | false ] Display progress bar in the command window. Select=true [ true | false ] Automatically detect which equations need to be re-differentiated based on parameter changes from the last time the system matrices were calculated. Warning=true [ true | false ] Display warnings produced by this function. Description The IrisT solver uses an ordered QZ (or generalised Schur) decomposition to integrate out future expectations. The QZ may (very rarely) fail for numerical reasons. IrisT includes two patches to handle the some of the QZ failures: a SEVN2 patch (Sum-of-EigenValues-Near-Two), and an E2C2S patch (Eigenvalues-Too-Close-To-Swap). The SEVN2 patch: The model contains two or more unit roots, and the QZ algorithm interprets some of them incorrectly as pairs of eigenvalues that sum up accurately to 2, but with one of them significantly below 1 and the other significantly above 1. IrisT replaces the entries on the diagonal of one of the QZ factor matrices with numbers that evaluate to two unit roots. The E2C2S patch: The re-ordering of thq QZ matrices fails with a warning \"Reordering failed because some eigenvalues are too close to swap.\" IrisT attempts to re-order the equations until QZ works. The number of attempts is limited to N-1 at most where N is the total number of equations. Example","title":"solve"},{"location":"StructuralModeling/Model/solve.html#solve","text":"Calculate first-order solution matrices","title":"solve"},{"location":"StructuralModeling/Model/solve.html#syntax","text":"m = solve(model, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/solve.html#input-arguments","text":"model [ Model ] Model object with all active parameters assigned; nonlinear models must also have the steady state values assigned for all variables.","title":"Input arguments"},{"location":"StructuralModeling/Model/solve.html#output-arguments","text":"model [ Model ] Model with a newly computed solution for each parameter variant.","title":"Output arguments"},{"location":"StructuralModeling/Model/solve.html#options","text":"Expand=0 [ numeric | NaN ] Number of periods ahead up to which the model solution will be expanded; if NaN the matrices needed to support solution expansion are not calculated and stored at all and the model cannot be used later in simulations or forecasts with anticipated shocks or plans. Eqtn=@all [ @all | \"measurement\" | \"transition\" ] Update existing solution in the measurement block, or the transition block, or both. Error=false [ true | false ] Throw an error if no unique stable solution exists; if false , a warning message only will be displayed. PreferredSchur=\"schur\" [ \"schur\" | \"qz\" ] The preferred form of Schur decomposition for purely backward looking models; PreferredSchur=\"schur\" means plain Schur decomposition (faster), PreferredSchur=\"qz\" means generalized Schur decomposition (unnecessary for backward looking models but consistent with forward looking model solutions). Progress=false [ true | false ] Display progress bar in the command window. Select=true [ true | false ] Automatically detect which equations need to be re-differentiated based on parameter changes from the last time the system matrices were calculated. Warning=true [ true | false ] Display warnings produced by this function.","title":"Options"},{"location":"StructuralModeling/Model/solve.html#description","text":"The IrisT solver uses an ordered QZ (or generalised Schur) decomposition to integrate out future expectations. The QZ may (very rarely) fail for numerical reasons. IrisT includes two patches to handle the some of the QZ failures: a SEVN2 patch (Sum-of-EigenValues-Near-Two), and an E2C2S patch (Eigenvalues-Too-Close-To-Swap). The SEVN2 patch: The model contains two or more unit roots, and the QZ algorithm interprets some of them incorrectly as pairs of eigenvalues that sum up accurately to 2, but with one of them significantly below 1 and the other significantly above 1. IrisT replaces the entries on the diagonal of one of the QZ factor matrices with numbers that evaluate to two unit roots. The E2C2S patch: The re-ordering of thq QZ matrices fails with a warning \"Reordering failed because some eigenvalues are too close to swap.\" IrisT attempts to re-order the equations until QZ works. The number of attempts is limited to N-1 at most where N is the total number of equations.","title":"Description"},{"location":"StructuralModeling/Model/solve.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Model/steady.html","text":"steady Compute steady state or balance-growth path of the model Syntax [model, success, info] = steady(model, ...) Input arguments model [ Model ] Model for which the steady state values of its variables will be calculated. Output arguments model [ Model ] Model with its newly calculated steady state values assigned. success [ logical ] A 1-by-n array of true or false where n is the number of parameter variants in the model ; each true indicates a successeful completion (convergence) of steady state calculations. info [ struct ] Output info structure with the following fields: .ExitFlags - a 1-by-n cell array of arrays of solver.ExitFlag objects; the {i}(j) element indicates the exit flag for the i-th parameter variant and j-th block of steady equations. .Blazer - contains a solver.blazer.Steady object used when calculating the steady state values for each parameter variant. Options Warning=true [ true | false ] Display IrisT warning messages produced by this function. Options for nonlinear models Blocks=true [ true | false ] - Rearrange steady-state equations in sequential blocks before computing steady state. Endogenize=[ ] [ @auto | cellstr | char | empty ] - List of parameters that will be endogenized when computing the steady state; the number of endogenized parameters must match the number of transtion variables exogenized in the Exogenize= option; the use of the keyword @auto is explained in Description. Exogenize= [ @auto | cellstr | char | empty ] - List of transition variables that will be exogenized when computing the steady state; the number of exogenized variables must match the number of parameters exogenized in the 'Exogenize=' option; the use of the keyword @auto is explained in Description. Fix=[ ] [ cellstr | Except | empty ] - List of variables whose steady state (both level and change) will not be computed and kept fixed to the currently assigned values; alternatively an Except wrapper object can be used to specify that all variables are to be fixed except those listed. FixGrowth=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state first difference (variables not declared as log) or the steady-state rates of change (variables declared as log) of each variables listed. FixLevel=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state level of each variable listed. Growth=[] [ true | false | empty ] If true , both the steady-state levels and steady-state changes (differences or growth rates, depending on the log status of the respective variable) will be computed; if false , only the levels will be computed assuming that either all model variables are stationary, have stochastic trend without deterministic drift, or that the correct steady-state changes are already assigned in the model object. LogMinus=empty [ cell | char | empty ] - List of log variables whose steady state will be restricted to negative values in this run of sstate(~) . Reuse=false [ true | false ] - Reuse the steady-state values calculated for one parameter variant to initialize the steady-state calculation for the next parameter variant. Solver=\"qnsd\" [ \"qnsd\" | \"newton\" | \"fsolve\" | \"lsqnonlin\" | cell ] Numerical nonlinear solver (optionally also specified including non-default settings) used in steady state calculations; see Description; the default solver, \"qnsd\", is an IrisT quasi-Newton steepest-descent based algorithm. Unlog=[ ] [ cell | char | empty ] - List of log variables that will be temporarily treated as non-log variables in this run of steady(~) , i.e. their steady-state levels will not be restricted to either positive or negative values. Options for linear models Solve=false [ true | false ] Calculate first-order solution before steady state. Description Option Growth= The option Growth= is false by default which is consistent with one of the following situations: all model variables are either stationary or have stochastic trend but no deterministic trend (no deterministic trend: the simplest example is a plain vanilla random walk with no drift); the steady-state first differences (for variables not declared as log) and steady-state rates of growth (for variables declared as log) have been assigned (as imaginary parts) in the model object for all variables before running sstate(~)(~) . If some variables have an unknown deterministic trend (drift) in steady state (for instance, a balanced growth path model), sstate(~)(~) needs to be run with Growth=true . Lower and Upper Bounds Use options 'LevelWithin=' and 'ChangeWithin=' to impose lower and/or upper bounds on steady-state levels and/or growth rates of selected variables. Create a struct with a 1-by-2 vector [lower, upper] for each variable that is supposed to be bounded when the steady state is being calculated, and pass the struct into the respective option. User -Inf or Inf if only one of the bounds is specified. For instance, the following piece of code bnd = struct( ); bnd.X = [0, 10]; bnd.Y = [-Inf, 20]; bnd.Z = [5, Inf]; specifies lower bounds for variables X and Z , and upper bounds for variables X and Y . The variables that are not bounded do not need to be included in the struct. Using @auto in Options Exogenize= and Endogenize= The keyword @auto refers to !steady-autoswaps definitions and can be used in the options Exogenize= and Exogenize= in the following three possible combinations: Setting both Exogenize= and Endogenize= to @auto will exogenize all variables from !steady-autoswaps definitions and endogenize all corresponding parameters. Assigning the option Exogenize= an explicit list of variables while setting Endogenize= to @auto will exogenize only the listed variables while endogenizing the same number of the corresponding parameters from !steady-autoswaps definitions. The listed variables must each be found on the left-hand sides of a !steady-autoswaps definition. Setting Exogenize= to @auto while assigning the option Endogenize= an explicit list of parameters will exogenize only the variables that occur on the left-hand sides of those !steady-autoswaps definitions that have the listed parameters on their right-hand sides. The listed parameters must each be found on the right-hand side of a !steady-autoswaps definition. Options Fix=, FixLevel= and FixGrowth= Options Fix= , FixLevel= and FixGrowth= can be used for fixing the steady state of a subset of variables (their steady-state levels, changes, or both) to values supplied by the user before running sstate(~) . The fixed values need to be assigned to the respective variables directly in the model object, and obviously need to be the correct steady-state values. The variables are excluded from the list of unknowns when the steady-state equations are being solved. The list of variables assigned to the three options can be also defined inversely using a Except wrapper object, constructed by passing the list of variables that are not to be fixed. For instance, in sstate(m, 'FixGrowth=', Except('x', 'y')) the steady-state growth of all variables except x and y will be fixed (and needs to be supplied before calling this sstate(~) ). Example This example illustrates the use of the keyword @auto in exogenizing/endogenizing variabes/parameters. Assume that the underlying model file included the following sections: !variables W, X, Y, Z !parameters alpha, beta, gamma, delta !steady-autoswaps W := alpha; Y := beta; Z := delta; Running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', @auto) will calculate the steady state with all three variables from the !steady-autoswaps defintions, W , Y , and Z , exogenized to their currently assigned values while endogenizing the three corresponding parameters, alpha , beta , and delta . Running the following command m = sstate(m, 'Exogenize=', {'W', 'Z'}, 'Endogenize=', @auto) will calculate the steady state with the two listed variables, W and Z , exogenized and the corresponding parameters, alpha and delta , endogenized. Finally, running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', {'delta', 'beta'}) will calculate the steady state with two variables, Z and Y , (corresponding to the endogenized parameters listed) exogenized while endogenizing the listed parameters, alpha and delta . %","title":"steady"},{"location":"StructuralModeling/Model/steady.html#steady","text":"Compute steady state or balance-growth path of the model","title":"steady"},{"location":"StructuralModeling/Model/steady.html#syntax","text":"[model, success, info] = steady(model, ...)","title":"Syntax"},{"location":"StructuralModeling/Model/steady.html#input-arguments","text":"model [ Model ] Model for which the steady state values of its variables will be calculated.","title":"Input arguments"},{"location":"StructuralModeling/Model/steady.html#output-arguments","text":"model [ Model ] Model with its newly calculated steady state values assigned. success [ logical ] A 1-by-n array of true or false where n is the number of parameter variants in the model ; each true indicates a successeful completion (convergence) of steady state calculations. info [ struct ] Output info structure with the following fields: .ExitFlags - a 1-by-n cell array of arrays of solver.ExitFlag objects; the {i}(j) element indicates the exit flag for the i-th parameter variant and j-th block of steady equations. .Blazer - contains a solver.blazer.Steady object used when calculating the steady state values for each parameter variant.","title":"Output arguments"},{"location":"StructuralModeling/Model/steady.html#options","text":"Warning=true [ true | false ] Display IrisT warning messages produced by this function.","title":"Options"},{"location":"StructuralModeling/Model/steady.html#options-for-nonlinear-models","text":"Blocks=true [ true | false ] - Rearrange steady-state equations in sequential blocks before computing steady state. Endogenize=[ ] [ @auto | cellstr | char | empty ] - List of parameters that will be endogenized when computing the steady state; the number of endogenized parameters must match the number of transtion variables exogenized in the Exogenize= option; the use of the keyword @auto is explained in Description. Exogenize= [ @auto | cellstr | char | empty ] - List of transition variables that will be exogenized when computing the steady state; the number of exogenized variables must match the number of parameters exogenized in the 'Exogenize=' option; the use of the keyword @auto is explained in Description. Fix=[ ] [ cellstr | Except | empty ] - List of variables whose steady state (both level and change) will not be computed and kept fixed to the currently assigned values; alternatively an Except wrapper object can be used to specify that all variables are to be fixed except those listed. FixGrowth=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state first difference (variables not declared as log) or the steady-state rates of change (variables declared as log) of each variables listed. FixLevel=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state level of each variable listed. Growth=[] [ true | false | empty ] If true , both the steady-state levels and steady-state changes (differences or growth rates, depending on the log status of the respective variable) will be computed; if false , only the levels will be computed assuming that either all model variables are stationary, have stochastic trend without deterministic drift, or that the correct steady-state changes are already assigned in the model object. LogMinus=empty [ cell | char | empty ] - List of log variables whose steady state will be restricted to negative values in this run of sstate(~) . Reuse=false [ true | false ] - Reuse the steady-state values calculated for one parameter variant to initialize the steady-state calculation for the next parameter variant. Solver=\"qnsd\" [ \"qnsd\" | \"newton\" | \"fsolve\" | \"lsqnonlin\" | cell ] Numerical nonlinear solver (optionally also specified including non-default settings) used in steady state calculations; see Description; the default solver, \"qnsd\", is an IrisT quasi-Newton steepest-descent based algorithm. Unlog=[ ] [ cell | char | empty ] - List of log variables that will be temporarily treated as non-log variables in this run of steady(~) , i.e. their steady-state levels will not be restricted to either positive or negative values.","title":"Options for nonlinear models"},{"location":"StructuralModeling/Model/steady.html#options-for-linear-models","text":"Solve=false [ true | false ] Calculate first-order solution before steady state.","title":"Options for linear models"},{"location":"StructuralModeling/Model/steady.html#description","text":"Option Growth= The option Growth= is false by default which is consistent with one of the following situations: all model variables are either stationary or have stochastic trend but no deterministic trend (no deterministic trend: the simplest example is a plain vanilla random walk with no drift); the steady-state first differences (for variables not declared as log) and steady-state rates of growth (for variables declared as log) have been assigned (as imaginary parts) in the model object for all variables before running sstate(~)(~) . If some variables have an unknown deterministic trend (drift) in steady state (for instance, a balanced growth path model), sstate(~)(~) needs to be run with Growth=true . Lower and Upper Bounds Use options 'LevelWithin=' and 'ChangeWithin=' to impose lower and/or upper bounds on steady-state levels and/or growth rates of selected variables. Create a struct with a 1-by-2 vector [lower, upper] for each variable that is supposed to be bounded when the steady state is being calculated, and pass the struct into the respective option. User -Inf or Inf if only one of the bounds is specified. For instance, the following piece of code bnd = struct( ); bnd.X = [0, 10]; bnd.Y = [-Inf, 20]; bnd.Z = [5, Inf]; specifies lower bounds for variables X and Z , and upper bounds for variables X and Y . The variables that are not bounded do not need to be included in the struct. Using @auto in Options Exogenize= and Endogenize= The keyword @auto refers to !steady-autoswaps definitions and can be used in the options Exogenize= and Exogenize= in the following three possible combinations: Setting both Exogenize= and Endogenize= to @auto will exogenize all variables from !steady-autoswaps definitions and endogenize all corresponding parameters. Assigning the option Exogenize= an explicit list of variables while setting Endogenize= to @auto will exogenize only the listed variables while endogenizing the same number of the corresponding parameters from !steady-autoswaps definitions. The listed variables must each be found on the left-hand sides of a !steady-autoswaps definition. Setting Exogenize= to @auto while assigning the option Endogenize= an explicit list of parameters will exogenize only the variables that occur on the left-hand sides of those !steady-autoswaps definitions that have the listed parameters on their right-hand sides. The listed parameters must each be found on the right-hand side of a !steady-autoswaps definition. Options Fix=, FixLevel= and FixGrowth= Options Fix= , FixLevel= and FixGrowth= can be used for fixing the steady state of a subset of variables (their steady-state levels, changes, or both) to values supplied by the user before running sstate(~) . The fixed values need to be assigned to the respective variables directly in the model object, and obviously need to be the correct steady-state values. The variables are excluded from the list of unknowns when the steady-state equations are being solved. The list of variables assigned to the three options can be also defined inversely using a Except wrapper object, constructed by passing the list of variables that are not to be fixed. For instance, in sstate(m, 'FixGrowth=', Except('x', 'y')) the steady-state growth of all variables except x and y will be fixed (and needs to be supplied before calling this sstate(~) ).","title":"Description"},{"location":"StructuralModeling/Model/steady.html#example","text":"This example illustrates the use of the keyword @auto in exogenizing/endogenizing variabes/parameters. Assume that the underlying model file included the following sections: !variables W, X, Y, Z !parameters alpha, beta, gamma, delta !steady-autoswaps W := alpha; Y := beta; Z := delta; Running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', @auto) will calculate the steady state with all three variables from the !steady-autoswaps defintions, W , Y , and Z , exogenized to their currently assigned values while endogenizing the three corresponding parameters, alpha , beta , and delta . Running the following command m = sstate(m, 'Exogenize=', {'W', 'Z'}, 'Endogenize=', @auto) will calculate the steady state with the two listed variables, W and Z , exogenized and the corresponding parameters, alpha and delta , endogenized. Finally, running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', {'delta', 'beta'}) will calculate the steady state with two variables, Z and Y , (corresponding to the endogenized parameters listed) exogenized while endogenizing the listed parameters, alpha and delta . %","title":"Example"},{"location":"StructuralModeling/Model/system.html","text":"system System matrices for the unsolved model Syntax [A, B, C, D, F, G, H, J, list, numF] = system(model) Input Arguments model [ Model ] Model object whose system matrices will be returned. Output Arguments A , B , C , D , F , G , H , J [ numeric ] Matrices of the unsolved system, see Description. list [ cell ] Lists of measurement variables, transition variables includint their auxiliary lags and leads, shocks, measurement equations, and transition equations as they appear in the rows and columns of the system matrices. numF [ numeric ] Number of non-predetermined (forward-looking) transition variables (multiplied by the first numF columns of matrices A and B ). Options ForceDiff=false [ true | false ] If false , automatically detect which equations need to be re-differentiated based on parameter changes from the last time the system matrices were calculated; if true , recalculate all derivatives. MatrixFormat=\"NamedMatrix\" [ \"plain\" | \"NamedMatrix\" ] Format of the output matrix. Normalize=true [ true | false ] Normalize (divide) the derivatives within each equation by the largest of them. Sparse=false [ true | false ] Return matrices A , B , D , F , G , and J as sparse matrices; can be set to true only in models with one parameterization. Description The system before the model is solved has the following form: A E[xf;xb] + B [xf(-1);xb(-1)] + C + D e = 0 F y + G xb + H + J e = 0 where E is a conditional expectations operator; xf is a vector of non-predetermined (forward-looking) transition variables; xb is a vector of predetermined (backward-looking) transition variables; y is a vector of measurement variables e is a vector of transition and measurement shocks. Example","title":"system"},{"location":"StructuralModeling/Model/system.html#system","text":"System matrices for the unsolved model","title":"system"},{"location":"StructuralModeling/Model/system.html#syntax","text":"[A, B, C, D, F, G, H, J, list, numF] = system(model)","title":"Syntax"},{"location":"StructuralModeling/Model/system.html#input-arguments","text":"model [ Model ] Model object whose system matrices will be returned.","title":"Input Arguments"},{"location":"StructuralModeling/Model/system.html#output-arguments","text":"A , B , C , D , F , G , H , J [ numeric ] Matrices of the unsolved system, see Description. list [ cell ] Lists of measurement variables, transition variables includint their auxiliary lags and leads, shocks, measurement equations, and transition equations as they appear in the rows and columns of the system matrices. numF [ numeric ] Number of non-predetermined (forward-looking) transition variables (multiplied by the first numF columns of matrices A and B ).","title":"Output Arguments"},{"location":"StructuralModeling/Model/system.html#options","text":"ForceDiff=false [ true | false ] If false , automatically detect which equations need to be re-differentiated based on parameter changes from the last time the system matrices were calculated; if true , recalculate all derivatives. MatrixFormat=\"NamedMatrix\" [ \"plain\" | \"NamedMatrix\" ] Format of the output matrix. Normalize=true [ true | false ] Normalize (divide) the derivatives within each equation by the largest of them. Sparse=false [ true | false ] Return matrices A , B , D , F , G , and J as sparse matrices; can be set to true only in models with one parameterization.","title":"Options"},{"location":"StructuralModeling/Model/system.html#description","text":"The system before the model is solved has the following form: A E[xf;xb] + B [xf(-1);xb(-1)] + C + D e = 0 F y + G xb + H + J e = 0 where E is a conditional expectations operator; xf is a vector of non-predetermined (forward-looking) transition variables; xb is a vector of predetermined (backward-looking) transition variables; y is a vector of measurement variables e is a vector of transition and measurement shocks.","title":"Description"},{"location":"StructuralModeling/Model/system.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Model/table.html","text":"table Create table based on selected indicators from Model object Syntax outputTable = table(model, request, ...) # Input arguments model [ Model ] Model object based on which the table will be prepared. requests [ char | cellstr | string ] Requested columns for the table; see Description for the list of valid requests. Output arguments outputTable [ table ] Table object with requested values. Options CompareFirstColumn=true [ true | false ] Include the first column in comparison tables (first column compares itself with itself). Diary=\"\" [ string ] If Diary= is not empty, the table will be printed on the screen in the command window, and captured in a text file under this file name. SelectRows=false [ false | string ] Select only a subset of rows (names of variables, shocks and/or parameters) to be included in the outputTable . Sort=false [ true | false ] If true sort the table rows alphabetically by the row names. Round=Inf [ Inf | numeric ] Round numeric entries in the table to the specified number of digits; Inf means no rounding. WriteTable=\"\" [ string | cell ] If non-empty, the table will be exported to a text or spreadsheet file (depending on the file extension provided) under this file name using the standard writetable( ) function; Description This is the list of valid requests that can be combined in one call of the table() function: \"SteadyLevel\" - Steady-state level for each model variable. \"SteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables. \"SteadyDiff\" - Steady-state difference for each model variable not declared as log-variables; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables; NaN for nonlog-variables. \"Form\" - Indicator of the form in which steady-state change and/or comparison are reported for each model variable: \"Diff-\" (meaning a first difference when reporting steady-state growth, or a difference between two steady states when reporting steady-state comparison) for each nonlog-variable, and \"Rate/\" for each log-variable. \"CompareSteadyLevel\" - Steady-state level for each model variable compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyDiff\" - Steady-state difference for each model variable not declared as log-variables, compared to the first parameter variant; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables, compared to the first parameter variant; NaN for nonlog-variables. \"Description\" - Description text from the model file (quoted text preceding the name in a declaration section). \"Alias\" - Alias text from the model file (the part of the quoted text preceding the name in a declaration section that follows after a double exclamation mark). \"Log\" - Indicator of log-variables: true for each model variable declared as a log-variable, false otherwise. This is the list of valid requests that can be called individually: \"Parameters\" - The currently assigned value for each parameter; this request can be combined with \"Description\" . \"Stationary\" - Indicator of stationarity of variables or log variables. \"Std\" - The currently assigned value for the standard deviation of each model shock. \"Corr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks. \"CompareParameters\" - The currently assigned value for each parameter compared to the first parameter variant (a difference); this request can be combined with \"Description\" . \"CompareStd\" - The currently assigned value for the standard deviation of each model shock compared to the first parameter variant (a difference). \"CompareCorr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks compared to the first parameter variant (a difference). \"AllRoots\" - All eigenvalues associated with the current solution. \"StableRoots\" - All stable eigenvalues (smaller than 1 in magnitude) associated with the current solution. \"UnitRoots\" - All unit eigenvalues (equal 1 in magnitude) associated with the current solution. \"UnstableRoots\" - All unstable eigenvalues (greater than 1 in magnitude) associated with the current solution. Examples Plain vanilla table Create table with a steady state summary: table ( m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ]) Save table to spreadsheet Create the same table as before, and save it to an Excel spreadsheet file: table ( ... m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ] ... writeTable = \"steadyState.xls\" ... )","title":"table"},{"location":"StructuralModeling/Model/table.html#table","text":"Create table based on selected indicators from Model object","title":"table"},{"location":"StructuralModeling/Model/table.html#syntax","text":"outputTable = table(model, request, ...) # Input arguments model [ Model ] Model object based on which the table will be prepared. requests [ char | cellstr | string ] Requested columns for the table; see Description for the list of valid requests.","title":"Syntax"},{"location":"StructuralModeling/Model/table.html#output-arguments","text":"outputTable [ table ] Table object with requested values.","title":"Output arguments"},{"location":"StructuralModeling/Model/table.html#options","text":"CompareFirstColumn=true [ true | false ] Include the first column in comparison tables (first column compares itself with itself). Diary=\"\" [ string ] If Diary= is not empty, the table will be printed on the screen in the command window, and captured in a text file under this file name. SelectRows=false [ false | string ] Select only a subset of rows (names of variables, shocks and/or parameters) to be included in the outputTable . Sort=false [ true | false ] If true sort the table rows alphabetically by the row names. Round=Inf [ Inf | numeric ] Round numeric entries in the table to the specified number of digits; Inf means no rounding. WriteTable=\"\" [ string | cell ] If non-empty, the table will be exported to a text or spreadsheet file (depending on the file extension provided) under this file name using the standard writetable( ) function;","title":"Options"},{"location":"StructuralModeling/Model/table.html#description","text":"This is the list of valid requests that can be combined in one call of the table() function: \"SteadyLevel\" - Steady-state level for each model variable. \"SteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables. \"SteadyDiff\" - Steady-state difference for each model variable not declared as log-variables; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables; NaN for nonlog-variables. \"Form\" - Indicator of the form in which steady-state change and/or comparison are reported for each model variable: \"Diff-\" (meaning a first difference when reporting steady-state growth, or a difference between two steady states when reporting steady-state comparison) for each nonlog-variable, and \"Rate/\" for each log-variable. \"CompareSteadyLevel\" - Steady-state level for each model variable compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyDiff\" - Steady-state difference for each model variable not declared as log-variables, compared to the first parameter variant; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables, compared to the first parameter variant; NaN for nonlog-variables. \"Description\" - Description text from the model file (quoted text preceding the name in a declaration section). \"Alias\" - Alias text from the model file (the part of the quoted text preceding the name in a declaration section that follows after a double exclamation mark). \"Log\" - Indicator of log-variables: true for each model variable declared as a log-variable, false otherwise. This is the list of valid requests that can be called individually: \"Parameters\" - The currently assigned value for each parameter; this request can be combined with \"Description\" . \"Stationary\" - Indicator of stationarity of variables or log variables. \"Std\" - The currently assigned value for the standard deviation of each model shock. \"Corr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks. \"CompareParameters\" - The currently assigned value for each parameter compared to the first parameter variant (a difference); this request can be combined with \"Description\" . \"CompareStd\" - The currently assigned value for the standard deviation of each model shock compared to the first parameter variant (a difference). \"CompareCorr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks compared to the first parameter variant (a difference). \"AllRoots\" - All eigenvalues associated with the current solution. \"StableRoots\" - All stable eigenvalues (smaller than 1 in magnitude) associated with the current solution. \"UnitRoots\" - All unit eigenvalues (equal 1 in magnitude) associated with the current solution. \"UnstableRoots\" - All unstable eigenvalues (greater than 1 in magnitude) associated with the current solution.","title":"Description"},{"location":"StructuralModeling/Model/table.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Model/table.html#plain-vanilla-table","text":"Create table with a steady state summary: table ( m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ])","title":"Plain vanilla table"},{"location":"StructuralModeling/Model/table.html#save-table-to-spreadsheet","text":"Create the same table as before, and save it to an Excel spreadsheet file: table ( ... m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ] ... writeTable = \"steadyState.xls\" ... )","title":"Save table to spreadsheet"},{"location":"StructuralModeling/Plan/index.html","text":"Overview of simulation plan objects Categorical list of functions Constructing model objects Function Description Plan.forModel Create simulation Plan for Model object Plan.forExplanatory Create simulation Plan for Explanatory object Exogenizing variables, endogenizing shocks Function Description autoswap Exogenize variables and endogenize shocks autoswap pairs","title":"Overview of simulation plan objects"},{"location":"StructuralModeling/Plan/index.html#overview-of-simulation-plan-objects","text":"","title":"Overview of simulation plan objects"},{"location":"StructuralModeling/Plan/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"StructuralModeling/Plan/index.html#constructing-model-objects","text":"Function Description Plan.forModel Create simulation Plan for Model object Plan.forExplanatory Create simulation Plan for Explanatory object","title":"Constructing model objects"},{"location":"StructuralModeling/Plan/index.html#exogenizing-variables-endogenizing-shocks","text":"Function Description autoswap Exogenize variables and endogenize shocks autoswap pairs","title":"Exogenizing variables, endogenizing shocks"},{"location":"StructuralModeling/Plan/autoswap.html","text":"autoswap Exogenize variables and endogenize shocks autoswap pairs Syntax Input arguments Output arguments Description Examples","title":"autoswap"},{"location":"StructuralModeling/Plan/autoswap.html#autoswap","text":"Exogenize variables and endogenize shocks autoswap pairs","title":"autoswap"},{"location":"StructuralModeling/Plan/autoswap.html#syntax","text":"","title":"Syntax"},{"location":"StructuralModeling/Plan/autoswap.html#input-arguments","text":"","title":"Input arguments"},{"location":"StructuralModeling/Plan/autoswap.html#output-arguments","text":"","title":"Output arguments"},{"location":"StructuralModeling/Plan/autoswap.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Plan/autoswap.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Plan/forExplanatory.html","text":"Plan.forExplanatory Create simulation Plan for Explanatory object Syntax Input arguments Output arguments Description Examples","title":"Plan.forExplanatory"},{"location":"StructuralModeling/Plan/forExplanatory.html#planforexplanatory","text":"Create simulation Plan for Explanatory object","title":"Plan.forExplanatory"},{"location":"StructuralModeling/Plan/forExplanatory.html#syntax","text":"","title":"Syntax"},{"location":"StructuralModeling/Plan/forExplanatory.html#input-arguments","text":"","title":"Input arguments"},{"location":"StructuralModeling/Plan/forExplanatory.html#output-arguments","text":"","title":"Output arguments"},{"location":"StructuralModeling/Plan/forExplanatory.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Plan/forExplanatory.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Plan/forModel.html","text":"Plan.forModel Create simulation Plan for Model object Syntax Input arguments Output arguments Description Examples","title":"Plan.forModel"},{"location":"StructuralModeling/Plan/forModel.html#planformodel","text":"Create simulation Plan for Model object","title":"Plan.forModel"},{"location":"StructuralModeling/Plan/forModel.html#syntax","text":"","title":"Syntax"},{"location":"StructuralModeling/Plan/forModel.html#input-arguments","text":"","title":"Input arguments"},{"location":"StructuralModeling/Plan/forModel.html#output-arguments","text":"","title":"Output arguments"},{"location":"StructuralModeling/Plan/forModel.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Plan/forModel.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Slang/index.html","text":"Overview of model source code language The IrisT model source code language (Slang) is a system of keywords that define the structure of model source files. The model source files are plain text files (saved under any file name with any extension) that describe the model: its equations, variables, parameters, etc. The model files do not describe what tasks to do with the model. To run the tasks you want to perform with the model, you need first to load the model file into Matlab using the Model.fromFile function. This function creates a model object. Then you write your own m-files using Matlab and IrisT functions to perform the desired tasks with the model object. When writing model files, you can also use the IrisT preparsing commands that introduce tools for writing reusable and well-structured model code base and minimize repetitive model code writing tasks. You can get the model source files syntax highlighted in the Matlab editor to improve the readability of the files, and helps navigate the model more quickly; see the setup instructions . Guidelines Reference Description Creating model files Guideline for writing and structuring model source files Declaring model names Declare model names: Variables, shocks, parameters Writing model equations Write model equations Categorical list of keywords Declaring model names: Variables, parameters and shocks Keyword Description !transition-variables Declare names of transition variables !transition-shocks Declare names of transition shocks !measurement-variables Declare names fo measurement variables !measurement-shocks Declare names of measurement shocks !parameters Declare names of parameters !exogenous-variables Declare names exogenous variables Writing model equations See {{ slang._equations }} for details on declaring model equations. See {{ slang._guidelines }} for writing model source files. Keyword Description !transition-equations Block of transition equations !measurement-equations Block of measurement equations !dtrends Block of deterministic trend equations !links Define dynamic links !preprocessor Preprocessing equations !postprocessor Postprocessing equations Controlling log status of variables Keyword Description !log-variables List of log-linearised variables !all-but Inverse list of log-linearised variables Defining autoswap pairs !autoswaps-simulate | Definitions of variable-shock pairs to be autoswapped in dynamic simulations !autoswaps-steady | Definitions of variable-parameter pairs to be autoexogenized in steady-state calculations Other keywords and syntax Keyword Description min Define loss function for optimal policy !! Steady-state versions of equations || Separate alias from the rest of name or equation description {...} Lag or lead & Reference to the steady-state level of a variable !ttrend Linear time trend in deterministic trend equations Pseudofunctions Pseudofunctions do not start with an exclamation point Keyword Description diff First difference pseudofunction roc Gross rate of change pseudofunction pct Percent change difflog First log-difference pseudofunction movavg Moving average pseudofunction movgeom Moving geometric average pseudofunction movprod Moving product pseudofunction movsum Moving sum pseudofunction Preparsing keywords Keyword Description % Line comments %{ ... %} Block comments <...> Interpolation. !export Create exportable file to be saved in working directory. !for For-loop control structure for automated creation of model source code !function Create exportable m-file function to be saved in working directory !if Choose block of code based on logical condition. !import Include the content of another model file. !substitutions Define text substitutions !switch Switch among several cases based on expression. Matlab and user-defined functions in model files You can use any of the built-in functions (Matlab functions, functions within the Toolboxes you have on your computer, or your own m-file functions). The only requirement is that the function needs to be visible to Matlab, i.e. located either in the current working directory or in a folder on the Matlab search path. In addition, when using your own m-file functions, you can also (optionally) supply the first derivatives that will be used to compute Taylor expansions when the model is being solved, and the second derivatives that will be used when the function occurs in a loss function. When asked for the derivatives, the function is called with two extra input arguments on top of that function's regular input arguments. The first extra input argument is a text string \"diff\" (indicating the call to the function is supposed to return a derivative). The second extra input argument is a number or a vector of two numbers; it determines with respect to which input argument or arguments the first derivative or the second derivative is requested. For instance, your function takes three input arguments, myfunc(x, y, z) . To be able to supply derivates avoiding thus numerical differentiation, the function must be written so that the following three calls myfunc(x, y, z, \"diff\", 1) myfunc(x, y, z, \"diff\", 2) myfunc(x, y, z, \"diff\", 3) return the first derivative wrt to the first, second, and third input argument, respectively, while myfunc(x, y, z, \"diff\", [1, 2]) returns the second derivative wrt to the first and second input arguments. Note that second derivatives are only needed for functions that occur in an equation defining optimal policy objective, min . If any of these calls fail, the respective derivative will be simply evaluated numerically. Basic rules for writing IrisT model source files There can be four types of equations in IrisT models: transition equations which are simply the endogenous dynamic equations, measurement equations which link the model to observables, deterministic trend equations which can be added at the top of measurement equations, and dynamic links which can be used to link some parameters or steady-state values to each other. There can be two types of variables and two types of shocks in IrisT models: transition variables and shocks, and measurement variables and shocks. Each model must have at least one transition (aka endogenous) variable and one transition equation. Each variable, shock, or parameter must be declared in the appropriate declaration section. The declaration sections and equations sections can be written in any order. You can have as many declaration sections or equations sections of the same kind as you wish in one model file; they all get combined together at the time the model is being loaded. Transition variables can occur with lags and leads in transition equations. Transition variables cannot, though, have leads in measurement equations. Measurement variables and the shocks cannot have any lags or leads. Transition shocks cannot occur in measurement equations, and the measurement shocks cannot occur in transition equations. Exogenous variables can only occur in dtrends (deterministic trend equations), and must be always supplied as part of the input database to commands like Model/simulate , Model/filter , Model/estimate , etc. They are not returned in the output databases. You can choose between linearisation and log-linearisation for each individual transition and measurement variable. Shocks are always linearized. Exogenous variables must be always introduced so that their effect on the respective measurement variable is linear.","title":"Overview of model source code language"},{"location":"StructuralModeling/Slang/index.html#overview-of-model-source-code-language","text":"The IrisT model source code language (Slang) is a system of keywords that define the structure of model source files. The model source files are plain text files (saved under any file name with any extension) that describe the model: its equations, variables, parameters, etc. The model files do not describe what tasks to do with the model. To run the tasks you want to perform with the model, you need first to load the model file into Matlab using the Model.fromFile function. This function creates a model object. Then you write your own m-files using Matlab and IrisT functions to perform the desired tasks with the model object. When writing model files, you can also use the IrisT preparsing commands that introduce tools for writing reusable and well-structured model code base and minimize repetitive model code writing tasks. You can get the model source files syntax highlighted in the Matlab editor to improve the readability of the files, and helps navigate the model more quickly; see the setup instructions .","title":"Overview of model source code language"},{"location":"StructuralModeling/Slang/index.html#guidelines","text":"Reference Description Creating model files Guideline for writing and structuring model source files Declaring model names Declare model names: Variables, shocks, parameters Writing model equations Write model equations","title":"Guidelines"},{"location":"StructuralModeling/Slang/index.html#categorical-list-of-keywords","text":"","title":"Categorical list of keywords"},{"location":"StructuralModeling/Slang/index.html#declaring-model-names-variables-parameters-and-shocks","text":"Keyword Description !transition-variables Declare names of transition variables !transition-shocks Declare names of transition shocks !measurement-variables Declare names fo measurement variables !measurement-shocks Declare names of measurement shocks !parameters Declare names of parameters !exogenous-variables Declare names exogenous variables","title":"Declaring model names: Variables, parameters and shocks"},{"location":"StructuralModeling/Slang/index.html#writing-model-equations","text":"See {{ slang._equations }} for details on declaring model equations. See {{ slang._guidelines }} for writing model source files. Keyword Description !transition-equations Block of transition equations !measurement-equations Block of measurement equations !dtrends Block of deterministic trend equations !links Define dynamic links !preprocessor Preprocessing equations !postprocessor Postprocessing equations","title":"Writing model equations"},{"location":"StructuralModeling/Slang/index.html#controlling-log-status-of-variables","text":"Keyword Description !log-variables List of log-linearised variables !all-but Inverse list of log-linearised variables","title":"Controlling log status of variables"},{"location":"StructuralModeling/Slang/index.html#defining-autoswap-pairs","text":"!autoswaps-simulate | Definitions of variable-shock pairs to be autoswapped in dynamic simulations !autoswaps-steady | Definitions of variable-parameter pairs to be autoexogenized in steady-state calculations","title":"Defining autoswap pairs"},{"location":"StructuralModeling/Slang/index.html#other-keywords-and-syntax","text":"Keyword Description min Define loss function for optimal policy !! Steady-state versions of equations || Separate alias from the rest of name or equation description {...} Lag or lead & Reference to the steady-state level of a variable !ttrend Linear time trend in deterministic trend equations","title":"Other keywords and syntax"},{"location":"StructuralModeling/Slang/index.html#pseudofunctions","text":"Pseudofunctions do not start with an exclamation point Keyword Description diff First difference pseudofunction roc Gross rate of change pseudofunction pct Percent change difflog First log-difference pseudofunction movavg Moving average pseudofunction movgeom Moving geometric average pseudofunction movprod Moving product pseudofunction movsum Moving sum pseudofunction","title":"Pseudofunctions"},{"location":"StructuralModeling/Slang/index.html#preparsing-keywords","text":"Keyword Description % Line comments %{ ... %} Block comments <...> Interpolation. !export Create exportable file to be saved in working directory. !for For-loop control structure for automated creation of model source code !function Create exportable m-file function to be saved in working directory !if Choose block of code based on logical condition. !import Include the content of another model file. !substitutions Define text substitutions !switch Switch among several cases based on expression.","title":"Preparsing keywords"},{"location":"StructuralModeling/Slang/index.html#matlab-and-user-defined-functions-in-model-files","text":"You can use any of the built-in functions (Matlab functions, functions within the Toolboxes you have on your computer, or your own m-file functions). The only requirement is that the function needs to be visible to Matlab, i.e. located either in the current working directory or in a folder on the Matlab search path. In addition, when using your own m-file functions, you can also (optionally) supply the first derivatives that will be used to compute Taylor expansions when the model is being solved, and the second derivatives that will be used when the function occurs in a loss function. When asked for the derivatives, the function is called with two extra input arguments on top of that function's regular input arguments. The first extra input argument is a text string \"diff\" (indicating the call to the function is supposed to return a derivative). The second extra input argument is a number or a vector of two numbers; it determines with respect to which input argument or arguments the first derivative or the second derivative is requested. For instance, your function takes three input arguments, myfunc(x, y, z) . To be able to supply derivates avoiding thus numerical differentiation, the function must be written so that the following three calls myfunc(x, y, z, \"diff\", 1) myfunc(x, y, z, \"diff\", 2) myfunc(x, y, z, \"diff\", 3) return the first derivative wrt to the first, second, and third input argument, respectively, while myfunc(x, y, z, \"diff\", [1, 2]) returns the second derivative wrt to the first and second input arguments. Note that second derivatives are only needed for functions that occur in an equation defining optimal policy objective, min . If any of these calls fail, the respective derivative will be simply evaluated numerically.","title":"Matlab and user-defined functions in model files"},{"location":"StructuralModeling/Slang/index.html#basic-rules-for-writing-irist-model-source-files","text":"There can be four types of equations in IrisT models: transition equations which are simply the endogenous dynamic equations, measurement equations which link the model to observables, deterministic trend equations which can be added at the top of measurement equations, and dynamic links which can be used to link some parameters or steady-state values to each other. There can be two types of variables and two types of shocks in IrisT models: transition variables and shocks, and measurement variables and shocks. Each model must have at least one transition (aka endogenous) variable and one transition equation. Each variable, shock, or parameter must be declared in the appropriate declaration section. The declaration sections and equations sections can be written in any order. You can have as many declaration sections or equations sections of the same kind as you wish in one model file; they all get combined together at the time the model is being loaded. Transition variables can occur with lags and leads in transition equations. Transition variables cannot, though, have leads in measurement equations. Measurement variables and the shocks cannot have any lags or leads. Transition shocks cannot occur in measurement equations, and the measurement shocks cannot occur in transition equations. Exogenous variables can only occur in dtrends (deterministic trend equations), and must be always supplied as part of the input database to commands like Model/simulate , Model/filter , Model/estimate , etc. They are not returned in the output databases. You can choose between linearisation and log-linearisation for each individual transition and measurement variable. Shocks are always linearized. Exogenous variables must be always introduced so that their effect on the respective measurement variable is linear.","title":"Basic rules for writing IrisT model source files"},{"location":"StructuralModeling/Slang/%21all-but.html","text":"!all-but Inverse list of log-linearised variables Syntax !log-variables !all-but VariableName, VariableName, VariableName, ... Description See help on !log-variables .","title":"!all-but"},{"location":"StructuralModeling/Slang/%21all-but.html#all-but","text":"Inverse list of log-linearised variables","title":"!all-but"},{"location":"StructuralModeling/Slang/%21all-but.html#syntax","text":"!log-variables !all-but VariableName, VariableName, VariableName, ...","title":"Syntax"},{"location":"StructuralModeling/Slang/%21all-but.html#description","text":"See help on !log-variables .","title":"Description"},{"location":"StructuralModeling/Slang/%21autoswaps-simulate.html","text":"!autoswaps-simulate Definitions of variable-shock pairs to be autoswapped in dynamic simulations Syntax !autoswaps-simulate variableName := shockName; variableName := shockName; variableName := shockName; Description The section !autoswaps-simulate defines pairs of variables and shocks that can be used to simplify and automate the specification of dynamic simulation Plan objects by calling the function autoswap . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid measurement or transition shock name. Example !transition-variables x, y, z !transition-shocks ex, ey, ez !measurement-variables x_obs, y_obs, z_obs !autoswaps-simulate x := ex; y_obs := ey;","title":"!autoswaps-simulate"},{"location":"StructuralModeling/Slang/%21autoswaps-simulate.html#autoswaps-simulate","text":"Definitions of variable-shock pairs to be autoswapped in dynamic simulations","title":"!autoswaps-simulate"},{"location":"StructuralModeling/Slang/%21autoswaps-simulate.html#syntax","text":"!autoswaps-simulate variableName := shockName; variableName := shockName; variableName := shockName;","title":"Syntax"},{"location":"StructuralModeling/Slang/%21autoswaps-simulate.html#description","text":"The section !autoswaps-simulate defines pairs of variables and shocks that can be used to simplify and automate the specification of dynamic simulation Plan objects by calling the function autoswap . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid measurement or transition shock name.","title":"Description"},{"location":"StructuralModeling/Slang/%21autoswaps-simulate.html#example","text":"!transition-variables x, y, z !transition-shocks ex, ey, ez !measurement-variables x_obs, y_obs, z_obs !autoswaps-simulate x := ex; y_obs := ey;","title":"Example"},{"location":"StructuralModeling/Slang/%21autoswaps-steady.html","text":"!autoswaps-steady Definitions of variable-parameter pairs to be autoexogenized in steady-state calculations Syntax !autoswaps-steady variableName := parameterName; variableName := parameterName; variableName := parameterName; Description The section !autoswaps-steady defines pairs of variables and parameters that can be used to simplify and automate the definition of exogenized variables and endogenized parameters in steady-state calculations, i.e. in calling the function Model/steady . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid parameter name. Examples !transition_variables x, y, z !parameters alpha, beta, gamma !measurement_variables x_obs, y_obs, z_obs !dynamic_autoexog x := alpha; y_obs := beta;","title":"!autoswaps-steady"},{"location":"StructuralModeling/Slang/%21autoswaps-steady.html#autoswaps-steady","text":"Definitions of variable-parameter pairs to be autoexogenized in steady-state calculations","title":"!autoswaps-steady"},{"location":"StructuralModeling/Slang/%21autoswaps-steady.html#syntax","text":"!autoswaps-steady variableName := parameterName; variableName := parameterName; variableName := parameterName;","title":"Syntax"},{"location":"StructuralModeling/Slang/%21autoswaps-steady.html#description","text":"The section !autoswaps-steady defines pairs of variables and parameters that can be used to simplify and automate the definition of exogenized variables and endogenized parameters in steady-state calculations, i.e. in calling the function Model/steady . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid parameter name.","title":"Description"},{"location":"StructuralModeling/Slang/%21autoswaps-steady.html#examples","text":"!transition_variables x, y, z !parameters alpha, beta, gamma !measurement_variables x_obs, y_obs, z_obs !dynamic_autoexog x := alpha; y_obs := beta;","title":"Examples"},{"location":"StructuralModeling/Slang/%21dtrends.html","text":"!dtrends Block of deterministic trend equations Syntax for linearised measurement variables !dtrends VariableName += Expression; VariableName += Expression; ... Syntax for log-linearised measurement variables !dtrends log(VariableName) += Expression; log(VariableName) += Expression; ... Syntax with equation labels !dtrends 'Equation label' VariableName += Expression; 'Equation label' LOG(VariableName) += Expression; Description Example !dtrends Infl += pi_; Rate += rho_ + pi_;","title":"!dtrends"},{"location":"StructuralModeling/Slang/%21dtrends.html#dtrends","text":"Block of deterministic trend equations","title":"!dtrends"},{"location":"StructuralModeling/Slang/%21dtrends.html#syntax-for-linearised-measurement-variables","text":"!dtrends VariableName += Expression; VariableName += Expression; ...","title":"Syntax for linearised measurement variables"},{"location":"StructuralModeling/Slang/%21dtrends.html#syntax-for-log-linearised-measurement-variables","text":"!dtrends log(VariableName) += Expression; log(VariableName) += Expression; ...","title":"Syntax for log-linearised measurement variables"},{"location":"StructuralModeling/Slang/%21dtrends.html#syntax-with-equation-labels","text":"!dtrends 'Equation label' VariableName += Expression; 'Equation label' LOG(VariableName) += Expression;","title":"Syntax with equation labels"},{"location":"StructuralModeling/Slang/%21dtrends.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Slang/%21dtrends.html#example","text":"!dtrends Infl += pi_; Rate += rho_ + pi_;","title":"Example"},{"location":"StructuralModeling/Slang/%21exogenous-variables.html","text":"!exogenous-variables Declare names exogenous variables See {{ slang._names }} for details on declaring model names.","title":"!exogenous-variables"},{"location":"StructuralModeling/Slang/%21exogenous-variables.html#exogenous-variables","text":"Declare names exogenous variables See {{ slang._names }} for details on declaring model names.","title":"!exogenous-variables"},{"location":"StructuralModeling/Slang/%21export.html","text":"!export Create exportable file to be saved in working directory. Syntax !export(FileName) FileContents !end Description You can include in the model file the contents of files you need or want to carry around together with the model; a typical example is your own m-file functions used in model equations. The file or files are created and saved under the name specified in the !export keyword at the time you load the model using the function model . The contents of the export files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export . If no filename is provided or FileName is empty, an error is thrown.","title":"!export"},{"location":"StructuralModeling/Slang/%21export.html#export","text":"Create exportable file to be saved in working directory.","title":"!export"},{"location":"StructuralModeling/Slang/%21export.html#syntax","text":"!export(FileName) FileContents !end","title":"Syntax"},{"location":"StructuralModeling/Slang/%21export.html#description","text":"You can include in the model file the contents of files you need or want to carry around together with the model; a typical example is your own m-file functions used in model equations. The file or files are created and saved under the name specified in the !export keyword at the time you load the model using the function model . The contents of the export files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export . If no filename is provided or FileName is empty, an error is thrown.","title":"Description"},{"location":"StructuralModeling/Slang/%21for.html","text":"!for For-loop control structure for automated creation of model source code Abbreviated syntax (cannot be nested) In the abbreviated syntax, the control name is simply ? !for tokens !do template !end Full syntax !for ?controlName = tokens !do template !end Full syntax with Matlab expression !for ?controlName = <matlab> !do template !end Description Use the !for control structure to specify a template and let the IrisT preparser automatically create multiple instances of the template by iterating over a list of tokens. The preparser cycles over the individual strings from the list; in each iteration, the current string is used to replace all occurences of the control variable in the template. The name of the control name is either implicitly a question mark, ? , in the abbreviated syntax, or any string starting with a question mark and not containing blank spaces, question marks (other than the leading question mark), colons or periods; for example, ?x , ?# , ?NAME+ . The tokens (text strings) in the list must be separated by commas, blank spaces, or line breaks and they themselves must not contain any of those. In each iteration, all occurrences of the control variable in the template are replaced with the currently processed token; all occurrences in the template of ?.controlName are replaced with the currently processed token converted to lower case; this option is NOT available with the abbreviated syntax; all occurrences in the template of ?:controlName are replaced with the currently processed token converted to upper case; this option is NOT available with the abbreviated syntax; The list of tokens can be based on Matlab expressions Matlab expressions : Enclose an expression in a pair of angle braces, <...> . The expression must evaluate to either a numeric vector, a char vector, a string vetor, or a cell array of numerics and/or strings; the value will be then converted to a comma-separted list of strings. Examples Automate similar equations In a model sourc file, instead of writing a number of definitions of growth rates like the following ones dP = P/P{-1} - 1; dW = W/W{-1} - 1; dX = X/X{-1} - 1; dY = Y/Y{-1} - 1; can use the !for control structure as follows: !for P, W, X, Y !do d? = ?/?{-1} - 1; !end Also with declarations We redo the previous example, but using now the fact that you can have as many variable declaration sections or equation sections as you wish. The !for control structure can therefore not only produce the equations for you, but also declare the respectie variables. !for P, W, X, Y !do !transition_variables d? !transition_equations d? = ?/?{-1} - 1; !end The preparser expands this structure as follows: !transition_variables dP !transition_equations dP = P/P{-1} - 1; !transition_variables dW !transition_equations dW = W/W{-1} - 1; !transition_variables dX !transition_equations dX = X/X{-1} - 1; !transition_variables dY !transition_equations dY = Y/Y{-1} - 1; Switch lower/upper case as needed In a model source file, instead of writing a number of autoregression processes like the following ones X = rhox*X{-1} + ex; Y = rhoy*Y{-1} + ey; Z = rhoz*Z{-1} + ez; use a !for control structure as follows changing the lower/upper case of the tokens as needed: !for ?# = X, Y, Z !do ?# = rho?.#*?{-1} + e?.#; !end Example Redo the previous example, but now for six variables named A1 , A2 , B1 , B2 , C1 , C2 , nesting two !for control structures one within the other: !for ?letter = A, B, C !do !for ?number = 1, 2 !do ?letter?number = rho?.letter?number * ?letter?number{-1} e?.letter?number; !end !end The preparser produces the following six equations: A1 = rhoa1*A1{-1} + ea1; A2 = rhoa2*A2{-1} + ea2; B1 = rhob1*B1{-1} + eb1; B2 = rhob2*B2{-1} + eb2; C1 = rhoc1*C1{-1} + ec1; C2 = rhoc2*C2{-1} + ec2; Use Matlab expressions We use a Matlab expression (the colon operator) to simplify the list of tokens. The following block of code !for 1, 2, 3, 4, 5, 6, 7 !do a? = a?{-1} + res_a?; !end can be simplified as follow: !for <1 : 7> !do a? = a?{-1} + res_a?; !end or generalized with the use of Matlab variable name supplied through the option assign= when reading the model source file . !for <1 : N> !do a? = a?{-1} + res_a?; !end","title":"!for"},{"location":"StructuralModeling/Slang/%21for.html#for","text":"For-loop control structure for automated creation of model source code","title":"!for"},{"location":"StructuralModeling/Slang/%21for.html#abbreviated-syntax-cannot-be-nested","text":"In the abbreviated syntax, the control name is simply ? !for tokens !do template !end","title":"Abbreviated syntax (cannot be nested)"},{"location":"StructuralModeling/Slang/%21for.html#full-syntax","text":"!for ?controlName = tokens !do template !end","title":"Full syntax"},{"location":"StructuralModeling/Slang/%21for.html#full-syntax-with-matlab-expression","text":"!for ?controlName = <matlab> !do template !end","title":"Full syntax with Matlab expression"},{"location":"StructuralModeling/Slang/%21for.html#description","text":"Use the !for control structure to specify a template and let the IrisT preparser automatically create multiple instances of the template by iterating over a list of tokens. The preparser cycles over the individual strings from the list; in each iteration, the current string is used to replace all occurences of the control variable in the template. The name of the control name is either implicitly a question mark, ? , in the abbreviated syntax, or any string starting with a question mark and not containing blank spaces, question marks (other than the leading question mark), colons or periods; for example, ?x , ?# , ?NAME+ . The tokens (text strings) in the list must be separated by commas, blank spaces, or line breaks and they themselves must not contain any of those. In each iteration, all occurrences of the control variable in the template are replaced with the currently processed token; all occurrences in the template of ?.controlName are replaced with the currently processed token converted to lower case; this option is NOT available with the abbreviated syntax; all occurrences in the template of ?:controlName are replaced with the currently processed token converted to upper case; this option is NOT available with the abbreviated syntax; The list of tokens can be based on Matlab expressions Matlab expressions : Enclose an expression in a pair of angle braces, <...> . The expression must evaluate to either a numeric vector, a char vector, a string vetor, or a cell array of numerics and/or strings; the value will be then converted to a comma-separted list of strings.","title":"Description"},{"location":"StructuralModeling/Slang/%21for.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Slang/%21for.html#automate-similar-equations","text":"In a model sourc file, instead of writing a number of definitions of growth rates like the following ones dP = P/P{-1} - 1; dW = W/W{-1} - 1; dX = X/X{-1} - 1; dY = Y/Y{-1} - 1; can use the !for control structure as follows: !for P, W, X, Y !do d? = ?/?{-1} - 1; !end","title":"Automate similar equations"},{"location":"StructuralModeling/Slang/%21for.html#also-with-declarations","text":"We redo the previous example, but using now the fact that you can have as many variable declaration sections or equation sections as you wish. The !for control structure can therefore not only produce the equations for you, but also declare the respectie variables. !for P, W, X, Y !do !transition_variables d? !transition_equations d? = ?/?{-1} - 1; !end The preparser expands this structure as follows: !transition_variables dP !transition_equations dP = P/P{-1} - 1; !transition_variables dW !transition_equations dW = W/W{-1} - 1; !transition_variables dX !transition_equations dX = X/X{-1} - 1; !transition_variables dY !transition_equations dY = Y/Y{-1} - 1;","title":"Also with declarations"},{"location":"StructuralModeling/Slang/%21for.html#switch-lowerupper-case-as-needed","text":"In a model source file, instead of writing a number of autoregression processes like the following ones X = rhox*X{-1} + ex; Y = rhoy*Y{-1} + ey; Z = rhoz*Z{-1} + ez; use a !for control structure as follows changing the lower/upper case of the tokens as needed: !for ?# = X, Y, Z !do ?# = rho?.#*?{-1} + e?.#; !end","title":"Switch lower/upper case as needed"},{"location":"StructuralModeling/Slang/%21for.html#example","text":"Redo the previous example, but now for six variables named A1 , A2 , B1 , B2 , C1 , C2 , nesting two !for control structures one within the other: !for ?letter = A, B, C !do !for ?number = 1, 2 !do ?letter?number = rho?.letter?number * ?letter?number{-1} e?.letter?number; !end !end The preparser produces the following six equations: A1 = rhoa1*A1{-1} + ea1; A2 = rhoa2*A2{-1} + ea2; B1 = rhob1*B1{-1} + eb1; B2 = rhob2*B2{-1} + eb2; C1 = rhoc1*C1{-1} + ec1; C2 = rhoc2*C2{-1} + ec2;","title":"Example"},{"location":"StructuralModeling/Slang/%21for.html#use-matlab-expressions","text":"We use a Matlab expression (the colon operator) to simplify the list of tokens. The following block of code !for 1, 2, 3, 4, 5, 6, 7 !do a? = a?{-1} + res_a?; !end can be simplified as follow: !for <1 : 7> !do a? = a?{-1} + res_a?; !end or generalized with the use of Matlab variable name supplied through the option assign= when reading the model source file . !for <1 : N> !do a? = a?{-1} + res_a?; !end","title":"Use Matlab expressions"},{"location":"StructuralModeling/Slang/%21function.html","text":"!function Create exportable m-file function to be saved in working directory Syntax !function [...] = functionName(...) ... !end Description You can include in the model file the contents of m-file functions you need or want to carry around together with the model; a typical example is your own functions used in model equations. The !function ... !end command is a shortcut to the following !export ... !end structure: !export(functionName.m) function [...] = functionName(...) ... end !end The m-file function are created and saved under the name specified in the function definition at the time you load the model using the function model . The contents of the files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export .","title":"!function"},{"location":"StructuralModeling/Slang/%21function.html#function","text":"Create exportable m-file function to be saved in working directory Syntax !function [...] = functionName(...) ... !end Description You can include in the model file the contents of m-file functions you need or want to carry around together with the model; a typical example is your own functions used in model equations. The !function ... !end command is a shortcut to the following !export ... !end structure: !export(functionName.m) function [...] = functionName(...) ... end !end The m-file function are created and saved under the name specified in the function definition at the time you load the model using the function model . The contents of the files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export .","title":"!function"},{"location":"StructuralModeling/Slang/%21if.html","text":"!if Choose a branch of code based on logical condition Syntax with else and elseif clauses !if Condition1 Block1 !elseif Condition2 Block2 !elseif Condition3 ... !else Block3 !end Syntax with an else clause only !if Condition1 Block1 !else Block2 !end Syntax without an else clause !if Condition Block1 !end Description The !if command works the same way as its counterpart in the Matlab programming language. Use the command to create multiple branches or versions of the model source code. Whether a block of code in a particular branch is used or discarded, depends on the condition after the opening !if command and the conditions after subsequent !elseif commands if present. The condition must be a Matlab expression that evaluates to true or false. The condition can refer to model parameters, or to other fields included in the database passed in through the option ' assign= ' in the model function. Example !if B < Inf % This is a linearised sticky-price Phillips curve. pi = A*pi{-1} + (1-A)*pi{1} + B*log(mu*rmc); !else % This is a flexible-price mark-up rule. rmc = 1/mu; !end If you set the parameter B to Inf in the parameter database when reading in the model file, then the flexible-price equatio, rmc = 0 , is used and the Phillips curve equation discarded. To use the Phillips curve equation instead, you need to re-read the model file with B set to a number other than Inf. In this example, B needs to be, obviously, declared as a model parameter. Example !if exogenous == true x = y; !else x = rho*x{-1} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named exogenous in it, and use the 'assign=' option to pass the database in. Note that you do not need to declare exogenous as a parameter in the model file. P = struct( ); P.exogenous = true; ... m = model('my.model','assign=',P); In this case, the model will contain the first equation, x = rho*x{-1} + epsilon; will be used, and the other discarded. To use the other equation, x = y , you need to re-read the model file with exogenous set to false: P = struct( ); P.exogenous = false; ... m = model('my.model','assign=',P); You can also use an abbreviate syntax to assign control parameters when readin the model file; for instance m = model('my.model','exogenous=',true);","title":"!if"},{"location":"StructuralModeling/Slang/%21if.html#if","text":"Choose a branch of code based on logical condition","title":"!if"},{"location":"StructuralModeling/Slang/%21if.html#syntax-with-else-and-elseif-clauses","text":"!if Condition1 Block1 !elseif Condition2 Block2 !elseif Condition3 ... !else Block3 !end","title":"Syntax with else and elseif clauses"},{"location":"StructuralModeling/Slang/%21if.html#syntax-with-an-else-clause-only","text":"!if Condition1 Block1 !else Block2 !end","title":"Syntax with an else clause only"},{"location":"StructuralModeling/Slang/%21if.html#syntax-without-an-else-clause","text":"!if Condition Block1 !end","title":"Syntax without an else clause"},{"location":"StructuralModeling/Slang/%21if.html#description","text":"The !if command works the same way as its counterpart in the Matlab programming language. Use the command to create multiple branches or versions of the model source code. Whether a block of code in a particular branch is used or discarded, depends on the condition after the opening !if command and the conditions after subsequent !elseif commands if present. The condition must be a Matlab expression that evaluates to true or false. The condition can refer to model parameters, or to other fields included in the database passed in through the option ' assign= ' in the model function.","title":"Description"},{"location":"StructuralModeling/Slang/%21if.html#example","text":"!if B < Inf % This is a linearised sticky-price Phillips curve. pi = A*pi{-1} + (1-A)*pi{1} + B*log(mu*rmc); !else % This is a flexible-price mark-up rule. rmc = 1/mu; !end If you set the parameter B to Inf in the parameter database when reading in the model file, then the flexible-price equatio, rmc = 0 , is used and the Phillips curve equation discarded. To use the Phillips curve equation instead, you need to re-read the model file with B set to a number other than Inf. In this example, B needs to be, obviously, declared as a model parameter.","title":"Example"},{"location":"StructuralModeling/Slang/%21if.html#example_1","text":"!if exogenous == true x = y; !else x = rho*x{-1} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named exogenous in it, and use the 'assign=' option to pass the database in. Note that you do not need to declare exogenous as a parameter in the model file. P = struct( ); P.exogenous = true; ... m = model('my.model','assign=',P); In this case, the model will contain the first equation, x = rho*x{-1} + epsilon; will be used, and the other discarded. To use the other equation, x = y , you need to re-read the model file with exogenous set to false: P = struct( ); P.exogenous = false; ... m = model('my.model','assign=',P); You can also use an abbreviate syntax to assign control parameters when readin the model file; for instance m = model('my.model','exogenous=',true);","title":"Example"},{"location":"StructuralModeling/Slang/%21import.html","text":"!import Include the content of another model file. Syntax !import(FileName) Description The !import command loads the content of the specified file FileName . This allows you to split the model code into several parts (each saved in a separate file) and to reuse some bits of the model. Example !import(mesurement_equations.model)","title":"!import"},{"location":"StructuralModeling/Slang/%21import.html#import","text":"Include the content of another model file.","title":"!import"},{"location":"StructuralModeling/Slang/%21import.html#syntax","text":"!import(FileName)","title":"Syntax"},{"location":"StructuralModeling/Slang/%21import.html#description","text":"The !import command loads the content of the specified file FileName . This allows you to split the model code into several parts (each saved in a separate file) and to reuse some bits of the model.","title":"Description"},{"location":"StructuralModeling/Slang/%21import.html#example","text":"!import(mesurement_equations.model)","title":"Example"},{"location":"StructuralModeling/Slang/%21links.html","text":"!links Define dynamic links Syntax !links ParameterName := Expression; VariableName := Expression; Syntax with equation labels !links 'Equation label' ParameterName := Expression; 'Equation label' VariableName := Expression; Description The dynamic links relate a particular parameter (or steady-state value) on the LHS to a function of other parameters or steady-state values on the RHS. Expression can be any expression involving parameter names, variables names, Matlab functions and constants, or your own m-file functions on the path; it must not refer to any lags or leads. Expression must evaluate to a single number. It is the user's responsibility to properly handle the imaginary (i.e. growth) part of the steady-state values. The links are automatically refreshed in solve , sstate , and chksstate functions, and also in each iteration within the estimate function. They can also be refreshed manually by calling refresh . The links must not involve parameters occuring in !dtrends equations that will be estimated using the 'outoflik=' option of the estimate function. Example !links R := 1/beta; alphak := 1 - alphan - alpham;","title":"!links"},{"location":"StructuralModeling/Slang/%21links.html#links","text":"Define dynamic links","title":"!links"},{"location":"StructuralModeling/Slang/%21links.html#syntax","text":"!links ParameterName := Expression; VariableName := Expression;","title":"Syntax"},{"location":"StructuralModeling/Slang/%21links.html#syntax-with-equation-labels","text":"!links 'Equation label' ParameterName := Expression; 'Equation label' VariableName := Expression;","title":"Syntax with equation labels"},{"location":"StructuralModeling/Slang/%21links.html#description","text":"The dynamic links relate a particular parameter (or steady-state value) on the LHS to a function of other parameters or steady-state values on the RHS. Expression can be any expression involving parameter names, variables names, Matlab functions and constants, or your own m-file functions on the path; it must not refer to any lags or leads. Expression must evaluate to a single number. It is the user's responsibility to properly handle the imaginary (i.e. growth) part of the steady-state values. The links are automatically refreshed in solve , sstate , and chksstate functions, and also in each iteration within the estimate function. They can also be refreshed manually by calling refresh . The links must not involve parameters occuring in !dtrends equations that will be estimated using the 'outoflik=' option of the estimate function.","title":"Description"},{"location":"StructuralModeling/Slang/%21links.html#example","text":"!links R := 1/beta; alphak := 1 - alphan - alpham;","title":"Example"},{"location":"StructuralModeling/Slang/%21log-variables.html","text":"!log-variables List of log-linearised variables Syntax !log-variables VariableName, VariableName, VariableName, ... Syntax with inverted list !log-variables !all-but VariableName, VariableName, VariableName, ... Syntax with regular expression(s) !log-variables VariableName, VariableName, VariableName, ... Description List all log variables under this headings. Only measurement or transition variables can be declared as log variables. In non-linear models, all variables are linearised around the steady state or a balanced-growth path. If you wish to log-linearise some of them instead, put them on a !log-variables list. You can also use the !all-but keyword to indicate an inverse list: all variables will be log-linearised except those listed. Example The following block of code will cause the variables Y , C , I , and K to be declared as log variables, and hence log-linearised in the model solution, while r and pie will be linearised: !transition-variables Y, C, I, K, r, pie !log-variables Y, C, I, K You can do the same job by writing !transition-variables Y, C, I, K, r, pie !log-variables !all-but r, pie","title":"!log-variables"},{"location":"StructuralModeling/Slang/%21log-variables.html#log-variables","text":"List of log-linearised variables","title":"!log-variables"},{"location":"StructuralModeling/Slang/%21log-variables.html#syntax","text":"!log-variables VariableName, VariableName, VariableName, ...","title":"Syntax"},{"location":"StructuralModeling/Slang/%21log-variables.html#syntax-with-inverted-list","text":"!log-variables !all-but VariableName, VariableName, VariableName, ...","title":"Syntax with inverted list"},{"location":"StructuralModeling/Slang/%21log-variables.html#syntax-with-regular-expressions","text":"!log-variables VariableName, VariableName, VariableName, ...","title":"Syntax with regular expression(s)"},{"location":"StructuralModeling/Slang/%21log-variables.html#description","text":"List all log variables under this headings. Only measurement or transition variables can be declared as log variables. In non-linear models, all variables are linearised around the steady state or a balanced-growth path. If you wish to log-linearise some of them instead, put them on a !log-variables list. You can also use the !all-but keyword to indicate an inverse list: all variables will be log-linearised except those listed.","title":"Description"},{"location":"StructuralModeling/Slang/%21log-variables.html#example","text":"The following block of code will cause the variables Y , C , I , and K to be declared as log variables, and hence log-linearised in the model solution, while r and pie will be linearised: !transition-variables Y, C, I, K, r, pie !log-variables Y, C, I, K You can do the same job by writing !transition-variables Y, C, I, K, r, pie !log-variables !all-but r, pie","title":"Example"},{"location":"StructuralModeling/Slang/%21measurement-equations.html","text":"!measurement-equations Block of measurement equations Syntax !measurement-equations Equation1; Equation2; Equation3; ... Syntax with equation labels !measurement-equations Equation1; 'Equation label' Equation2; Equation3; ... Description The !measurement-equations keyword starts a new block of measurement equations; the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object. Example !measurement-equations 'Inflation observations' Infl = 40*(P/P{-1} - 1);","title":"!measurement-equations"},{"location":"StructuralModeling/Slang/%21measurement-equations.html#measurement-equations","text":"Block of measurement equations","title":"!measurement-equations"},{"location":"StructuralModeling/Slang/%21measurement-equations.html#syntax","text":"!measurement-equations Equation1; Equation2; Equation3; ...","title":"Syntax"},{"location":"StructuralModeling/Slang/%21measurement-equations.html#syntax-with-equation-labels","text":"!measurement-equations Equation1; 'Equation label' Equation2; Equation3; ...","title":"Syntax with equation labels"},{"location":"StructuralModeling/Slang/%21measurement-equations.html#description","text":"The !measurement-equations keyword starts a new block of measurement equations; the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object.","title":"Description"},{"location":"StructuralModeling/Slang/%21measurement-equations.html#example","text":"!measurement-equations 'Inflation observations' Infl = 40*(P/P{-1} - 1);","title":"Example"},{"location":"StructuralModeling/Slang/%21measurement-shocks.html","text":"!measurement-shocks Declare names of measurement shocks See {{ slang._names }} for details on declaring model names.","title":"!measurement-shocks"},{"location":"StructuralModeling/Slang/%21measurement-shocks.html#measurement-shocks","text":"Declare names of measurement shocks See {{ slang._names }} for details on declaring model names.","title":"!measurement-shocks"},{"location":"StructuralModeling/Slang/%21measurement-variables.html","text":"!measurement-variables Declare names fo measurement variables See {{ slang._names }} for details on declaring model names.","title":"!measurement-variables"},{"location":"StructuralModeling/Slang/%21measurement-variables.html#measurement-variables","text":"Declare names fo measurement variables See {{ slang._names }} for details on declaring model names.","title":"!measurement-variables"},{"location":"StructuralModeling/Slang/%21parameters.html","text":"!parameters Declare names of parameters See {{ slang._names }} for details on declaring model names.","title":"!parameters"},{"location":"StructuralModeling/Slang/%21parameters.html#parameters","text":"Declare names of parameters See {{ slang._names }} for details on declaring model names.","title":"!parameters"},{"location":"StructuralModeling/Slang/%21postprocessor.html","text":"!postprocessor Postprocessing equations","title":"!postprocessor"},{"location":"StructuralModeling/Slang/%21postprocessor.html#postprocessor","text":"Postprocessing equations","title":"!postprocessor"},{"location":"StructuralModeling/Slang/%21preprocessor.html","text":"!preprocessor Preprocessing equations","title":"!preprocessor"},{"location":"StructuralModeling/Slang/%21preprocessor.html#preprocessor","text":"Preprocessing equations","title":"!preprocessor"},{"location":"StructuralModeling/Slang/%21substitutions.html","text":"!substitutions Define text substitutions Basic syntax for defining substitutions !substitutions name1 := expression1; name2 := expression2; Basic syntax for using substitutions $name1$ Syntax for including substitutions as preprocessing equations Each substitution will be automatically added to !preprocessor equations !substitutions-preprocessor name3 := expression3; name4 := expression4; Syntax for including substitutions as postprocessing equations Each substitution will be automatically added to !postprocessor equations !substitutions-postprocessor name5 := expression5; name6 := expression6; Description The !substitutions starts a block with substitution definitions. The definition of each substitution must begin with the name of the substitution, followed by a colon-equal sign, := , and a text string ended with a semi-colon. The semi-colon is not part of the substitution. Then, each occurence of the name of a substitution enclosed in dollar signs, i.e. $name$ , will be replaced with the text string from the definition of the respective substitution. Some rules for using the substitutions: If more than one source file are specified, substitutions from one file are available in any other file as well. The right-hand-side expressions in the definitions of substitutions can refer to other substitutions; recursive definitions will, off course, not work. The substitutions are literal text substitutions; parenthesise the RHS expressions properly when using the substitutions in math expressions; see Examples below. If included in the preprocessor or postprocessor, the RHS expressions in the substitutions must also comply with the syntax of @Explanatory equations. Examples Using parentheses to preserve precendence of math operations The following snippet of model source !substitution a := ((omega1+omega2)/(omega1+omega2+omega3)); !transition-equations X = $a$^2*Y + (1-$a$^2)*Z; will expand to the following expression !transition-equations X = ((omega1+omega2)/(omega1+omega2+omega3))^2*Y + ... (1-((omega1+omega2)/(omega1+omega2+omega3))^2)*Z; Note that the outermost parentheses are needed to preserve the intended math expression. Substitutions included in preprocessor and/or postprocessor The following snippet of model source !substitutions-postprocessor alpha := (a + b + c)/3; is equivalent to this snippet !substitutions alpha := (a + b + c)/3; !postprocessor alpha = (a + b + c)/3; or also to this ones !substitutions alpha := (a + b + c)/3; !postprocessor alpha = $alpha$;","title":"!substitutions"},{"location":"StructuralModeling/Slang/%21substitutions.html#substitutions","text":"Define text substitutions","title":"!substitutions"},{"location":"StructuralModeling/Slang/%21substitutions.html#basic-syntax-for-defining-substitutions","text":"!substitutions name1 := expression1; name2 := expression2;","title":"Basic syntax for defining substitutions"},{"location":"StructuralModeling/Slang/%21substitutions.html#basic-syntax-for-using-substitutions","text":"$name1$","title":"Basic syntax for using substitutions"},{"location":"StructuralModeling/Slang/%21substitutions.html#syntax-for-including-substitutions-as-preprocessing-equations","text":"Each substitution will be automatically added to !preprocessor equations !substitutions-preprocessor name3 := expression3; name4 := expression4;","title":"Syntax for including substitutions as preprocessing equations"},{"location":"StructuralModeling/Slang/%21substitutions.html#syntax-for-including-substitutions-as-postprocessing-equations","text":"Each substitution will be automatically added to !postprocessor equations !substitutions-postprocessor name5 := expression5; name6 := expression6;","title":"Syntax for including substitutions as postprocessing equations"},{"location":"StructuralModeling/Slang/%21substitutions.html#description","text":"The !substitutions starts a block with substitution definitions. The definition of each substitution must begin with the name of the substitution, followed by a colon-equal sign, := , and a text string ended with a semi-colon. The semi-colon is not part of the substitution. Then, each occurence of the name of a substitution enclosed in dollar signs, i.e. $name$ , will be replaced with the text string from the definition of the respective substitution. Some rules for using the substitutions: If more than one source file are specified, substitutions from one file are available in any other file as well. The right-hand-side expressions in the definitions of substitutions can refer to other substitutions; recursive definitions will, off course, not work. The substitutions are literal text substitutions; parenthesise the RHS expressions properly when using the substitutions in math expressions; see Examples below. If included in the preprocessor or postprocessor, the RHS expressions in the substitutions must also comply with the syntax of @Explanatory equations.","title":"Description"},{"location":"StructuralModeling/Slang/%21substitutions.html#examples","text":"","title":"Examples"},{"location":"StructuralModeling/Slang/%21substitutions.html#using-parentheses-to-preserve-precendence-of-math-operations","text":"The following snippet of model source !substitution a := ((omega1+omega2)/(omega1+omega2+omega3)); !transition-equations X = $a$^2*Y + (1-$a$^2)*Z; will expand to the following expression !transition-equations X = ((omega1+omega2)/(omega1+omega2+omega3))^2*Y + ... (1-((omega1+omega2)/(omega1+omega2+omega3))^2)*Z; Note that the outermost parentheses are needed to preserve the intended math expression.","title":"Using parentheses to preserve precendence of math operations"},{"location":"StructuralModeling/Slang/%21substitutions.html#substitutions-included-in-preprocessor-andor-postprocessor","text":"The following snippet of model source !substitutions-postprocessor alpha := (a + b + c)/3; is equivalent to this snippet !substitutions alpha := (a + b + c)/3; !postprocessor alpha = (a + b + c)/3; or also to this ones !substitutions alpha := (a + b + c)/3; !postprocessor alpha = $alpha$;","title":"Substitutions included in preprocessor and/or postprocessor"},{"location":"StructuralModeling/Slang/%21switch.html","text":"!switch Switch among several cases based on expression. Syntax with an otherwise clause !switch Expr !case Balue1 Block1 !case Balue2 Block2 ... !otherwise OtherwiseBlock !end Syntax without an otherwise clause !switch Expr !case Value1 Block1 !case Value2 Block2 ... !end Description The !switch...!case...!otherwise...!end command works the same way as its counterpart in the Matlab programming language. Use the !switch...!case...!end command to create a larger number of branches of the model code. Which block of code is actually read in and which blocks are discarded depends on which value in the !case clauses matches the value of the !switch expression. This works exactly as the switch...case...end command in Matlab. The expression after the !switch part of the command must must be a valid Matlab expression, and can refer to the model parameters, or to other fields included in the parameter database passed in when you run the model function; see the option 'assign=' . If the expression fails to be matched by any value in the !case clauses, the branch in the !otherwise clause is used. If it is a !switch command without the !otherwise clause, the whole command is discarded. The Matlab function isequal is used to match the !switch expression with the !case values. Example !switch policy_regime !case 'IT' r = rho*r{-1} + (1-rho)*kappa*pie{4} + epsilon; !case 'Managed_exchange_rate' s = s{-1} + epsilon; !case 'Constant_money_growth' m-m{-1} = m{-1}-m{-2} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named policy_regime in it, and use the option 'assign=' to pass the database in. Note that you do not need to declare policy_regime as a parameter in the model file. P = struct( ); P.policy_regime = 'Managed_exchange_rate'; ... m = model('my.model','assign',P); In this case, the managed exchange rate policy rule, s = s{-1} + epsilon; is read in and the rest of the !switch command is discarded. To use another branch of the !switch command you need to re-read the model file again with a different value assigned to the policy_regime field of the input database.","title":"!switch"},{"location":"StructuralModeling/Slang/%21switch.html#switch","text":"Switch among several cases based on expression.","title":"!switch"},{"location":"StructuralModeling/Slang/%21switch.html#syntax-with-an-otherwise-clause","text":"!switch Expr !case Balue1 Block1 !case Balue2 Block2 ... !otherwise OtherwiseBlock !end","title":"Syntax with an otherwise clause"},{"location":"StructuralModeling/Slang/%21switch.html#syntax-without-an-otherwise-clause","text":"!switch Expr !case Value1 Block1 !case Value2 Block2 ... !end","title":"Syntax without an otherwise clause"},{"location":"StructuralModeling/Slang/%21switch.html#description","text":"The !switch...!case...!otherwise...!end command works the same way as its counterpart in the Matlab programming language. Use the !switch...!case...!end command to create a larger number of branches of the model code. Which block of code is actually read in and which blocks are discarded depends on which value in the !case clauses matches the value of the !switch expression. This works exactly as the switch...case...end command in Matlab. The expression after the !switch part of the command must must be a valid Matlab expression, and can refer to the model parameters, or to other fields included in the parameter database passed in when you run the model function; see the option 'assign=' . If the expression fails to be matched by any value in the !case clauses, the branch in the !otherwise clause is used. If it is a !switch command without the !otherwise clause, the whole command is discarded. The Matlab function isequal is used to match the !switch expression with the !case values.","title":"Description"},{"location":"StructuralModeling/Slang/%21switch.html#example","text":"!switch policy_regime !case 'IT' r = rho*r{-1} + (1-rho)*kappa*pie{4} + epsilon; !case 'Managed_exchange_rate' s = s{-1} + epsilon; !case 'Constant_money_growth' m-m{-1} = m{-1}-m{-2} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named policy_regime in it, and use the option 'assign=' to pass the database in. Note that you do not need to declare policy_regime as a parameter in the model file. P = struct( ); P.policy_regime = 'Managed_exchange_rate'; ... m = model('my.model','assign',P); In this case, the managed exchange rate policy rule, s = s{-1} + epsilon; is read in and the rest of the !switch command is discarded. To use another branch of the !switch command you need to re-read the model file again with a different value assigned to the policy_regime field of the input database.","title":"Example"},{"location":"StructuralModeling/Slang/%21transition-equations.html","text":"!transition-equations Block of transition equations Syntax !transition-equations Equation1; Equation2; Equation2; ... Abbreviated syntax !equations Equation1; Equation2; Equation3; ... Syntax with equation labels !transition-equations Equation1; 'Equation label' Equation2; Equation3; ... Description The !transition-equations keyword starts a new block of transition equations (i.e. endogenous equations); the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object. Example !transition-equations 'Euler equation' C{1}/C = R*beta;","title":"!transition-equations"},{"location":"StructuralModeling/Slang/%21transition-equations.html#transition-equations","text":"Block of transition equations","title":"!transition-equations"},{"location":"StructuralModeling/Slang/%21transition-equations.html#syntax","text":"!transition-equations Equation1; Equation2; Equation2; ...","title":"Syntax"},{"location":"StructuralModeling/Slang/%21transition-equations.html#abbreviated-syntax","text":"!equations Equation1; Equation2; Equation3; ...","title":"Abbreviated syntax"},{"location":"StructuralModeling/Slang/%21transition-equations.html#syntax-with-equation-labels","text":"!transition-equations Equation1; 'Equation label' Equation2; Equation3; ...","title":"Syntax with equation labels"},{"location":"StructuralModeling/Slang/%21transition-equations.html#description","text":"The !transition-equations keyword starts a new block of transition equations (i.e. endogenous equations); the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object.","title":"Description"},{"location":"StructuralModeling/Slang/%21transition-equations.html#example","text":"!transition-equations 'Euler equation' C{1}/C = R*beta;","title":"Example"},{"location":"StructuralModeling/Slang/%21transition-shocks.html","text":"!transition-shocks Declare names of transition shocks See {{ slang._names }} for details on declaring model names.","title":"!transition-shocks"},{"location":"StructuralModeling/Slang/%21transition-shocks.html#transition-shocks","text":"Declare names of transition shocks See {{ slang._names }} for details on declaring model names.","title":"!transition-shocks"},{"location":"StructuralModeling/Slang/%21transition-variables.html","text":"!transition-variables Declare names of transition variables Details on declaring model names .","title":"!transition-variables"},{"location":"StructuralModeling/Slang/%21transition-variables.html#transition-variables","text":"Declare names of transition variables Details on declaring model names .","title":"!transition-variables"},{"location":"StructuralModeling/Slang/%21ttrend.html","text":"!ttrend Linear time trend in deterministic trend equations Syntax !ttrend Description Example !dtrends log(Y) += a*!ttrend;","title":"!ttrend"},{"location":"StructuralModeling/Slang/%21ttrend.html#ttrend","text":"Linear time trend in deterministic trend equations","title":"!ttrend"},{"location":"StructuralModeling/Slang/%21ttrend.html#syntax","text":"!ttrend","title":"Syntax"},{"location":"StructuralModeling/Slang/%21ttrend.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Slang/%21ttrend.html#example","text":"!dtrends log(Y) += a*!ttrend;","title":"Example"},{"location":"StructuralModeling/Slang/alias.html","text":"|| Separate alias from the rest of name or equation description Syntax in name descriptions \"Description || Alias\" name Syntax in equation labels \"Description || Alias\" equation; Description When used in descriptions of variables, shocks, and parameters, or in equation labels, the double exclamation mark starts an alias (but the exlamation marks are not included in it). The alias can be used to specify, for example, a LaTeX code associated with the variable, shock, parameter, or equation. The aliases can be retrieved from the model code by using the appropriate query in the function Model/access . Example Based on this snippet of a model source file, !transition-variables \"Output gap || $\\hat y_t$\" y_gap in the resulting model object, the description of the variable y_gap will be \"Output gap\" while its alias will be \" \\(\\hat y_t\\) \".","title":"||"},{"location":"StructuralModeling/Slang/alias.html#_1","text":"Separate alias from the rest of name or equation description","title":"||"},{"location":"StructuralModeling/Slang/alias.html#syntax-in-name-descriptions","text":"\"Description || Alias\" name","title":"Syntax in name descriptions"},{"location":"StructuralModeling/Slang/alias.html#syntax-in-equation-labels","text":"\"Description || Alias\" equation;","title":"Syntax in equation labels"},{"location":"StructuralModeling/Slang/alias.html#description","text":"When used in descriptions of variables, shocks, and parameters, or in equation labels, the double exclamation mark starts an alias (but the exlamation marks are not included in it). The alias can be used to specify, for example, a LaTeX code associated with the variable, shock, parameter, or equation. The aliases can be retrieved from the model code by using the appropriate query in the function Model/access .","title":"Description"},{"location":"StructuralModeling/Slang/alias.html#example","text":"Based on this snippet of a model source file, !transition-variables \"Output gap || $\\hat y_t$\" y_gap in the resulting model object, the description of the variable y_gap will be \"Output gap\" while its alias will be \" \\(\\hat y_t\\) \".","title":"Example"},{"location":"StructuralModeling/Slang/block-comment.html","text":"%{...%} Block comments Syntax %{ ... ... ... %} Description Anything between the opening block comment sign, %{ , and the closing block comment sign, %} , is discarded. Unlike in Matlab, the opening and closing block comment signs do not need to stand alone on otherwise blank lines. You can even have block comments contained within a single line. Example !transition_equations x = rho*x{-1} %{ this is a valid block comment %} + epsilon;","title":"%{...%}"},{"location":"StructuralModeling/Slang/block-comment.html#_1","text":"Block comments","title":"%{...%}"},{"location":"StructuralModeling/Slang/block-comment.html#syntax","text":"%{ ... ... ... %}","title":"Syntax"},{"location":"StructuralModeling/Slang/block-comment.html#description","text":"Anything between the opening block comment sign, %{ , and the closing block comment sign, %} , is discarded. Unlike in Matlab, the opening and closing block comment signs do not need to stand alone on otherwise blank lines. You can even have block comments contained within a single line.","title":"Description"},{"location":"StructuralModeling/Slang/block-comment.html#example","text":"!transition_equations x = rho*x{-1} %{ this is a valid block comment %} + epsilon;","title":"Example"},{"location":"StructuralModeling/Slang/diff.html","text":"diff First difference pseudofunction Syntax diff(Expr) diff(Expr,K) Description If the input argument K is not specified, this pseudofunction expands to ((Expr)-(Expr{-1})) If the input argument K is specified, it expands to ((Expr)-(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively. Example These two lines diff(Z) diff(log(X{1})-log(Y{-1}),-2) will expand to ((Z)-(Z{-1})) ((log(X{1})-log(Y{-1}))-(log(X{-1})-log(Y{-3})))","title":"diff"},{"location":"StructuralModeling/Slang/diff.html#diff","text":"First difference pseudofunction","title":"diff"},{"location":"StructuralModeling/Slang/diff.html#syntax","text":"diff(Expr) diff(Expr,K)","title":"Syntax"},{"location":"StructuralModeling/Slang/diff.html#description","text":"If the input argument K is not specified, this pseudofunction expands to ((Expr)-(Expr{-1})) If the input argument K is specified, it expands to ((Expr)-(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively.","title":"Description"},{"location":"StructuralModeling/Slang/diff.html#example","text":"These two lines diff(Z) diff(log(X{1})-log(Y{-1}),-2) will expand to ((Z)-(Z{-1})) ((log(X{1})-log(Y{-1}))-(log(X{-1})-log(Y{-3})))","title":"Example"},{"location":"StructuralModeling/Slang/difflog.html","text":"difflog First log-difference pseudofunction Syntax difflog(Expr) difflog(Expr,K) Description If the input argument K is not specified, this pseudofunction expands to (log(Expr)-log(Expr{-1})) If the input argument K is specified, it expands to (log(Expr)-log(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively. Example The following two lines of code difflog(Z) difflog(X{1}/Y{-1},-2) will expand to (log(Z)-log(Z{-1})) (log(X{1}/Y{-1})-log(X{-1}/Y{-3}))","title":"difflog"},{"location":"StructuralModeling/Slang/difflog.html#difflog","text":"First log-difference pseudofunction","title":"difflog"},{"location":"StructuralModeling/Slang/difflog.html#syntax","text":"difflog(Expr) difflog(Expr,K)","title":"Syntax"},{"location":"StructuralModeling/Slang/difflog.html#description","text":"If the input argument K is not specified, this pseudofunction expands to (log(Expr)-log(Expr{-1})) If the input argument K is specified, it expands to (log(Expr)-log(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively.","title":"Description"},{"location":"StructuralModeling/Slang/difflog.html#example","text":"The following two lines of code difflog(Z) difflog(X{1}/Y{-1},-2) will expand to (log(Z)-log(Z{-1})) (log(X{1}/Y{-1})-log(X{-1}/Y{-3}))","title":"Example"},{"location":"StructuralModeling/Slang/equations.html","text":"Writing model equations Model source code can contain the following types of model equations Model equation type Keyword Remark Transition equations !transition-equations May be abbreviated to !equations Measurement equations !measurement-equations Deterministic trends !dtrends Dynamic links !links Preprocessing equations !preprocessor Not a structural part of the model Postprocessing equations !postprocessor Not a structural part of the model","title":"Writing model equations"},{"location":"StructuralModeling/Slang/equations.html#writing-model-equations","text":"Model source code can contain the following types of model equations Model equation type Keyword Remark Transition equations !transition-equations May be abbreviated to !equations Measurement equations !measurement-equations Deterministic trends !dtrends Dynamic links !links Preprocessing equations !preprocessor Not a structural part of the model Postprocessing equations !postprocessor Not a structural part of the model","title":"Writing model equations"},{"location":"StructuralModeling/Slang/interp.html","text":"<...> Interpolation. Syntax <Expr> Description The expression Expr enclosed within a pair of angle braces, <...> , is evaluated as a Matlab expression, and converted to a character string. The expression may refer to parameters passed into the function model , or to !for loop control variable names. The expression must evaluate to a scalar number, a logical scalar, or character string. Example The following line of code pie{<K>} which is assumed to be part of a model file named my.model , will expand to pie{3} in either of the following two calls to the function model : model('my.model','K=',3); P = struct( ); P.K = 3; model('my.model','assign=',P); Example The following !for loop !for < 2 : 4 > !do x? = x<?-1>{-1}; !end will expand to x2 = x1{-1}; x3 = x2{-1}; x4 = x3{-1};","title":"<...>"},{"location":"StructuralModeling/Slang/interp.html#_1","text":"Interpolation.","title":"&lt;...&gt;"},{"location":"StructuralModeling/Slang/interp.html#syntax","text":"<Expr>","title":"Syntax"},{"location":"StructuralModeling/Slang/interp.html#description","text":"The expression Expr enclosed within a pair of angle braces, <...> , is evaluated as a Matlab expression, and converted to a character string. The expression may refer to parameters passed into the function model , or to !for loop control variable names. The expression must evaluate to a scalar number, a logical scalar, or character string.","title":"Description"},{"location":"StructuralModeling/Slang/interp.html#example","text":"The following line of code pie{<K>} which is assumed to be part of a model file named my.model , will expand to pie{3} in either of the following two calls to the function model : model('my.model','K=',3); P = struct( ); P.K = 3; model('my.model','assign=',P);","title":"Example"},{"location":"StructuralModeling/Slang/interp.html#example_1","text":"The following !for loop !for < 2 : 4 > !do x? = x<?-1>{-1}; !end will expand to x2 = x1{-1}; x3 = x2{-1}; x4 = x3{-1};","title":"Example"},{"location":"StructuralModeling/Slang/line-comment.html","text":"% Line comments Syntax % Anything from the percent sign until the end of line is discarded. Description Example","title":"%"},{"location":"StructuralModeling/Slang/line-comment.html#_1","text":"Line comments","title":"%"},{"location":"StructuralModeling/Slang/line-comment.html#syntax","text":"% Anything from the percent sign until the end of line is discarded.","title":"Syntax"},{"location":"StructuralModeling/Slang/line-comment.html#description","text":"","title":"Description"},{"location":"StructuralModeling/Slang/line-comment.html#example","text":"","title":"Example"},{"location":"StructuralModeling/Slang/min.html","text":"min Define loss function for optimal policy Syntax min(Disc) Expr; Syntax for exact non-linear simulations min#(Disc) Expr; Description The loss function must be types as one of the transition equations. The Disc is a parameter or an expression defining the discount factor (applied to future dates), and the expression Expr defines the loss fuction. The Disc expression must not contain a comma. If you use the min#(Disc) syntax, all equations created by differentiating the lagrangian w.r.t. individual variables will be earmarked for exact nonlinear simulations provided the respective derivative is nonzero. This only makes sense if the loss function is other than quadratic, and hence its derivatives are nonlinear. There are two types of optimal policy that can be calculated: time-consistent discretionary policy, and time-inconsistent optimal policy with commitment. Use the option 'optimal=' in the function model at the time of loading the model file to switch between these two types of policy; the option can be either 'discretion' (default) or 'commitment' . Example This is a simple model file with a Phillips curve and a quadratic loss function. !transition-variables x, pi !transition-shocks u !parameters alpha, beta, gamma !transition-equations min(beta) pi^2 + lambda*x^2; pi = alpha*pi{-1} + (1-alpha)*pi{1} + gamma*y + u;","title":"min"},{"location":"StructuralModeling/Slang/min.html#min","text":"Define loss function for optimal policy","title":"min"},{"location":"StructuralModeling/Slang/min.html#syntax","text":"min(Disc) Expr;","title":"Syntax"},{"location":"StructuralModeling/Slang/min.html#syntax-for-exact-non-linear-simulations","text":"min#(Disc) Expr;","title":"Syntax for exact non-linear simulations"},{"location":"StructuralModeling/Slang/min.html#description","text":"The loss function must be types as one of the transition equations. The Disc is a parameter or an expression defining the discount factor (applied to future dates), and the expression Expr defines the loss fuction. The Disc expression must not contain a comma. If you use the min#(Disc) syntax, all equations created by differentiating the lagrangian w.r.t. individual variables will be earmarked for exact nonlinear simulations provided the respective derivative is nonzero. This only makes sense if the loss function is other than quadratic, and hence its derivatives are nonlinear. There are two types of optimal policy that can be calculated: time-consistent discretionary policy, and time-inconsistent optimal policy with commitment. Use the option 'optimal=' in the function model at the time of loading the model file to switch between these two types of policy; the option can be either 'discretion' (default) or 'commitment' .","title":"Description"},{"location":"StructuralModeling/Slang/min.html#example","text":"This is a simple model file with a Phillips curve and a quadratic loss function. !transition-variables x, pi !transition-shocks u !parameters alpha, beta, gamma !transition-equations min(beta) pi^2 + lambda*x^2; pi = alpha*pi{-1} + (1-alpha)*pi{1} + gamma*y + u;","title":"Example"},{"location":"StructuralModeling/Slang/model-files.html","text":"Creating model source code Guideline for writing and structuring model source code","title":"Creating model source code"},{"location":"StructuralModeling/Slang/model-files.html#creating-model-source-code","text":"Guideline for writing and structuring model source code","title":"Creating model source code"},{"location":"StructuralModeling/Slang/movavg.html","text":"movavg Moving average pseudofunction Syntax movavg(Expr) movavg(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving average of the last K periods (including the current period), i.e. (((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)})/-K) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving average of the next K periods ahead (including the current period), i.e. (((Expr)+(Expr{1})+ ... +(Expr{K-1})/K) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movavg(Z) movavg(Z,-3) movavg(X+Y{-1},2) will expand to (((Z)+(Z{-1})+(Z{-2})+(Z{-3}))/4) (((Z)+(Z{-1})+(Z{-2}))/3) (((X+Y{-1})+(X{1}+Y))/2)","title":"movavg"},{"location":"StructuralModeling/Slang/movavg.html#movavg","text":"Moving average pseudofunction","title":"movavg"},{"location":"StructuralModeling/Slang/movavg.html#syntax","text":"movavg(Expr) movavg(Expr,K)","title":"Syntax"},{"location":"StructuralModeling/Slang/movavg.html#description","text":"If the second input argument, K , is negative, this function expands to the moving average of the last K periods (including the current period), i.e. (((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)})/-K) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving average of the next K periods ahead (including the current period), i.e. (((Expr)+(Expr{1})+ ... +(Expr{K-1})/K) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"StructuralModeling/Slang/movavg.html#example","text":"The following three lines movavg(Z) movavg(Z,-3) movavg(X+Y{-1},2) will expand to (((Z)+(Z{-1})+(Z{-2})+(Z{-3}))/4) (((Z)+(Z{-1})+(Z{-2}))/3) (((X+Y{-1})+(X{1}+Y))/2)","title":"Example"},{"location":"StructuralModeling/Slang/movgeom.html","text":"movavg Moving geometric average pseudofunction Syntax movgeom(Expr) movgeom(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving geometric average of the last K periods (including the current period), i.e. (((Expr)*(Expr{-1})* ... *(Expr{-(K-1)})^(1/-K)) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving geometric average of the next K periods ahead (including the current period), i.e. (((Expr)*(Expr{1})* ... *(Expr{K-1})^(1/K)) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movgeom(Z) movgeom(Z,-3) movgeom(X+Y{-1},2) will expand to (((Z)*(Z{-1})*(Z{-2})*(Z{-3}))^(1/4)) (((Z)*(Z{-1})*(Z{-2}))^(1/3)) (((X+Y{-1})*(X{1}+Y))^(1/2))","title":"movavg"},{"location":"StructuralModeling/Slang/movgeom.html#movavg","text":"Moving geometric average pseudofunction","title":"movavg"},{"location":"StructuralModeling/Slang/movgeom.html#syntax","text":"movgeom(Expr) movgeom(Expr,K)","title":"Syntax"},{"location":"StructuralModeling/Slang/movgeom.html#description","text":"If the second input argument, K , is negative, this function expands to the moving geometric average of the last K periods (including the current period), i.e. (((Expr)*(Expr{-1})* ... *(Expr{-(K-1)})^(1/-K)) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving geometric average of the next K periods ahead (including the current period), i.e. (((Expr)*(Expr{1})* ... *(Expr{K-1})^(1/K)) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"StructuralModeling/Slang/movgeom.html#example","text":"The following three lines movgeom(Z) movgeom(Z,-3) movgeom(X+Y{-1},2) will expand to (((Z)*(Z{-1})*(Z{-2})*(Z{-3}))^(1/4)) (((Z)*(Z{-1})*(Z{-2}))^(1/3)) (((X+Y{-1})*(X{1}+Y))^(1/2))","title":"Example"},{"location":"StructuralModeling/Slang/movprod.html","text":"movsum Moving product pseudofunction Syntax movprod(Expr) movprod(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving product of the last K periods (including the current period), i.e. ((Expr)*(Expr{-1})* ... *(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving product of the next K periods ahead (including the current period), i.e. ((Expr)*(Expr{1})* ... *(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movprod(Z) movprod(Z,-3) movprod(X+Y{-1},2) will expand to ((Z)*(Z{-1})*(Z{-2})*(Z{-3})) ((Z)*(Z{-1})*(Z{-2})) ((X+Y{-1})*(X{1}+Y))","title":"movsum"},{"location":"StructuralModeling/Slang/movprod.html#movsum","text":"Moving product pseudofunction","title":"movsum"},{"location":"StructuralModeling/Slang/movprod.html#syntax","text":"movprod(Expr) movprod(Expr,K)","title":"Syntax"},{"location":"StructuralModeling/Slang/movprod.html#description","text":"If the second input argument, K , is negative, this function expands to the moving product of the last K periods (including the current period), i.e. ((Expr)*(Expr{-1})* ... *(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving product of the next K periods ahead (including the current period), i.e. ((Expr)*(Expr{1})* ... *(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"StructuralModeling/Slang/movprod.html#example","text":"The following three lines movprod(Z) movprod(Z,-3) movprod(X+Y{-1},2) will expand to ((Z)*(Z{-1})*(Z{-2})*(Z{-3})) ((Z)*(Z{-1})*(Z{-2})) ((X+Y{-1})*(X{1}+Y))","title":"Example"},{"location":"StructuralModeling/Slang/movsum.html","text":"movsum Moving sum pseudofunction Syntax movsum(Expr) movsum(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving sum of the last K periods (including the current period), i.e. ((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving sum of the next K periods ahead (including the current period), i.e. ((Expr)+(Expr{1})+ ... +(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movsum(Z) movsum(Z,-3) movsum(X+Y{-1},2) will expand to ((Z)+(Z{-1})+(Z{-2})+(Z{-3})) ((Z)+(Z{-1})+(Z{-2})) ((X+Y{-1})+(X{1}+Y))","title":"movsum"},{"location":"StructuralModeling/Slang/movsum.html#movsum","text":"Moving sum pseudofunction","title":"movsum"},{"location":"StructuralModeling/Slang/movsum.html#syntax","text":"movsum(Expr) movsum(Expr,K)","title":"Syntax"},{"location":"StructuralModeling/Slang/movsum.html#description","text":"If the second input argument, K , is negative, this function expands to the moving sum of the last K periods (including the current period), i.e. ((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving sum of the next K periods ahead (including the current period), i.e. ((Expr)+(Expr{1})+ ... +(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"StructuralModeling/Slang/movsum.html#example","text":"The following three lines movsum(Z) movsum(Z,-3) movsum(X+Y{-1},2) will expand to ((Z)+(Z{-1})+(Z{-2})+(Z{-3})) ((Z)+(Z{-1})+(Z{-2})) ((X+Y{-1})+(X{1}+Y))","title":"Example"},{"location":"StructuralModeling/Slang/names.html","text":"Declaring model names Declare names of model quantities: Variables, shocks, parameters Each model quantity (variable, shock, parameter) needs to be declared, i.e. listed under an appropriate heading. Model source code can contain the following types of model names Model name type Keyword Remark Transition variables !transition-variables May be abbreviated to !variables Transition shocks !transition-shocks May be abbreviated to !shocks Measurement variables !measurement-variables Measurement shocks !measurement-shocks Parameters !parameters Exogenous variables !exogenous-variables May only be used in !dtrends equations Syntax List the names under the respective keyword. The names are separated by white spaces, commas or semicolons, and may be given optional annotations. An annotation is enclosed in double quotes and immediately precedes the respective name. !transition-variables variableName, variableName, ... \"Description of the variable\" variableName ... Example: Declare transition variables The following section declares three variables, pie , y , and re !transition-variables pie, \"Real output\" y \"Real exchange rate\" re Example: Split declaration Declaration of a particular type of model names can be split into any number of sections (as long as each model name is declared only once). The following snippet is equivalent to the previous example: !transition-variables pie !transition-variables \"Real output\" y !transition-variables \"Real exchange rate\" re This is useful when you use some of the control structures, such as !if , !switch.md , or !for , or when you split the model source code into multiple source files.","title":"Declaring model names"},{"location":"StructuralModeling/Slang/names.html#declaring-model-names","text":"Declare names of model quantities: Variables, shocks, parameters Each model quantity (variable, shock, parameter) needs to be declared, i.e. listed under an appropriate heading. Model source code can contain the following types of model names Model name type Keyword Remark Transition variables !transition-variables May be abbreviated to !variables Transition shocks !transition-shocks May be abbreviated to !shocks Measurement variables !measurement-variables Measurement shocks !measurement-shocks Parameters !parameters Exogenous variables !exogenous-variables May only be used in !dtrends equations","title":"Declaring model names"},{"location":"StructuralModeling/Slang/names.html#syntax","text":"List the names under the respective keyword. The names are separated by white spaces, commas or semicolons, and may be given optional annotations. An annotation is enclosed in double quotes and immediately precedes the respective name. !transition-variables variableName, variableName, ... \"Description of the variable\" variableName ...","title":"Syntax"},{"location":"StructuralModeling/Slang/names.html#example-declare-transition-variables","text":"The following section declares three variables, pie , y , and re !transition-variables pie, \"Real output\" y \"Real exchange rate\" re","title":"Example: Declare transition variables"},{"location":"StructuralModeling/Slang/names.html#example-split-declaration","text":"Declaration of a particular type of model names can be split into any number of sections (as long as each model name is declared only once). The following snippet is equivalent to the previous example: !transition-variables pie !transition-variables \"Real output\" y !transition-variables \"Real exchange rate\" re This is useful when you use some of the control structures, such as !if , !switch.md , or !for , or when you split the model source code into multiple source files.","title":"Example: Split declaration"},{"location":"StructuralModeling/Slang/pct.html","text":"pct Percent change Syntax pct(expression) pct(expression, k) Description If the input argument k is not specified, this pseudofunction expands to (100*((expression)/(expression{-1})-1)) If the input argument k is specified, it expands to (100*((expression)/(expression{k})-1)) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively. Examples The following two lines pct(z) pct(x+y, -2) will expand to (100*((z)/(z{-1})-1)) (100*((x+y)/(x{-2}+y{-2})-1))","title":"pct"},{"location":"StructuralModeling/Slang/pct.html#pct","text":"Percent change","title":"pct"},{"location":"StructuralModeling/Slang/pct.html#syntax","text":"pct(expression) pct(expression, k)","title":"Syntax"},{"location":"StructuralModeling/Slang/pct.html#description","text":"If the input argument k is not specified, this pseudofunction expands to (100*((expression)/(expression{-1})-1)) If the input argument k is specified, it expands to (100*((expression)/(expression{k})-1)) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively.","title":"Description"},{"location":"StructuralModeling/Slang/pct.html#examples","text":"The following two lines pct(z) pct(x+y, -2) will expand to (100*((z)/(z{-1})-1)) (100*((x+y)/(x{-2}+y{-2})-1))","title":"Examples"},{"location":"StructuralModeling/Slang/roc.html","text":"roc Gross rate of change pseudofunction Syntax roc(expression) roc(expression, k) Description If the input argument k is not specified, this pseudofunction expands to ((expression)/(expression{-1})) If the input argument k is specified, it expands to ((expression)/(expression{k})) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively. Examples The following two lines roc(z) roc(x+y,-2) will expand to ((Z)/(Z{-1})) ((X+Y)/(X{-2}+Y{-2}))","title":"roc"},{"location":"StructuralModeling/Slang/roc.html#roc","text":"Gross rate of change pseudofunction","title":"roc"},{"location":"StructuralModeling/Slang/roc.html#syntax","text":"roc(expression) roc(expression, k)","title":"Syntax"},{"location":"StructuralModeling/Slang/roc.html#description","text":"If the input argument k is not specified, this pseudofunction expands to ((expression)/(expression{-1})) If the input argument k is specified, it expands to ((expression)/(expression{k})) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively.","title":"Description"},{"location":"StructuralModeling/Slang/roc.html#examples","text":"The following two lines roc(z) roc(x+y,-2) will expand to ((Z)/(Z{-1})) ((X+Y)/(X{-2}+Y{-2}))","title":"Examples"},{"location":"StructuralModeling/Slang/shift.html","text":"{...} Lag or lead Syntax VariableName{-lag} VariableName{lead} VariableName{+lead} Description To create a lag or a lead of a variable, use a pair of curly brackets. Example !transition-equations x = rho*x{-1} + epsilon_x; pi = 1/2*pie{-1} + 1/2*pie{1} + gamma*y + epsilon_pi;","title":"{...}"},{"location":"StructuralModeling/Slang/shift.html#_1","text":"Lag or lead","title":"{...}"},{"location":"StructuralModeling/Slang/shift.html#syntax","text":"VariableName{-lag} VariableName{lead} VariableName{+lead}","title":"Syntax"},{"location":"StructuralModeling/Slang/shift.html#description","text":"To create a lag or a lead of a variable, use a pair of curly brackets.","title":"Description"},{"location":"StructuralModeling/Slang/shift.html#example","text":"!transition-equations x = rho*x{-1} + epsilon_x; pi = 1/2*pie{-1} + 1/2*pie{1} + gamma*y + epsilon_pi;","title":"Example"},{"location":"StructuralModeling/Slang/steady-ref.html","text":"& Reference to the steady-state level of a variable Syntax &variableName &variableName{K} Description Use the & sign in front of a variable name to create a reference to that variable's steady-state level in transition or measurement equations. Steady-state references may only be used in nonlinear models. The steady-state reference can include a time shift (a lag or a lead), K . In that case, the steady-state value will be adjusted for steady-state growth backward or forward accordingly. The steady-state reference will be replaced: with the variable itself at the time the model's steady state is being calculated, i.e. when calling the function Model/steady ; with the actually assigned steady-state value at the time the model is being solved, i.e. when calling the function 'Model/solve' '. Examples x = rho*x{-1} + (1-rho)*&x + epsilon_x !! x = 1;","title":"&"},{"location":"StructuralModeling/Slang/steady-ref.html#_1","text":"Reference to the steady-state level of a variable","title":"&amp;"},{"location":"StructuralModeling/Slang/steady-ref.html#syntax","text":"&variableName &variableName{K}","title":"Syntax"},{"location":"StructuralModeling/Slang/steady-ref.html#description","text":"Use the & sign in front of a variable name to create a reference to that variable's steady-state level in transition or measurement equations. Steady-state references may only be used in nonlinear models. The steady-state reference can include a time shift (a lag or a lead), K . In that case, the steady-state value will be adjusted for steady-state growth backward or forward accordingly. The steady-state reference will be replaced: with the variable itself at the time the model's steady state is being calculated, i.e. when calling the function Model/steady ; with the actually assigned steady-state value at the time the model is being solved, i.e. when calling the function 'Model/solve' '.","title":"Description"},{"location":"StructuralModeling/Slang/steady-ref.html#examples","text":"x = rho*x{-1} + (1-rho)*&x + epsilon_x !! x = 1;","title":"Examples"},{"location":"StructuralModeling/Slang/steady-version.html","text":"!! Steady-state versions of equations Syntax dynamicEquation !! steadyEquation; Description For each transition or measurement equation, you can provide a separate steady-state version of it. The steady-state version is used when you run the functions steady and checkSteady , the latter unless you change the option EquationSwitch= . This is useful when you can substantially simplify some parts of the full dynamic equations, split the model into sequential blocks, and help therefore the numerical solver to achieve faster and possibly laso more accurate results. Examples log(a) = 0.8*log(a{-1}) + (1-0.8)*2 + epsilon_a !! log(a) = 2; The following steady state version of an Euler equation will be valid only in stationary models where we can safely remove lags and leads. lambda = lambda{1}*(1+r)*beta !! r = 1/beta - 1;","title":"!!"},{"location":"StructuralModeling/Slang/steady-version.html#_1","text":"Steady-state versions of equations","title":"!!"},{"location":"StructuralModeling/Slang/steady-version.html#syntax","text":"dynamicEquation !! steadyEquation;","title":"Syntax"},{"location":"StructuralModeling/Slang/steady-version.html#description","text":"For each transition or measurement equation, you can provide a separate steady-state version of it. The steady-state version is used when you run the functions steady and checkSteady , the latter unless you change the option EquationSwitch= . This is useful when you can substantially simplify some parts of the full dynamic equations, split the model into sequential blocks, and help therefore the numerical solver to achieve faster and possibly laso more accurate results.","title":"Description"},{"location":"StructuralModeling/Slang/steady-version.html#examples","text":"log(a) = 0.8*log(a{-1}) + (1-0.8)*2 + epsilon_a !! log(a) = 2; The following steady state version of an Euler equation will be valid only in stationary models where we can safely remove lags and leads. lambda = lambda{1}*(1+r)*beta !! r = 1/beta - 1;","title":"Examples"},{"location":"TimeSeriesModeling/index.html","text":"Overview of time series modeling tools","title":"Overview of time series modeling tools"},{"location":"TimeSeriesModeling/index.html#overview-of-time-series-modeling-tools","text":"","title":"Overview of time series modeling tools"},{"location":"TimeSeriesModeling/Armani/index.html","text":"Overview of ARMA processes: @Armani objects","title":"Overview of ARMA processes: `@Armani` objects"},{"location":"TimeSeriesModeling/Armani/index.html#overview-of-arma-processes-armani-objects","text":"","title":"Overview of ARMA processes: @Armani objects"},{"location":"TimeSeriesModeling/Dynafit/index.html","text":"Overview of dynamic factor models: @Dynafit objects","title":"Overview of dynamic factor models: `@Dynafit` objects"},{"location":"TimeSeriesModeling/Dynafit/index.html#overview-of-dynamic-factor-models-dynafit-objects","text":"","title":"Overview of dynamic factor models: @Dynafit objects"},{"location":"TimeSeriesModeling/Dynafit/estimate.html","text":"estimate Estimate Dynamo using static principal components Syntax [a, outputDb, contribDb, range] = estimate(a, inputDb, range, [R, Q], ___) Input arguments a [ Dynamo ] Empty Dynamo object. inputDb [ struct ] Input database. range [ numeric ] Estimation range. R [ numeric ] Selection criterion for the number of factors: Minimum requested proportion of input data volatility explained by the factors Q [ numeric ] Selection criterion for the number of factors: Maximum number of factors Output arguments A [ Dynamo ] Estimated Dynamo object. outputDb [ struct ] Output database with the observed series, their common components ( common_? ), the estimates of the factors ( factor? ), the idiosyncratic residuals ( res_? ) and the factor residuals ( res_factor? ). contribDb [ struct ] Contributions of the individual input series to the estimated factors. Options Cross=true [ true | false | numeric ] Keep off-diagonal elements in the covariance matrix of idiosyncratic residuals; if false all cross-covariances are reset to zero; if a number between zero and one, all cross-covariances are multiplied by that number Order=1 [ numeric ] Order of the VAR for factors Rank=Inf [ numeric ] Restriction on the rank of the factor VAR residuals. Description Examples","title":"estimate"},{"location":"TimeSeriesModeling/Dynafit/estimate.html#estimate","text":"Estimate Dynamo using static principal components","title":"estimate"},{"location":"TimeSeriesModeling/Dynafit/estimate.html#syntax","text":"[a, outputDb, contribDb, range] = estimate(a, inputDb, range, [R, Q], ___)","title":"Syntax"},{"location":"TimeSeriesModeling/Dynafit/estimate.html#input-arguments","text":"a [ Dynamo ] Empty Dynamo object. inputDb [ struct ] Input database. range [ numeric ] Estimation range. R [ numeric ] Selection criterion for the number of factors: Minimum requested proportion of input data volatility explained by the factors Q [ numeric ] Selection criterion for the number of factors: Maximum number of factors","title":"Input arguments"},{"location":"TimeSeriesModeling/Dynafit/estimate.html#output-arguments","text":"A [ Dynamo ] Estimated Dynamo object. outputDb [ struct ] Output database with the observed series, their common components ( common_? ), the estimates of the factors ( factor? ), the idiosyncratic residuals ( res_? ) and the factor residuals ( res_factor? ). contribDb [ struct ] Contributions of the individual input series to the estimated factors.","title":"Output arguments"},{"location":"TimeSeriesModeling/Dynafit/estimate.html#options","text":"Cross=true [ true | false | numeric ] Keep off-diagonal elements in the covariance matrix of idiosyncratic residuals; if false all cross-covariances are reset to zero; if a number between zero and one, all cross-covariances are multiplied by that number Order=1 [ numeric ] Order of the VAR for factors Rank=Inf [ numeric ] Restriction on the rank of the factor VAR residuals.","title":"Options"},{"location":"TimeSeriesModeling/Dynafit/estimate.html#description","text":"","title":"Description"},{"location":"TimeSeriesModeling/Dynafit/estimate.html#examples","text":"","title":"Examples"},{"location":"TimeSeriesModeling/Dynafit/kalmanFilter.html","text":"filter Re-estimate factors by Kalman filtering data taking Dynamo coefficients as given ## Syntax [outputDb, a, info] = kalmanFilter(a, inputDb, range, ___) ## Input arguments a [ Dynamo ] Estimated Dynamo object. inputDb [ struct ] Input database or tseries object with the Dynamo observables. range [ Dater ] Filter date range. ## Output arguments outputDb [ struct ] Output databank. a [ Dynamo ] Dynamo object. ## Options Cross=true [ true | false | numeric ] Run the filter with the off-diagonal elements in the covariance matrix of idiosyncratic residuals; if false all cross-covariances are reset to zero; if a number between zero and one, all cross-covariances are multiplied by that number. InvFunc=\"auto\" [ \"auto\" | function_handle ] Inversion method for the FMSE matrices. MeanOnly=false [ true | false ] Return only mean data, i.e. point estimates. Persist=false [ true | false ] If filter or forecast is used with Persist=true for the first time, the forecast MSE matrices and their inverses will be stored; subsequent calls of the filter or forecast functions will re-use these matrices until filter or forecast is called with this option set to false . Tolerance=0 [ numeric ] Numerical tolerance under which two FMSE matrices computed in two consecutive periods will be treated as equal and their inversions will be re-used, not re-computed. ## Description It is the user's responsibility to make sure that filter and forecast called with Persist= set to true are valid, i.e. that the previously computed FMSE matrices can be really re-used in the current run. ## Example","title":"filter"},{"location":"TimeSeriesModeling/Dynafit/kalmanFilter.html#filter","text":"Re-estimate factors by Kalman filtering data taking Dynamo coefficients as given ## Syntax [outputDb, a, info] = kalmanFilter(a, inputDb, range, ___) ## Input arguments a [ Dynamo ] Estimated Dynamo object. inputDb [ struct ] Input database or tseries object with the Dynamo observables. range [ Dater ] Filter date range. ## Output arguments outputDb [ struct ] Output databank. a [ Dynamo ] Dynamo object. ## Options Cross=true [ true | false | numeric ] Run the filter with the off-diagonal elements in the covariance matrix of idiosyncratic residuals; if false all cross-covariances are reset to zero; if a number between zero and one, all cross-covariances are multiplied by that number. InvFunc=\"auto\" [ \"auto\" | function_handle ] Inversion method for the FMSE matrices. MeanOnly=false [ true | false ] Return only mean data, i.e. point estimates. Persist=false [ true | false ] If filter or forecast is used with Persist=true for the first time, the forecast MSE matrices and their inverses will be stored; subsequent calls of the filter or forecast functions will re-use these matrices until filter or forecast is called with this option set to false . Tolerance=0 [ numeric ] Numerical tolerance under which two FMSE matrices computed in two consecutive periods will be treated as equal and their inversions will be re-used, not re-computed. ## Description It is the user's responsibility to make sure that filter and forecast called with Persist= set to true are valid, i.e. that the previously computed FMSE matrices can be really re-used in the current run. ## Example","title":"filter"},{"location":"TimeSeriesModeling/PanelVAR/index.html","text":"Panel VAR models: Extension to @VAR and @SVAR objects","title":"Panel VAR models: Extension to `@VAR` and `@SVAR` objects"},{"location":"TimeSeriesModeling/PanelVAR/index.html#panel-var-models-extension-to-var-and-svar-objects","text":"","title":"Panel VAR models: Extension to @VAR and @SVAR objects"},{"location":"TimeSeriesModeling/ParamArmani/index.html","text":"Overview of parameterized ARMA models: @ParamArmani objects","title":"Overview of parameterized ARMA models: `@ParamArmani` objects"},{"location":"TimeSeriesModeling/ParamArmani/index.html#overview-of-parameterized-arma-models-paramarmani-objects","text":"","title":"Overview of parameterized ARMA models: @ParamArmani objects"},{"location":"TimeSeriesModeling/SVAR/index.html","text":"Overview of structural VAR models: @SVAR objects","title":"Overview of structural VAR models: `@SVAR` objects"},{"location":"TimeSeriesModeling/SVAR/index.html#overview-of-structural-var-models-svar-objects","text":"","title":"Overview of structural VAR models: @SVAR objects"},{"location":"TimeSeriesModeling/VAR/index.html","text":"Overview of VAR models","title":"Overview of VAR models"},{"location":"TimeSeriesModeling/VAR/index.html#overview-of-var-models","text":"","title":"Overview of VAR models"},{"location":"TimeSeriesModeling/dummy/index.html","text":"Overview of prior dummy observations: +dummy package","title":"Overview of prior dummy observations: `+dummy` package"},{"location":"TimeSeriesModeling/dummy/index.html#overview-of-prior-dummy-observations-dummy-package","text":"","title":"Overview of prior dummy observations: +dummy package"},{"location":"TimeSeriesModeling/x13/index.html","text":"Overview of the X13 interface Categorical list of functions Seasonal adjustment Function Description x13.season Interface to X13-Arima seasonal adjustment procedure","title":"Overview of the X13 interface"},{"location":"TimeSeriesModeling/x13/index.html#overview-of-the-x13-interface","text":"","title":"Overview of the X13 interface"},{"location":"TimeSeriesModeling/x13/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"TimeSeriesModeling/x13/index.html#seasonal-adjustment","text":"Function Description x13.season Interface to X13-Arima seasonal adjustment procedure","title":"Seasonal adjustment"},{"location":"TimeSeriesModeling/x13/season.html","text":"x13.season Interface to X13-Arima seasonal adjustment procedure Syntax [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, ...) [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, range, ...) Input Arguments inputSeries [ Series ] Input time series that will be subjected to a X13-ARIMA seasonal adjustment procedure. range=Inf [ Dater ] Date range on which the seasonal adjustment will be performed; any observations outside the range will be clipped off before running the procedure; if not specified, all observations available will be used. Output Arguments outputSeries [ Series ] One or more output time series that correspond to the type of output requested in the option Output . info [ struct ] Information struct with details on the X13-ARIMA procedure run. The info struct includes the following fields and nested fields: .InputFiles - a struct with nested fields named after the extensions of the individual input files, with the content of the these input files. .OutputFiles - a struct with with nested fields named after the extensions of the individual output files produced by the X13-ARIMA procedure, with the content of these output files. The output files always included are .log , .out , and .err . Additional output files are included based on the output series (output tables) requested in the option Output . .Message - the screen output of the X13-ARIMA procedure; this output is also printed on the screen when the option Display=true . .OutputSpecs - selected specs based on the information captured from some output files; the output specs may include OutputSpecs.X11_Mode , OutputSpecs.Arima_Model , OutputSpecs.Arima_AR , OutputSPecs.Arima_MA . .Path - the entire path to the input and output files, including the file name wkithout and extension (the same file name with different extensions is used for both input and output files); when Cleanup=true , the input and output files are all deleted automatically. General Options Output=\"d10\" [ string ] Types of output requested to be returned as time series from the X13-ARIMA procedure; see the Output Tables in Description; the number of the outputSeries arguments corresponds to the number of elements in this option. Range=Inf [ Dater ] Date range that will be extracted from the inputSeries before running the X13-ARIMA procedure; the observations outside the range will be discarded. Display=false [ true | false ] Print the screen output produced by the X13-ARIMA procedure; the message is also captured in the output argument info.Message . Cleanup=true [ true | false ] Delete all input and output files automatically. X13-ARIMA Options Below are listed the X13-ARIMA specs that are supported in the current implemenation; refer to the X13-ARIMA-SEATS manual for details and explanation. To assign values to the individual specs and their settings, follow these rules: if a numeric scalar or vector is expected, assign the option a numeric scalar or vector; if a \"yes\" or \"no\" value is expected, assign a true or false ; if a text value or a list of more than onetext values is expected (such as log in Transform_Function , or td lpyear in Regression_Variables ), enter a single double-quoted string, or an array of strings (such as \"log\" or [\"td\", \"lpyear\"] ); if time series data are expected (such as in Regression_Data ), enter a time series object; if a fixed numeric value is expected (such as fixed coefficients in Arima_AR , as opposed to initial values in the same spec), enter an imaginary value (such as 0.8i ); imaginary values will be printed with an extra F in the input files (such as 0.8F ); Series Spec Series_Title Series_Span Series_ModelSpan Series_Precision Series_Decimals Series_CompType Series_CompWeight Series_AppendBcst Series_AppendFcst Series_Type Series_Save X11 Spec X11_SeasonalMA X11_TrendMA X11_SigmaLim X11_Title X11_AppendFcst X11_AppendBcst X11_Final X11_Print X11_Save X11_SaveLog Transform Spec Transform_Function Transform_Power Transform_Adjust Transform_Title Transform_AicDiff Transform_Print Transform_Save Transform_SaveLog Estimate Spec Estimate_Tol Estimate_MaxIter Estimate_Exact Estimate_OutOfSample Estimate_Print Estimate_Save Estimate_SaveLog Automdl Spec Automdl_MaxOrder Automdl_MaxDiff Automdl_Diff Automdl_AcceptDefault Automdl_CheckMu Automdl_LjungBoxLimit Automdl_Mixed Automdl_Print Automdl_SaveLog Arima Spec Arima_Model Arima_AR Arima_MA Arima_Title Force Spec Force_Type Force_Lambda Force_Rho Force_Round Force_Start Force_Target Force_UseFcst Force_Print Force_Save Forecast Spec Forecast_MaxLead Forecast_MaxBack Forecast_Exclude Forecast_LogNormal Forecast_Print Forecast_Save Regression Spec Regression_Variables Regression_TestAllEaster Regression_Data Regression_User Regression_UserType Regression_AicTest Regression_AicDiff Regression_PVAicTest Regression_TLimit Regression_Chi2Test Regression_Chi2TestCV Regression_Print Regression_Save Regression_SaveLog X11Regression Spec X11Regression_Variables X11Regression_Data X11Regression_User X11Regression_UserType X11Regression_AicTest X11Regression_AicDiff X11Regression_TDPrior X11Regression_Prior X11Regression_Span X11Regression_Sigma X11Regression_Critical X11Regression_OutlierMethod X11Regression_OutlierSpan X11Regression_Print X11Regression_Save X11Regression_SaveLog Seats Spec Seats_AppendFcst Seats_HpCycle Seats_NoAdmiss Seats_QMax Seats_RMod Seats_Out Seats_StatSeas Seats_TabTables Seats_PrintPhtrf Seats_Print Seats_Save Seats_SaveLog Description Bulding the Input File With no options specified, all specs (see their list above) are empty, meaning they are not included in the input file at all and the X13-ARIMA default values (see the X13-ARIMA-SEATS manual) are assumed, with the following exceptions: Series_Start , Series_Data and Series_Period are automatically created based on the inputSeries ; Series_Precision and Series_Decimals are both set to 5 (the maximum precision accepted by the X13-ARIMA procedure); Either an X11 spec or a pair of Seat and Automdl specs are included to force the execution of the X11 type of seasonal adjustment (if d.. types of output tables are requested in Output ) or the execution of the SEAT type of seasonal adjustment (if x.. types of output tables are requested in Output ). If no setting within a particular spec is not defined in the options, the spec itself is not included in the input file. To force the inclusion of an empty spec in the input file (assuming thus the default values for all the settings within that spece), use the name of the spec as an option and set it to true , e.g. (..., \"Automdl\", true, ...) to force the estimation of an ARIMA model based on an automatic model selection procedure. If at least one setting from a particular spec is specified as an option in the fuction call, that spec is included explicitly in the input file. Type of Seasonal Adjustment Two types of seasonal adjustments are available in X13-ARIMA: X11 and SEATS . Which one is invoked depends on the type of output requested in the option Output : the output tables starting with a d refer to X11 (hence, the default Output=\"d11\" invokes X11 and returns the final seasonally adjusted series) whereas the output tables starting with an s refer to SEATS . Depending on the output tables requested, the correct spec for the respective seasonal adjustment procedure will be included in the input file and invoked. The two procedures cannot be combined together in one run; i.e. the option Output cannot combine d.. and s.. output tables. Output Tables (Output Series) The following output tables (i.e. output series) can be requested in the option Output : Name in option Output Output table in X13 Description \"d10\" X11_d10 X11 final seasonal factors \"d11\" X11_d11 X11 final seasonally adjusted series \"d12\" X11_d12 X11 final trend-cycle \"d13\" X11_d13 X11 final irregular component \"d16\" X11_d16 X11 final combined seasonal and trading day factors \"d18\" X11_d18 X11 combined holiday and trading day factors \"s10\" Seats_s10 SEATS final seasonal component \"s11\" Seats_s11 SEATS final seasonal adjustment component \"s12\" Seats_s12 SEATS final trend component \"s13\" Seats_s13 SEATS final irregular component \"s14\" Seats_s14 SEATS final transitory component \"s16\" Seats_s16 SEATS final combined adjustment component \"s18\" Seats_s18 SEATS final adjustment ratio \"cyc\" Seats_cyc SEATS cycle component \"a18\" Series_a18 Original series adjusted for regARIMA calendar effects \"a19\" Series_a19 Original series adjusted for regARIMA outliers \"b1\" Series_b1 Original series, adjusted for prior effects and forecast extended \"mva\" Series_mva Original series with missing values replaced by regARIMA estimates \"saa\" Force_saa Final seasonally adjusted series with constrained yearly totals \"rnd\" Force_rnd Rounded final seasonally adjusted series \"fct\" Forecast_fct Point forecasts on the original scale \"bct\" Forecast_bct Point backcasts on the original scale \"ftr\" Forecast_ftr Point forecasts on the transformed scale \"btr\" Forecast_btr Point backcasts on the transformed scale Example A plain vanilla call xsa = x13 . season ( x ) or [ xsa , info ] = x13 . season ( x ) produces a seasonally adjusted series xsa with all default settings (hence no ARIMA model estimated). Example Estimate an ARIMA model based on an automatic model selection procedures, use the ARIMA information in the seasonal adjustment, and return the estimated ARIMA model in the output info struct: [xsa, info] = x13.season(x, \"Automdl\", true, \"Estimate_Save\", \"mdl\") Example Request additional output series: the seasonally adjusted series, the seasonal factors and the trend cycle component: [ xsa , xsf , xtc , info ] = x13 . season ( x , \"Output\" , [ \"d11\" , \"d10\" , \"d12\" ]); Example Run seasonal adjustment based on an automatically selected ARIMA model with dummy variables of additive outliers in period 2017Q3, 2017Q4 and 2018Q1: xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Variables\" , \"aos2017.3-2018.1\" ... ); This call is equivalent to creating the dummies manually (a time series object with three columns), and using the option Regression_Data instead: dummy = Series ( startDate : endDate , zeros ( 1 , 3 )); dummy ( qq ( 2017 , 3 ), 1 ) = 1 ; dummy ( qq ( 2017 , 4 ), 2 ) = 1 ; dummy ( qq ( 2018 , 1 ), 3 ) = 1 ; xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Data\" , dummy ... );","title":"x13.season"},{"location":"TimeSeriesModeling/x13/season.html#x13season","text":"Interface to X13-Arima seasonal adjustment procedure","title":"x13.season"},{"location":"TimeSeriesModeling/x13/season.html#syntax","text":"[outputSeries, outputSeries, ..., info] = x13.season(inputSeries, ...) [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, range, ...)","title":"Syntax"},{"location":"TimeSeriesModeling/x13/season.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be subjected to a X13-ARIMA seasonal adjustment procedure. range=Inf [ Dater ] Date range on which the seasonal adjustment will be performed; any observations outside the range will be clipped off before running the procedure; if not specified, all observations available will be used.","title":"Input Arguments"},{"location":"TimeSeriesModeling/x13/season.html#output-arguments","text":"outputSeries [ Series ] One or more output time series that correspond to the type of output requested in the option Output . info [ struct ] Information struct with details on the X13-ARIMA procedure run. The info struct includes the following fields and nested fields: .InputFiles - a struct with nested fields named after the extensions of the individual input files, with the content of the these input files. .OutputFiles - a struct with with nested fields named after the extensions of the individual output files produced by the X13-ARIMA procedure, with the content of these output files. The output files always included are .log , .out , and .err . Additional output files are included based on the output series (output tables) requested in the option Output . .Message - the screen output of the X13-ARIMA procedure; this output is also printed on the screen when the option Display=true . .OutputSpecs - selected specs based on the information captured from some output files; the output specs may include OutputSpecs.X11_Mode , OutputSpecs.Arima_Model , OutputSpecs.Arima_AR , OutputSPecs.Arima_MA . .Path - the entire path to the input and output files, including the file name wkithout and extension (the same file name with different extensions is used for both input and output files); when Cleanup=true , the input and output files are all deleted automatically.","title":"Output Arguments"},{"location":"TimeSeriesModeling/x13/season.html#general-options","text":"Output=\"d10\" [ string ] Types of output requested to be returned as time series from the X13-ARIMA procedure; see the Output Tables in Description; the number of the outputSeries arguments corresponds to the number of elements in this option. Range=Inf [ Dater ] Date range that will be extracted from the inputSeries before running the X13-ARIMA procedure; the observations outside the range will be discarded. Display=false [ true | false ] Print the screen output produced by the X13-ARIMA procedure; the message is also captured in the output argument info.Message . Cleanup=true [ true | false ] Delete all input and output files automatically.","title":"General Options"},{"location":"TimeSeriesModeling/x13/season.html#x13-arima-options","text":"Below are listed the X13-ARIMA specs that are supported in the current implemenation; refer to the X13-ARIMA-SEATS manual for details and explanation. To assign values to the individual specs and their settings, follow these rules: if a numeric scalar or vector is expected, assign the option a numeric scalar or vector; if a \"yes\" or \"no\" value is expected, assign a true or false ; if a text value or a list of more than onetext values is expected (such as log in Transform_Function , or td lpyear in Regression_Variables ), enter a single double-quoted string, or an array of strings (such as \"log\" or [\"td\", \"lpyear\"] ); if time series data are expected (such as in Regression_Data ), enter a time series object; if a fixed numeric value is expected (such as fixed coefficients in Arima_AR , as opposed to initial values in the same spec), enter an imaginary value (such as 0.8i ); imaginary values will be printed with an extra F in the input files (such as 0.8F );","title":"X13-ARIMA Options"},{"location":"TimeSeriesModeling/x13/season.html#series-spec","text":"Series_Title Series_Span Series_ModelSpan Series_Precision Series_Decimals Series_CompType Series_CompWeight Series_AppendBcst Series_AppendFcst Series_Type Series_Save","title":"Series Spec"},{"location":"TimeSeriesModeling/x13/season.html#x11-spec","text":"X11_SeasonalMA X11_TrendMA X11_SigmaLim X11_Title X11_AppendFcst X11_AppendBcst X11_Final X11_Print X11_Save X11_SaveLog","title":"X11 Spec"},{"location":"TimeSeriesModeling/x13/season.html#transform-spec","text":"Transform_Function Transform_Power Transform_Adjust Transform_Title Transform_AicDiff Transform_Print Transform_Save Transform_SaveLog","title":"Transform Spec"},{"location":"TimeSeriesModeling/x13/season.html#estimate-spec","text":"Estimate_Tol Estimate_MaxIter Estimate_Exact Estimate_OutOfSample Estimate_Print Estimate_Save Estimate_SaveLog","title":"Estimate Spec"},{"location":"TimeSeriesModeling/x13/season.html#automdl-spec","text":"Automdl_MaxOrder Automdl_MaxDiff Automdl_Diff Automdl_AcceptDefault Automdl_CheckMu Automdl_LjungBoxLimit Automdl_Mixed Automdl_Print Automdl_SaveLog","title":"Automdl Spec"},{"location":"TimeSeriesModeling/x13/season.html#arima-spec","text":"Arima_Model Arima_AR Arima_MA Arima_Title","title":"Arima Spec"},{"location":"TimeSeriesModeling/x13/season.html#force-spec","text":"Force_Type Force_Lambda Force_Rho Force_Round Force_Start Force_Target Force_UseFcst Force_Print Force_Save","title":"Force Spec"},{"location":"TimeSeriesModeling/x13/season.html#forecast-spec","text":"Forecast_MaxLead Forecast_MaxBack Forecast_Exclude Forecast_LogNormal Forecast_Print Forecast_Save","title":"Forecast Spec"},{"location":"TimeSeriesModeling/x13/season.html#regression-spec","text":"Regression_Variables Regression_TestAllEaster Regression_Data Regression_User Regression_UserType Regression_AicTest Regression_AicDiff Regression_PVAicTest Regression_TLimit Regression_Chi2Test Regression_Chi2TestCV Regression_Print Regression_Save Regression_SaveLog","title":"Regression Spec"},{"location":"TimeSeriesModeling/x13/season.html#x11regression-spec","text":"X11Regression_Variables X11Regression_Data X11Regression_User X11Regression_UserType X11Regression_AicTest X11Regression_AicDiff X11Regression_TDPrior X11Regression_Prior X11Regression_Span X11Regression_Sigma X11Regression_Critical X11Regression_OutlierMethod X11Regression_OutlierSpan X11Regression_Print X11Regression_Save X11Regression_SaveLog","title":"X11Regression Spec"},{"location":"TimeSeriesModeling/x13/season.html#seats-spec","text":"Seats_AppendFcst Seats_HpCycle Seats_NoAdmiss Seats_QMax Seats_RMod Seats_Out Seats_StatSeas Seats_TabTables Seats_PrintPhtrf Seats_Print Seats_Save Seats_SaveLog","title":"Seats Spec"},{"location":"TimeSeriesModeling/x13/season.html#description","text":"","title":"Description"},{"location":"TimeSeriesModeling/x13/season.html#bulding-the-input-file","text":"With no options specified, all specs (see their list above) are empty, meaning they are not included in the input file at all and the X13-ARIMA default values (see the X13-ARIMA-SEATS manual) are assumed, with the following exceptions: Series_Start , Series_Data and Series_Period are automatically created based on the inputSeries ; Series_Precision and Series_Decimals are both set to 5 (the maximum precision accepted by the X13-ARIMA procedure); Either an X11 spec or a pair of Seat and Automdl specs are included to force the execution of the X11 type of seasonal adjustment (if d.. types of output tables are requested in Output ) or the execution of the SEAT type of seasonal adjustment (if x.. types of output tables are requested in Output ). If no setting within a particular spec is not defined in the options, the spec itself is not included in the input file. To force the inclusion of an empty spec in the input file (assuming thus the default values for all the settings within that spece), use the name of the spec as an option and set it to true , e.g. (..., \"Automdl\", true, ...) to force the estimation of an ARIMA model based on an automatic model selection procedure. If at least one setting from a particular spec is specified as an option in the fuction call, that spec is included explicitly in the input file.","title":"Bulding the Input File"},{"location":"TimeSeriesModeling/x13/season.html#type-of-seasonal-adjustment","text":"Two types of seasonal adjustments are available in X13-ARIMA: X11 and SEATS . Which one is invoked depends on the type of output requested in the option Output : the output tables starting with a d refer to X11 (hence, the default Output=\"d11\" invokes X11 and returns the final seasonally adjusted series) whereas the output tables starting with an s refer to SEATS . Depending on the output tables requested, the correct spec for the respective seasonal adjustment procedure will be included in the input file and invoked. The two procedures cannot be combined together in one run; i.e. the option Output cannot combine d.. and s.. output tables.","title":"Type of Seasonal Adjustment"},{"location":"TimeSeriesModeling/x13/season.html#output-tables-output-series","text":"The following output tables (i.e. output series) can be requested in the option Output : Name in option Output Output table in X13 Description \"d10\" X11_d10 X11 final seasonal factors \"d11\" X11_d11 X11 final seasonally adjusted series \"d12\" X11_d12 X11 final trend-cycle \"d13\" X11_d13 X11 final irregular component \"d16\" X11_d16 X11 final combined seasonal and trading day factors \"d18\" X11_d18 X11 combined holiday and trading day factors \"s10\" Seats_s10 SEATS final seasonal component \"s11\" Seats_s11 SEATS final seasonal adjustment component \"s12\" Seats_s12 SEATS final trend component \"s13\" Seats_s13 SEATS final irregular component \"s14\" Seats_s14 SEATS final transitory component \"s16\" Seats_s16 SEATS final combined adjustment component \"s18\" Seats_s18 SEATS final adjustment ratio \"cyc\" Seats_cyc SEATS cycle component \"a18\" Series_a18 Original series adjusted for regARIMA calendar effects \"a19\" Series_a19 Original series adjusted for regARIMA outliers \"b1\" Series_b1 Original series, adjusted for prior effects and forecast extended \"mva\" Series_mva Original series with missing values replaced by regARIMA estimates \"saa\" Force_saa Final seasonally adjusted series with constrained yearly totals \"rnd\" Force_rnd Rounded final seasonally adjusted series \"fct\" Forecast_fct Point forecasts on the original scale \"bct\" Forecast_bct Point backcasts on the original scale \"ftr\" Forecast_ftr Point forecasts on the transformed scale \"btr\" Forecast_btr Point backcasts on the transformed scale","title":"Output Tables (Output Series)"},{"location":"TimeSeriesModeling/x13/season.html#example","text":"A plain vanilla call xsa = x13 . season ( x ) or [ xsa , info ] = x13 . season ( x ) produces a seasonally adjusted series xsa with all default settings (hence no ARIMA model estimated).","title":"Example"},{"location":"TimeSeriesModeling/x13/season.html#example_1","text":"Estimate an ARIMA model based on an automatic model selection procedures, use the ARIMA information in the seasonal adjustment, and return the estimated ARIMA model in the output info struct: [xsa, info] = x13.season(x, \"Automdl\", true, \"Estimate_Save\", \"mdl\")","title":"Example"},{"location":"TimeSeriesModeling/x13/season.html#example_2","text":"Request additional output series: the seasonally adjusted series, the seasonal factors and the trend cycle component: [ xsa , xsf , xtc , info ] = x13 . season ( x , \"Output\" , [ \"d11\" , \"d10\" , \"d12\" ]);","title":"Example"},{"location":"TimeSeriesModeling/x13/season.html#example_3","text":"Run seasonal adjustment based on an automatically selected ARIMA model with dummy variables of additive outliers in period 2017Q3, 2017Q4 and 2018Q1: xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Variables\" , \"aos2017.3-2018.1\" ... ); This call is equivalent to creating the dummies manually (a time series object with three columns), and using the option Regression_Data instead: dummy = Series ( startDate : endDate , zeros ( 1 , 3 )); dummy ( qq ( 2017 , 3 ), 1 ) = 1 ; dummy ( qq ( 2017 , 4 ), 2 ) = 1 ; dummy ( qq ( 2018 , 1 ), 3 ) = 1 ; xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Data\" , dummy ... );","title":"Example"},{"location":"Utilities/index.html","text":"Overview of utility functions","title":"Overview of utility functions"},{"location":"Utilities/index.html#overview-of-utility-functions","text":"","title":"Overview of utility functions"},{"location":"Utilities/%2Bdistribution/index.html","text":"Overview of probabilistic distributions","title":"Overview of probabilistic distributions"},{"location":"Utilities/%2Bdistribution/index.html#overview-of-probabilistic-distributions","text":"","title":"Overview of probabilistic distributions"},{"location":"Utilities/%2Bdistribution/Beta/index.html","text":"Beta Distribution Constructors The following are static constructors and need to be called with distribution.Beta. preceding their names. fromAB - Beta distribution from parameters A and B fromMeanVar - Beta distribution from mean and variance fromMeanStd - Beta distribution from mean and std deviation fromModeVar - Beta distribution from mode and variance fromModeStd - Beta distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution A - Parameter A of Beta distribution Beta - Beta distribution object Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Beta Distribution"},{"location":"Utilities/%2Bdistribution/Beta/index.html#beta-distribution","text":"Constructors The following are static constructors and need to be called with distribution.Beta. preceding their names. fromAB - Beta distribution from parameters A and B fromMeanVar - Beta distribution from mean and variance fromMeanStd - Beta distribution from mean and std deviation fromModeVar - Beta distribution from mode and variance fromModeStd - Beta distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution A - Parameter A of Beta distribution Beta - Beta distribution object Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Beta Distribution"},{"location":"Utilities/%2Bdistribution/Gamma/index.html","text":"Gamma Distribution Constructors The following are static constructors and need to be called with distribution.Gamma. preceding their names. fromShapeScale - Gamma distribution from shape and scale parameters fromAlphaBeta - Gamma distribution from alpha and beta parameters fromMeanVar - Gamma distribution from mean and variance fromMeanStd - Gamma distribution from mean and std deviation fromModeVar - Gamma distribution from mode and variance fromModeStd - Gamma distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution Alpha - Alpha (shape) parameter of Gamma distribution Beta - Beta (scale) parameter of Gamma distribution Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Shape - Shape parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Gamma Distribution"},{"location":"Utilities/%2Bdistribution/Gamma/index.html#gamma-distribution","text":"Constructors The following are static constructors and need to be called with distribution.Gamma. preceding their names. fromShapeScale - Gamma distribution from shape and scale parameters fromAlphaBeta - Gamma distribution from alpha and beta parameters fromMeanVar - Gamma distribution from mean and variance fromMeanStd - Gamma distribution from mean and std deviation fromModeVar - Gamma distribution from mode and variance fromModeStd - Gamma distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution Alpha - Alpha (shape) parameter of Gamma distribution Beta - Beta (scale) parameter of Gamma distribution Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Shape - Shape parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Gamma Distribution"},{"location":"Utilities/%2Btextual/index.html","text":"Overview of text utilities","title":"Overview of text utilities"},{"location":"Utilities/%2Btextual/index.html#overview-of-text-utilities","text":"","title":"Overview of text utilities"},{"location":"Utilities/%2Btextual/nonunique.html","text":"textual.nonunique Find nonunique entries in a list Syntax [flag, nonuniques] = textual.nonunique(inputList) Input arguments inputList [ string ] List of strings. Output arguments flag [ true | false ] True if there are duplicate (nonunique) entries in the inputList . nonuniques [ string ] List of nonunique (duplicate) entries from the inputList . Description Find all entries that occur in the inputList , more than once, and return them with each such entry included only once in the output list, nonuniques . Example >> [ flag , nonuniques ] = textual . nonunique ([ \"a\" , \"b\" , \"c\" ]) flag = logical 0 nonuniques = 1 x0 empty cell array >> [ flag , nonuniques ] = textual . nonunique ([ \"a\" , \"b\" , \"c\" , \"a\" , \"a\" , \"c\" }) flag = logical 1 nonuniques = 1 x2 string array \"a\" \"b\"","title":"textual.nonunique"},{"location":"Utilities/%2Btextual/nonunique.html#textualnonunique","text":"Find nonunique entries in a list","title":"textual.nonunique"},{"location":"Utilities/%2Btextual/nonunique.html#syntax","text":"[flag, nonuniques] = textual.nonunique(inputList)","title":"Syntax"},{"location":"Utilities/%2Btextual/nonunique.html#input-arguments","text":"inputList [ string ] List of strings.","title":"Input arguments"},{"location":"Utilities/%2Btextual/nonunique.html#output-arguments","text":"flag [ true | false ] True if there are duplicate (nonunique) entries in the inputList . nonuniques [ string ] List of nonunique (duplicate) entries from the inputList .","title":"Output arguments"},{"location":"Utilities/%2Btextual/nonunique.html#description","text":"Find all entries that occur in the inputList , more than once, and return them with each such entry included only once in the output list, nonuniques .","title":"Description"},{"location":"Utilities/%2Btextual/nonunique.html#example","text":">> [ flag , nonuniques ] = textual . nonunique ([ \"a\" , \"b\" , \"c\" ]) flag = logical 0 nonuniques = 1 x0 empty cell array >> [ flag , nonuniques ] = textual . nonunique ([ \"a\" , \"b\" , \"c\" , \"a\" , \"a\" , \"c\" }) flag = logical 1 nonuniques = 1 x2 string array \"a\" \"b\"","title":"Example"},{"location":"Utilities/%2Btextual/write.html","text":"textual.write Write character string to text file Syntax textual.write(c, fileName, ...) textual.write(c, fileName, precision, ...) Input Arguments c [ char | string ] - Character vector or string that will be written to the file. fileName [ char ] - Name of the destination file. ~precision [ char ] - Form and precision of the data written to the file; if omitted, precision='char' . Options MachineFormat='native' [ char | string ] Format for writing bytes and bits in the destination file. Encoding=@auto [ @auto | char | string ] - Encoding scheme for writing in the destination file; @auto means the operating system default scheme. Description Example","title":"textual.write"},{"location":"Utilities/%2Btextual/write.html#textualwrite","text":"Write character string to text file","title":"textual.write"},{"location":"Utilities/%2Btextual/write.html#syntax","text":"textual.write(c, fileName, ...) textual.write(c, fileName, precision, ...)","title":"Syntax"},{"location":"Utilities/%2Btextual/write.html#input-arguments","text":"c [ char | string ] - Character vector or string that will be written to the file. fileName [ char ] - Name of the destination file. ~precision [ char ] - Form and precision of the data written to the file; if omitted, precision='char' .","title":"Input Arguments"},{"location":"Utilities/%2Btextual/write.html#options","text":"MachineFormat='native' [ char | string ] Format for writing bytes and bits in the destination file. Encoding=@auto [ @auto | char | string ] - Encoding scheme for writing in the destination file; @auto means the operating system default scheme.","title":"Options"},{"location":"Utilities/%2Btextual/write.html#description","text":"","title":"Description"},{"location":"Utilities/%2Btextual/write.html#example","text":"","title":"Example"},{"location":"Utilities/%2Bvisual/index.html","text":"Overview of visualization utilities","title":"Overview of visualization utilities"},{"location":"Utilities/%2Bvisual/index.html#overview-of-visualization-utilities","text":"","title":"Overview of visualization utilities"},{"location":"Utilities/%40Grouping/index.html","text":"Overview of grouping objects Grouping objects are used for aggregating the contributions of shocks in model simulations, model/simulate , or aggregating the contributions of measurement variables in Kalman filtering, model/filter . Constructor Grouping - Create new empty Grouping object Getting information about groups detail - Details of a Grouping object isempty - True for empty Grouping object Setting up and using groups addgroup - Add measurement variable group or shock group to Grouping object eval - Evaluate contributions in input database S using Grouping object G","title":"Overview of grouping objects"},{"location":"Utilities/%40Grouping/index.html#overview-of-grouping-objects","text":"Grouping objects are used for aggregating the contributions of shocks in model simulations, model/simulate , or aggregating the contributions of measurement variables in Kalman filtering, model/filter .","title":"Overview of grouping objects"},{"location":"Utilities/%40Grouping/index.html#constructor","text":"Grouping - Create new empty Grouping object","title":"Constructor"},{"location":"Utilities/%40Grouping/index.html#getting-information-about-groups","text":"detail - Details of a Grouping object isempty - True for empty Grouping object","title":"Getting information about groups"},{"location":"Utilities/%40Grouping/index.html#setting-up-and-using-groups","text":"addgroup - Add measurement variable group or shock group to Grouping object eval - Evaluate contributions in input database S using Grouping object G","title":"Setting up and using groups"}]}