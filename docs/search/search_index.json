{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"[IrisToolbox] Reference Manual","title":"Introduction"},{"location":"index.html#iristoolbox-reference-manual","text":"","title":"[IrisToolbox] Reference Manual"},{"location":"install.html","text":"Installing IrisT There are two basic ways to get IrisT up and running on your computer: clone the GitHub repository; or download and unpack Iris from a zip achive. Cloning the GitHub Repository Installing IrisT from a Zip Archive","title":"Installation"},{"location":"install.html#installing-irist","text":"There are two basic ways to get IrisT up and running on your computer: clone the GitHub repository; or download and unpack Iris from a zip achive.","title":"Installing IrisT"},{"location":"install.html#cloning-the-github-repository","text":"","title":"Cloning the GitHub Repository"},{"location":"install.html#installing-irist-from-a-zip-archive","text":"","title":"Installing IrisT from a Zip Archive"},{"location":"data-management/index.html","text":"Data Management","title":"Introduction"},{"location":"data-management/index.html#data-management","text":"","title":"Data Management"},{"location":"data-management/databank/index.html","text":"Databank Functions IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks. Categorical List of Functions Creating, converting, importing, and exporting databanks Function Description databank.toArray Create numeric array from time series data databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series Getting information about databanks Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields databank.range Find a range that encompasses the ranges of all or selected databank time series Processing databanks Function Description databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy Copy fields of source databank to target databank databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields Manipulating model databanks Function Description databank.minusControl Create simulation-minus-control database","title":"Introduction"},{"location":"data-management/databank/index.html#databank-functions","text":"IrisT uses the standard Matlab structures (struct objects) as databanks that can store any types of data. The +databank package provides several functions to automate and streamline some of the most frequent data handling tasks.","title":"Databank Functions"},{"location":"data-management/databank/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"data-management/databank/index.html#creating-converting-importing-and-exporting-databanks","text":"Function Description databank.toArray Create numeric array from time series data databank.fromCSV Create databank by loading CSV file databank.toCSV Write databank to CSV file databank.withEmpty Create databank with empty time series","title":"Creating, converting, importing, and exporting databanks"},{"location":"data-management/databank/index.html#getting-information-about-databanks","text":"Function Description databank.fieldNames List of databank field names as a row vector of strings databank.list List databank fields adding date range to time series fields databank.range Find a range that encompasses the ranges of all or selected databank time series","title":"Getting information about databanks"},{"location":"data-management/databank/index.html#processing-databanks","text":"Function Description databank.apply Apply function to a selection of databank fields databank.clip Clip all time series in databank to a new range databank.copy Copy fields of source databank to target databank databank.eval Evaluate an expression within a databank context databank.filterFields Get the names of databank fields that pass name or value tests databank.merge Merge two or more databanks databank.retrieveColumns Retrieve selected columns from databank fields","title":"Processing databanks"},{"location":"data-management/databank/index.html#manipulating-model-databanks","text":"Function Description databank.minusControl Create simulation-minus-control database","title":"Manipulating model databanks"},{"location":"data-management/databank/apply.html","text":"databank.apply Apply function to a selection of databank fields Syntax [outputDb, appliedToNames, newNames] = apply(inputDb, func, ...) Input Arguments inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb . Output Arguments outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb . Options StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields. Description Example Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 ); Example Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"apply"},{"location":"data-management/databank/apply.html#databankapply","text":"Apply function to a selection of databank fields","title":"databank.apply"},{"location":"data-management/databank/apply.html#syntax","text":"[outputDb, appliedToNames, newNames] = apply(inputDb, func, ...)","title":"Syntax"},{"location":"data-management/databank/apply.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank to whose fields the function will be applied. func [ function_handle ] Function (function handle) that will be applied to the selected fields of the inputDb .","title":"Input Arguments"},{"location":"data-management/databank/apply.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created from the inputDb with new fields or some fields modified. appliedToNames [ string ] List of names to which the function has been actually applied. newNames [ string ] List of names under which the results are stored in the outputDb .","title":"Output Arguments"},{"location":"data-management/databank/apply.html#options","text":"StartsWith=\"\" [ string ] Apply the function to fields whose names start with this string. EndsWith=\"\" [ string ] Apply the function to fields whose names end with this string. RemoveStart=false [ true | false ] If option StartsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the start of the string. RemoveEnd=false [ true | false ] If option EndsWith= was used, a new field will be created after the function has been applied with its named derived from the original name by removing the end of the string. Prepend=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by prepending this string to the beginning of the original field name. Append=\"\" [ char | string ] A new field will be created after the function has been applied with its named derived from the original name by appending this string to the end of the original field name. RemoveSource=false [ true | false ] Remove the source field from the outputDb ; the source field is the inputDb on which the function was run to create a new field. SourceNames=@all [ @all | cellstr | string ] List of databank field names to which the name selection procedure will be reduced. TargetNames=@default [ @default | cellstr | string ] New names for output databank fields.","title":"Options"},{"location":"data-management/databank/apply.html#description","text":"","title":"Description"},{"location":"data-management/databank/apply.html#example","text":"Add 1 to all databank fields, regardless of their types. Note that the addition also works for strings. d1 = struct ( ); d1 . x = Series ( 1 : 10 , 1 : 10 ); d1 . b = 1 : 5 ; d1 . y_u = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d1 . s = \"x\" ; d2 = databank . apply ( d1 , @( x ) x + 1 );","title":"Example"},{"location":"data-management/databank/apply.html#example_1","text":"Seasonally adjust all time series whose name ends with _u . % Create random series, some with seasonal patterns range = qq ( 2010 , 1 ): qq ( 2025 , 4 ); s1 = Series . seasonDummy ( range , 1 ); s2 = Series . seasonDummy ( range , 2 ); s3 = Series . seasonDummy ( range , 3 ); d = struct (); d . x1_u = cumsum ( Series ( range , @ randn )) + 4 * s1 - 2 * s2 + 2 * s3 ; d . x2_u = cumsum ( Series ( range , @ randn )) - 1 * s1 + 3 * s2 - 7 * s3 ; d . x3_u = cumsum ( Series ( range , @ randn )) + 7 * s1 + 3 * s2 - 5 * s3 ; d . x4 = cumsum ( Series ( range , @ randn )); d . x5 = cumsum ( Series ( range , @ randn )); databank . list ( d ) % Apply the seasonal adjustment function to all fields whose name starts % with `_u`; the seasonally adjusted series will be added to the databank % under new names created by removing the `_u` func = @( x ) x13 . season ( x , \"x11_mode\" , \"add\" ); d = databank . apply ( d , func , \"endsWith\" , \"_u\" , \"removeEnd\" , true ); databank . list ( d )","title":"Example"},{"location":"data-management/databank/clip.html","text":"databank.clip Clip all time series in databank to a new range Syntax outputDatabank = databank.clip(inputDatabank, newStart, newEnd) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered. Output Arguments outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range. Description Example Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"clip"},{"location":"data-management/databank/clip.html#databankclip","text":"Clip all time series in databank to a new range","title":"databank.clip"},{"location":"data-management/databank/clip.html#syntax","text":"outputDatabank = databank.clip(inputDatabank, newStart, newEnd)","title":"Syntax"},{"location":"data-management/databank/clip.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series (of the matching frequency) will be clipped to a new range defined by newStart and newEnd . newStart [ Dater | -Inf ] A new start date to which all time series of the matching frequency will be clipped; -Inf means the start date will not be altered. newEnd [ Dater | Inf ] A new end date to which all time series of the matching frequency will be clipped; Inf means the end date will not be altered.","title":"Input Arguments"},{"location":"data-management/databank/clip.html#output-arguments","text":"outputDatabank [ struct | Dictionary ] - Output databank in which all time series (of the matching frequency) are clipped to the new range.","title":"Output Arguments"},{"location":"data-management/databank/clip.html#description","text":"","title":"Description"},{"location":"data-management/databank/clip.html#example","text":"Create a databank with time series of different frequencies. Clip the date range of all quarterly series.so that they all start in 2019Q1. d = struct (); d . x1 = Series ( qq ( 2015 , 1 ): qq ( 2030 , 4 ), @ rand ); d . x2 = Series ( qq ( 2010 , 1 ): qq ( 2025 , 4 ), @ rand ); d . x3 = Series ( mm ( 2012 , 01 ): qq ( 2025 , 12 ), @ rand ); d . x4 = Series ( mm ( 2019 , 01 ): qq ( 2022 , 08 ), @ rand ); d . x5 = Series ( 1 : 100 , @ rand ); d = databank . clip ( d , qq ( 2019 , 1 ), Inf )","title":"Example"},{"location":"data-management/databank/copy.html","text":"databank.copy Copy fields of source databank to target databank Syntax targetDb = databank.copy(sourceDb, ...) Input Arguments sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb . Options SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle ] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform=[ ] [ empty | function_handle ] Transformation function applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank. Output Arguments targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over. Description Example","title":"copy"},{"location":"data-management/databank/copy.html#databankcopy","text":"Copy fields of source databank to target databank","title":"databank.copy"},{"location":"data-management/databank/copy.html#syntax","text":"targetDb = databank.copy(sourceDb, ...)","title":"Syntax"},{"location":"data-management/databank/copy.html#input-arguments","text":"sourceDb [ struct | Dictionary ] Source databank from which some (or all) fields will be copied over to the targetDb .","title":"Input Arguments"},{"location":"data-management/databank/copy.html#options","text":"SourceNames=@all [ @all | cellstr | string ] List of fieldnames to be copied over from the sourceDb to the targetDb ; @all means all fields existing in the sourceDb will be copied. TargetDb=@empty [ @empty | struct | Dictionary ] Target databank to which some (or all) fields form the sourceDb will be copied over; @empty means a new empty databank will be created of the same type as the sourceDb (either a struct or a Dictionary). TargetNames=@auto [ cellstr | string | function_handle ] Names under which the fields from the sourceDb will be stored in the targetDb ; @auto means the TargetNames will be simply the same as the SourceNames ; if TargetNames is a function, the target names will be created by applying this function to each of the SourceNames . Transform=[ ] [ empty | function_handle ] Transformation function applied to each of the fields being copied over from the sourceDb to the targetDb ; if empty, no transformation is performed. WhenTransformFails='Error' [ 'Error' | 'Warning' | 'Silence' ] Action to be taken if the transformation function Transform= evaluates to an error when applied to one or more fields of the source databank.","title":"Options"},{"location":"data-management/databank/copy.html#output-arguments","text":"targetDb [ struct | Dictionary ] Target databank to which some (or all) fields from the sourceDb will be copied over.","title":"Output Arguments"},{"location":"data-management/databank/copy.html#description","text":"","title":"Description"},{"location":"data-management/databank/copy.html#example","text":"","title":"Example"},{"location":"data-management/databank/eval.html","text":"databank.eval Evaluate an expression within a databank context Syntax [output, output, ...] = databank.eval(inputDb, expression, expression, ...) outputs = databank.eval(inputDb, expressions) outputDb = databank.eval(inputDb, expressionsDb) Input Arguments inputDb [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDb fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDb fields. expressionsDb [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated. Output Arguments output [ * ] Result of the expression evaluated in the inputDb workspace. outputs [ cell ] Results of the expressions evaluated in the inputDb workspace. outputDb [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDb workspace. Description Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDb fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDb . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDb fields. To include round-bracket references to inputDb fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis. Example d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"eval"},{"location":"data-management/databank/eval.html#databankeval","text":"Evaluate an expression within a databank context","title":"databank.eval"},{"location":"data-management/databank/eval.html#syntax","text":"[output, output, ...] = databank.eval(inputDb, expression, expression, ...) outputs = databank.eval(inputDb, expressions) outputDb = databank.eval(inputDb, expressionsDb)","title":"Syntax"},{"location":"data-management/databank/eval.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank whose fields constitute a workspace in which the expressions will be evaluated.% expression [ char | string ] Text string with an expression that will be evaluated in the workspace consisting of the inputDb fields. expressions [ cellstr | string ] Cell array of char vectors or string array (more than one element) with expressions that will be evaluated in the workspace consisting of the inputDb fields. expressionsDb [ struct | Dictionary ] Databank whose fields contain the expressions that are to be evaluated.","title":"Input Arguments"},{"location":"data-management/databank/eval.html#output-arguments","text":"output [ * ] Result of the expression evaluated in the inputDb workspace. outputs [ cell ] Results of the expressions evaluated in the inputDb workspace. outputDb [ struct | Dictionary ] Output databank with the results of the expressions evaluated in the inputDb workspace.","title":"Output Arguments"},{"location":"data-management/databank/eval.html#description","text":"Any names, including dot-separated composite names, not immediately followed by an opening parenthesis (round bracket), are treated as inputDb fields. Dot=separated composite names are therefore considered to be fields of databanks nested withing the inputDb . Any names, including dot-separated composite names, immediately followed by an opening parenthesis (round bracket), are considered calls to functions, and not treated as inputDb fields. To include round-bracket references to inputDb fields (such as references to elements of arrays), include an extra space between the name and the opening parenthesis.","title":"Description"},{"location":"data-management/databank/eval.html#example","text":"d = struct ( ); d . aaa = [ 1 , 2 , 3 ]; databank . eval ( '10*aaa(2)' ) will fail with a Matlab error unless there is function named aaa existing in the current workspace. This is because aaa(2) is considered to be a call to a function named aaa , and not a reference to the field existing in the databank d . To refer the second element of the field aaa , include an extra space between aaa and ( databank . eval ( '10*aaa (2)' )","title":"Example"},{"location":"data-management/databank/fieldNames.html","text":"databank.fieldNames List of databank field names as a row vector of strings Syntax list = databank.fieldNames(db) Input Arguments db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object. Output Arguments list [ string ] List of all field names contained in the input db , arranged as a row vector of strings. Description The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop. Example d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"fieldNames"},{"location":"data-management/databank/fieldNames.html#databankfieldnames","text":"List of databank field names as a row vector of strings","title":"databank.fieldNames"},{"location":"data-management/databank/fieldNames.html#syntax","text":"list = databank.fieldNames(db)","title":"Syntax"},{"location":"data-management/databank/fieldNames.html#input-arguments","text":"db [ struct | Dictionary ] Databank, i.e. a struct or Dicionary object.","title":"Input Arguments"},{"location":"data-management/databank/fieldNames.html#output-arguments","text":"list [ string ] List of all field names contained in the input db , arranged as a row vector of strings.","title":"Output Arguments"},{"location":"data-management/databank/fieldNames.html#description","text":"The databank.keys function shadows the standard function fieldnames . However, the output argument is rearranged as a row vector of strings, and hence can be directly plugged into a for loop.","title":"Description"},{"location":"data-management/databank/fieldNames.html#example","text":"d = struct (); d . x = Series ( mm ( 2020 , 01 ), rand ( 24 , 1 )); d . y = Series ( yy ( 2010 ), rand ( 20 , 1 )); d . z = Series ( qq ( 2015 , 1 ), rand ( 40 , 1 )); for n = databank . fieldNames ( d ) startDateString = toDefaultString ( getStart ( d .( n )) p ); disp ( n + \": \" + startDateString ); end","title":"Example"},{"location":"data-management/databank/filterFields.html","text":"databank.filterFields Get the names of databank fields that pass name or value tests Syntax list = databank.filterFields(inputDb, ...) Input Arguments inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values. Output Arguments list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests. Options __ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test. Description Example","title":"filterFields"},{"location":"data-management/databank/filterFields.html#databankfilterfields","text":"Get the names of databank fields that pass name or value tests","title":"databank.filterFields"},{"location":"data-management/databank/filterFields.html#syntax","text":"list = databank.filterFields(inputDb, ...)","title":"Syntax"},{"location":"data-management/databank/filterFields.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databanks whose fields will be tested for their names, types (classes) and values.","title":"Input Arguments"},{"location":"data-management/databank/filterFields.html#output-arguments","text":"list [ string ] List of the inputDb fields that have successfully passed the name, class and value tests.","title":"Output Arguments"},{"location":"data-management/databank/filterFields.html#options","text":"__ Name=@all [ @all | function ] Function (function handle) that will be applied to each field name; the Name function must return a true or false for any field name; @all means all fields pass the name test. __ Class=@all [ @all | string ] List of classes against which the value of each inputDb field will be tested; @all mean all fields pass the class test. Value=@all [ @all | function ] Function (function handle) that will be applied to each field value; the Value function must return a true or false for any field value; @all means all fields pass the value test.","title":"Options"},{"location":"data-management/databank/filterFields.html#description","text":"","title":"Description"},{"location":"data-management/databank/filterFields.html#example","text":"","title":"Example"},{"location":"data-management/databank/fromCSV.html","text":"databank.fromCSV Create databank by loading CSV file Syntax outputDb = databank.fromCSV(fileName, ...) Input Arguments fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined. Output Arguments outputDb [ struct | Dictionary ] Database created from the input CSV file(s). Options AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series. Description Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example). Structure of CSV Data Files The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | Example Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"fromCSV"},{"location":"data-management/databank/fromCSV.html#databankfromcsv","text":"Create databank by loading CSV file","title":"databank.fromCSV"},{"location":"data-management/databank/fromCSV.html#syntax","text":"outputDb = databank.fromCSV(fileName, ...)","title":"Syntax"},{"location":"data-management/databank/fromCSV.html#input-arguments","text":"fileName [ string ] Name of the Input CSV data file or a cell array of CSV file names that will be combined.","title":"Input Arguments"},{"location":"data-management/databank/fromCSV.html#output-arguments","text":"outputDb [ struct | Dictionary ] Database created from the input CSV file(s).","title":"Output Arguments"},{"location":"data-management/databank/fromCSV.html#options","text":"AddToDatabank [ struct | Dictionary ] Add the data loaded from the input file to an existing databank (struct or Dictionary); the format (Matlab class) of AddToDatabank= must comply with option OutputType= . Case=\"\" [ \"lower\" | \"upper\" | \"\" ] Change case of variable names. CommentsRow=[\"Comment\", \"Comments\"] [ string ] Label at the start of row that will be used to create comments in time series. Continuous=false [ false | \"descending\" | \"ascending\" ] Indicate that dates are a continuous range, either acending or descending. DateFormat=\"YYYYFP\" [ string ] Format of dates in first column. Delimiter=\",\" [ string ] Delimiter separating the individual values (cells) in the CSV file; if different from a comma, all occurences of the delimiter will replaced with commas -- note that this will also affect text in comments. FirstDateOnly=false [ true | false ] Read and parse only the first date string, and fill in the remaining dates assuming a range of consecutive dates. EnforceFrequency=false [ Frequency | false ] Advise frequency of dates; if empty, frequency will be attempted to be automatically recognized from the date string (only possible if the date format contains the frequency letter). NamesHeader=[\"\", \"Variables\", \"Time\"] [ string | numeric ] String, or a vector of strings, that is at the beginning (in the first cell) of the row with variable names, or the line number at which the row with variable names appears (first row is numbered 1). NamesFunc=[ ] [ cell | function_handle | empty ] Function used to change or transform the variable names. If a cell array of function handles, each function will be applied in the given order. NaN=\"NaN\" [ string ] String representing missing observations (case insensitive). OutputType=\"struct\" [ \"struct\" | \"Dictionary\" ] Format (Matlab class) of the output databank. Preprocess=[ ] [ function_handle | cell | empty ] Apply this function, or cell array of functions, to the raw text file before parsing the data. Select=@all [ @all | string | empty ] Only databank entries included on this list will be read in and returned in the output databank outputDb ; entries not on this list will be discarded; @all means all entries found in the CSV file will be included in the outputDb . SkipRows=[ ] [ char | string | numeric | empty ] Skip rows whose first cell matches the string or strings (regular expressions); or, skip a vector of row numbers. DatabankUserData=Inf [ string | Inf ] Field name under which the databank-wide user data loaded from the CSV file (if they exist) will be stored in the output databank; Inf means the field name will be read from the CSV file (and will be thus identical to the originally saved databank). UserDataField=\".\" [ string ] A leading character denoting user data fields for individual time series; if empty, no user data fields will be read in and created. UserDataFieldList=[] [ string | numeric | empty ] List of row headers, or vector of row numbers, that will be included as user data in each time series.","title":"Options"},{"location":"data-management/databank/fromCSV.html#description","text":"Use the \"EnforeFrequency=\" option whenever there is ambiguity in intepreting the date strings, and IRIS is not able to determine the frequency correctly (see Example).","title":"Description"},{"location":"data-management/databank/fromCSV.html#structure-of-csv-data-files","text":"The minimalist structure of a CSV data file has a leading row with variables names, a leading column with dates in the basic IRIS format, and individual columns with numeric data: | | Y | P | |---------|---------|---------|-- | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can add a comment row (must be placed before the data part, and start with a label \"Comment\" in the first cell) that will also be read in and assigned as comments to the individual Series objects created in the output databank. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | | You can use a different label in the first cell to denote a comment row; in that case you need to set the option CommentsRow= accordingly. All CSV rows whose names start with a character specified in the option UserDataField= (a dot by default) will be added to output Series objects as fields of their user data. | | Y | P | |---------|---------|---------|-- | Comment | Output | Prices | | .Source | Stat | IMFIFS | | .Update | 17Feb11 | 01Feb11 | | .Units | Bil USD | 2010=1 | | 2010Q1 | 1 | 10 | | 2010Q2 | 2 | 20 | | | | |","title":"Structure of CSV Data Files"},{"location":"data-management/databank/fromCSV.html#example","text":"Typical example of using the EnforeFrequency= option is a quarterly databank with dates represented by the corresponding months, such as a sequence 2000-01-01, 2000-04-01, 2000-07-01, 2000-10-01, etc. In this case, you can use the following options: d = databank.fromCSV( ... \"MyDataFile.csv\" ... , \"dateFormat=\", \"YYYY-MM-01\" ... , \"enforeFrequency=\", Frequency.QUARTERLY ... ); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/databank/list.html","text":"databank.list List databank fields adding date range to time series fields Syntax databank.list(db) Input Arguments db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields. Description Example d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"list"},{"location":"data-management/databank/list.html#databanklist","text":"List databank fields adding date range to time series fields","title":"databank.list"},{"location":"data-management/databank/list.html#syntax","text":"databank.list(db)","title":"Syntax"},{"location":"data-management/databank/list.html#input-arguments","text":"db [ struct | Dictionary ] Databank whose fields will be listed on the screen, with information on date ranges added to time series fields.","title":"Input Arguments"},{"location":"data-management/databank/list.html#description","text":"","title":"Description"},{"location":"data-management/databank/list.html#example","text":"d = struct (); d . a = 1 ; d . b = Series ( qq ( 2020 , 1 ), rand ( 20 , 1 )); d . c = Series ( yy ( 2020 ), rand ( 10 , 1 )); d . d = \"abcd\" ; databank . list ( d )","title":"Example"},{"location":"data-management/databank/merge.html","text":"databank.merge Merge two or more databanks Syntax outputDb = databank.merge(method, primaryDb [, otherDb ], ...) Input Arguments method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb . Output Arguments outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method . Options MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" . Description The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown. Example","title":"merge"},{"location":"data-management/databank/merge.html#databankmerge","text":"Merge two or more databanks","title":"databank.merge"},{"location":"data-management/databank/merge.html#syntax","text":"outputDb = databank.merge(method, primaryDb [, otherDb ], ...)","title":"Syntax"},{"location":"data-management/databank/merge.html#input-arguments","text":"method [ \"horzcat\" | \"vertcat\" | \"replace\" | \"discard\" | \"error\" ] Action to perform when two or more of the input mergeWith contain a field of the same name; see Description. primaryDb [ struct | Dictionary ] Primary input databank that will be merged with the other input mergeWith, d1 , etc. using the method . otherDb [ struct | Dictionary ] One or more mergeWith which will be merged with the primaryinput databank primaryDb to create the outputDb .","title":"Input Arguments"},{"location":"data-management/databank/merge.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank created by merging the input mergeWith using the method specified by the method .","title":"Output Arguments"},{"location":"data-management/databank/merge.html#options","text":"MissingField=@rmfield [ @rmfield | NaN | [ ] | * ] Action to perform when a field is missing from one or more of the input mergeWith when the method is \"horzcat\" .","title":"Options"},{"location":"data-management/databank/merge.html#description","text":"The fields from each of the additional mergeWith ( d1 and further) are added to the main databank d . If the name of a field to be added already exists in the main databank, d , one of the following actions is performed: \"horzcat\" - the fields will be horizontally concatenated; \"replace\" - the field in the main databank will be replaced with the new field; \"discard\" - the field in the main databank will be kept unchanged, and the new field will be discarded; \"error\" - an error will be thrown.","title":"Description"},{"location":"data-management/databank/merge.html#example","text":"","title":"Example"},{"location":"data-management/databank/minusControl.html","text":"minusControl Create simulation-minus-control database Syntax [outputDb, controlDb] = databank.minusControl(model, inputDb, ...) [outputDb, controlDb] = databank.minusControl(model, inputDb, controlDb, ...) Input arguments __ model [ model ] Model object on which the databases inputDb and controlDb __ are based. inputDb [ struct ] Simulation (or any other kind of) databank from which the controlDb will be subtracted. ^__ controlDb [ struct ] Control database that will be subtracted form the inputDb ; if omitted a steady-state databank for the model is created and used in the place of the control databank. Output arguments outputData [ struct ] Simulation-minus-control database, in which all log variables are inputDb.x/controlDb.x , and all other variables are inputDb.x-controlDb.x . controlDb [ struct ] Control database that has been subtracted from the inputDb database to create outputDb . Options Range=Inf [ Dater | Inf ] This range is used in two places: if a controlDb is not supplied, the model steady-state databank is created with the Range= input argument (meaning the control databank will exist on this range plus any necessary presample and postsample periods); if opt.Range refers to -Inf or Inf , then the control databank is created on an all-encompassing range of the inputDb . each model variable time series is clipped to the Range= before being included in the outputDb . Description Example Run a shock simulation in full levels using a steady-state (or balanced-growth-path) database as input, and then compute the deviations from the steady state: d = steadydb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , prependInput = true ); s = databank . minusControl ( m , s , d ); or simply s = databank . minusControl ( m , s ); The above block of code is equivalent to this one: d = zerodb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , deviation = true , prependInput = true );","title":"minusControl"},{"location":"data-management/databank/minusControl.html#minuscontrol","text":"Create simulation-minus-control database","title":"minusControl"},{"location":"data-management/databank/minusControl.html#syntax","text":"[outputDb, controlDb] = databank.minusControl(model, inputDb, ...) [outputDb, controlDb] = databank.minusControl(model, inputDb, controlDb, ...)","title":"Syntax"},{"location":"data-management/databank/minusControl.html#input-arguments","text":"__ model [ model ] Model object on which the databases inputDb and controlDb __ are based. inputDb [ struct ] Simulation (or any other kind of) databank from which the controlDb will be subtracted. ^__ controlDb [ struct ] Control database that will be subtracted form the inputDb ; if omitted a steady-state databank for the model is created and used in the place of the control databank.","title":"Input arguments"},{"location":"data-management/databank/minusControl.html#output-arguments","text":"outputData [ struct ] Simulation-minus-control database, in which all log variables are inputDb.x/controlDb.x , and all other variables are inputDb.x-controlDb.x . controlDb [ struct ] Control database that has been subtracted from the inputDb database to create outputDb .","title":"Output arguments"},{"location":"data-management/databank/minusControl.html#options","text":"Range=Inf [ Dater | Inf ] This range is used in two places: if a controlDb is not supplied, the model steady-state databank is created with the Range= input argument (meaning the control databank will exist on this range plus any necessary presample and postsample periods); if opt.Range refers to -Inf or Inf , then the control databank is created on an all-encompassing range of the inputDb . each model variable time series is clipped to the Range= before being included in the outputDb .","title":"Options"},{"location":"data-management/databank/minusControl.html#description","text":"","title":"Description"},{"location":"data-management/databank/minusControl.html#example","text":"Run a shock simulation in full levels using a steady-state (or balanced-growth-path) database as input, and then compute the deviations from the steady state: d = steadydb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , prependInput = true ); s = databank . minusControl ( m , s , d ); or simply s = databank . minusControl ( m , s ); The above block of code is equivalent to this one: d = zerodb ( m , 1 : 40 ); % Set up a shock or shocks here s = simulate ( m , d , 1 : 40 , deviation = true , prependInput = true );","title":"Example"},{"location":"data-management/databank/range.html","text":"range Find a range that encompasses the ranges of all or selected databank time series Syntax [range, listFreq] = databank.range(inputDb, ...) Input Arguments inputDb [ struct | containers.Map | Dictionary ] Input databank; can be either a struct, a containers.Map, or a Dictionary. Output Arguments range [ Dater | cell ] Range that encompasses the observations of the time series in the input database; if time series with different frequencies are contained in the inputDb then the ranges, one for each of the frequency, are returned in a cell array. listFreq [ numeric ] Vector of date frequencies coresponding to the returned ranges. Options SourceNames=@all [ string | Rexp | @all ] List of time series that will be included in the range search or a regular expression that will be matched to compose the list; @all means all time series objects existing in the input databases will be included. StartDate=\"unbalanced\" [ \"unbalanced\" ] StartDate=\"unbalanced\" means the output range will start at the earliest start date among all them time series included in the search; StartDate=\"balanced\" means the range will start at the latest start date. EndDate=\"unbalanced\" [ \"unbalanced\" | \"balanced\" ] EndDate=\"unbalanced\" means the range will end at the latest end date among all the time series included in the search; EndDate=\"balanced\" means the range will end at the earliest end date. Description Example","title":"range"},{"location":"data-management/databank/range.html#range","text":"Find a range that encompasses the ranges of all or selected databank time series","title":"range"},{"location":"data-management/databank/range.html#syntax","text":"[range, listFreq] = databank.range(inputDb, ...)","title":"Syntax"},{"location":"data-management/databank/range.html#input-arguments","text":"inputDb [ struct | containers.Map | Dictionary ] Input databank; can be either a struct, a containers.Map, or a Dictionary.","title":"Input Arguments"},{"location":"data-management/databank/range.html#output-arguments","text":"range [ Dater | cell ] Range that encompasses the observations of the time series in the input database; if time series with different frequencies are contained in the inputDb then the ranges, one for each of the frequency, are returned in a cell array. listFreq [ numeric ] Vector of date frequencies coresponding to the returned ranges.","title":"Output Arguments"},{"location":"data-management/databank/range.html#options","text":"SourceNames=@all [ string | Rexp | @all ] List of time series that will be included in the range search or a regular expression that will be matched to compose the list; @all means all time series objects existing in the input databases will be included. StartDate=\"unbalanced\" [ \"unbalanced\" ] StartDate=\"unbalanced\" means the output range will start at the earliest start date among all them time series included in the search; StartDate=\"balanced\" means the range will start at the latest start date. EndDate=\"unbalanced\" [ \"unbalanced\" | \"balanced\" ] EndDate=\"unbalanced\" means the range will end at the latest end date among all the time series included in the search; EndDate=\"balanced\" means the range will end at the earliest end date.","title":"Options"},{"location":"data-management/databank/range.html#description","text":"","title":"Description"},{"location":"data-management/databank/range.html#example","text":"","title":"Example"},{"location":"data-management/databank/retrieveColumns.html","text":"databank.retrieveColumns Retrieve selected columns from databank fields Syntax outputDb = function(inputDb, refs,...) Input Arguments inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd). Output Arguments outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails . Options WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb . Description Example","title":"retrieveColumns"},{"location":"data-management/databank/retrieveColumns.html#databankretrievecolumns","text":"Retrieve selected columns from databank fields","title":"databank.retrieveColumns"},{"location":"data-management/databank/retrieveColumns.html#syntax","text":"outputDb = function(inputDb, refs,...)","title":"Syntax"},{"location":"data-management/databank/retrieveColumns.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank from whose fields the selected columns given by the ref will be extracted and included in the outputDb . refs [ numeric | cell ] References to columns that will be retrieved from the fields of the inputDb ; the references can be either numeric (refering to 2nd dimension) or a cell array (referring to multiple dimensions starting from 2nd).","title":"Input Arguments"},{"location":"data-management/databank/retrieveColumns.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank with the fields from the inputDb reduced to the selected columns refs ; what happens when the columns cannot be retrieved from a field is determined by the option WhenFails .","title":"Output Arguments"},{"location":"data-management/databank/retrieveColumns.html#options","text":"WhenFails=\"remove\" [ \"error\" | \"keep\" | \"remove\" ] This option determines what happens when an attempt to reference and retrieve the selected columns from a field fails (when Matlab throws an error): \"error\" - an error will be thrown listing the failed fields; \"keep\" - the field will be kept in the outputDb unchanged; \"remove\" - the field will be removed from the outputDb .","title":"Options"},{"location":"data-management/databank/retrieveColumns.html#description","text":"","title":"Description"},{"location":"data-management/databank/retrieveColumns.html#example","text":"","title":"Example"},{"location":"data-management/databank/toArray.html","text":"databank.toArray Create numeric array from time series data Syntax [outputArray, names, dates] = databank.toArray(inputDb, names, dates, columns) Input arguments inputDb [ struct | Dictionary ] Input databank from which the time series data will be retrieved and converted to a numeric array. names [ string | @all ] List of time series names whose data will be retrieved from the inputDb ; names=@all means all time series fields will be included. dates [ Dater | \"unbalanced\" | \"balanced\" ] Dates for which the time series data will be retrieved; the date frequency of the dates must be consistent with the date frequency of all time series listed in names . dates=Inf is the same as dates=\"unbalanced\" . dates=\"unbalanced\" means the dates will be automatically determined to cover an unbalanced panel of data (the earliest available observation among all time series to the latest). dates=\"balanced\" means the dates will automatically determined to cover a balanced panel of data (the earliest data at which data are available for all time series to the latest date at which data are available for all time series). columns=1 [ numeric ] Column or columns that will be retrieved from the time series data; if multiple columns are specified, the data will be flattened in 2nd dimension; columns=1 if omitted. Output arguments outputArray [ numeric ] Numeric array created from the time series data from the fields listed in names and dates specified in dates . names [ string ] The names of the time series included in the outputArray ; useful when the input argument names=@all . dates [ Dater ] The dates for which the time series data were retrieved and included in the outputArray ; useful when the input argument dates=Inf . Description Examples","title":"toArray"},{"location":"data-management/databank/toArray.html#databanktoarray","text":"Create numeric array from time series data","title":"databank.toArray"},{"location":"data-management/databank/toArray.html#syntax","text":"[outputArray, names, dates] = databank.toArray(inputDb, names, dates, columns)","title":"Syntax"},{"location":"data-management/databank/toArray.html#input-arguments","text":"inputDb [ struct | Dictionary ] Input databank from which the time series data will be retrieved and converted to a numeric array. names [ string | @all ] List of time series names whose data will be retrieved from the inputDb ; names=@all means all time series fields will be included. dates [ Dater | \"unbalanced\" | \"balanced\" ] Dates for which the time series data will be retrieved; the date frequency of the dates must be consistent with the date frequency of all time series listed in names . dates=Inf is the same as dates=\"unbalanced\" . dates=\"unbalanced\" means the dates will be automatically determined to cover an unbalanced panel of data (the earliest available observation among all time series to the latest). dates=\"balanced\" means the dates will automatically determined to cover a balanced panel of data (the earliest data at which data are available for all time series to the latest date at which data are available for all time series). columns=1 [ numeric ] Column or columns that will be retrieved from the time series data; if multiple columns are specified, the data will be flattened in 2nd dimension; columns=1 if omitted.","title":"Input arguments"},{"location":"data-management/databank/toArray.html#output-arguments","text":"outputArray [ numeric ] Numeric array created from the time series data from the fields listed in names and dates specified in dates . names [ string ] The names of the time series included in the outputArray ; useful when the input argument names=@all . dates [ Dater ] The dates for which the time series data were retrieved and included in the outputArray ; useful when the input argument dates=Inf .","title":"Output arguments"},{"location":"data-management/databank/toArray.html#description","text":"","title":"Description"},{"location":"data-management/databank/toArray.html#examples","text":"","title":"Examples"},{"location":"data-management/databank/toCSV.html","text":"databank.toCSV Write databank to CSV file Syntax fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...) Input Arguments inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date. Output Arguments fieldsSaved [ string ] List of databank fields that have been written to the output file fileName . Options NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. TargetNames=[] [ empty | function ] Function transforming the databank field names to the names under which the data are saved in the CSV file; TargetNames=[] means no transformation. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field. Description Example Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field. Example D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"toCSV"},{"location":"data-management/databank/toCSV.html#databanktocsv","text":"Write databank to CSV file","title":"databank.toCSV"},{"location":"data-management/databank/toCSV.html#syntax","text":"fieldsSaved = databank.toCSV(inputDb, fileName, dates, ...)","title":"Syntax"},{"location":"data-management/databank/toCSV.html#input-arguments","text":"inputDatabank [ struct | Dictionary ] Input databank whose time series and numeric entries will be serialized to a character vector. fileName [ string ] Name of a CSV file to which the databank will be saved. dates [ Dater | Inf ] Dates or date range on which the time series will be saved; Inf means a date range from the earliest date found in the inputDatabank to the latest date.","title":"Input Arguments"},{"location":"data-management/databank/toCSV.html#output-arguments","text":"fieldsSaved [ string ] List of databank fields that have been written to the output file fileName .","title":"Output Arguments"},{"location":"data-management/databank/toCSV.html#options","text":"NamesHeader=\"Variables->\" [ string ] String that will be put in the top-left corncer (cell A1). Class=true [ true | false ] Include a row with class and size specifications. Comments=true [ true | false ] Include a row with comments for time series. Decimals=[ ] [ numeric ] Number of decimals up to which the data will be saved; if empty the numeric format is taken from the option Format . Format=\"%.8e\" [ string ] Numeric format that will be used to represent the data, see sprintf for details on formatting, The format must start with a \"%\" , and must not include identifiers specifying order of processing, i.e. the \"$\" signs, or left-justify flags, the \"-\" signs. FreqLetters=[\"Y\", \"H\", \"Q\", \"M\", \"W\"] [ string ] Vector of five letters to represent the five possible date frequencies except daily and integer (annual, semi-annual, quarterly, monthly, weekly). MatchFreq=false [ true | false ] Save only those time series whose date frequencies match the input vector of dates . NaN=\"NaN\" [ string ] String to represent NaN values. TargetNames=[] [ empty | function ] Function transforming the databank field names to the names under which the data are saved in the CSV file; TargetNames=[] means no transformation. UserDataFields=[] [ empty | string ] List of user data fields that will be extracted from each time series object, and saved to the CSV file; the name of the row where each user data field is saved is .xxx where xxx is the name of the user data field.","title":"Options"},{"location":"data-management/databank/toCSV.html#description","text":"","title":"Description"},{"location":"data-management/databank/toCSV.html#example","text":"Create a simple database with two time series. D = struct( ); D.x = Series(qq(2010, 1):qq(2010, 4), @rand); D.y = Series(qq(2010, 1):qq(2010, 4), @rand); Add your own description of the database, e.g. D.UserData = {'My database', datestr(now( ))}; Save the database as CSV using databank.toCSV , databank.toCSV(D, 'mydatabase.csv'); When you later load the database, D = databank.fromCSV('mydatabase.csv') D = UserData: {'My database' '23-Sep-2011 14:10:17'} x: [4x1 Series] y: [4x1 Series] the database will preserve the 'UserData'' field.","title":"Example"},{"location":"data-management/databank/toCSV.html#example_1","text":"D = struct ( ); D . x = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); D . y = Series ( qq ( 2010 , 1 ): qq ( 2010 , 4 ), @ rand ); databank . toCSV ( D , 'datafile.csv' , Inf )","title":"Example"},{"location":"data-management/databank/withEmpty.html","text":"databank.withEmpty Create databank with empty time series Syntax outputDb = databank.withEmpty(names, ...) Input Arguments __ names [ char | cellstr | string ] List of names under which new empty time series will be created. Output Arguments __ outputDb [ struct ] Databank with the new empty time series created or added. Options AddToDatabank=struct() [ struct ] Add the new empty time series to this databank. Description Example","title":"withEmpty"},{"location":"data-management/databank/withEmpty.html#databankwithempty","text":"Create databank with empty time series","title":"databank.withEmpty"},{"location":"data-management/databank/withEmpty.html#syntax","text":"outputDb = databank.withEmpty(names, ...)","title":"Syntax"},{"location":"data-management/databank/withEmpty.html#input-arguments","text":"__ names [ char | cellstr | string ] List of names under which new empty time series will be created.","title":"Input Arguments"},{"location":"data-management/databank/withEmpty.html#output-arguments","text":"__ outputDb [ struct ] Databank with the new empty time series created or added.","title":"Output Arguments"},{"location":"data-management/databank/withEmpty.html#options","text":"AddToDatabank=struct() [ struct ] Add the new empty time series to this databank.","title":"Options"},{"location":"data-management/databank/withEmpty.html#description","text":"","title":"Description"},{"location":"data-management/databank/withEmpty.html#example","text":"","title":"Example"},{"location":"data-management/dates/index.html","text":"Dates IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with limited support to business daily) integer (numbered observations) Categorical List of Functions Creating Dates Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations) Converting Dates Function Description toString Print IrisT dates as formatted strings","title":"Introduction"},{"location":"data-management/dates/index.html#dates","text":"IrisT dates are designed to provide convenience for handling dates spaced at regular intervals throughout a calendar year, with native support for the following date frequencies: yearly half-yearly quarterly monthly weekly daily (with limited support to business daily) integer (numbered observations)","title":"Dates"},{"location":"data-management/dates/index.html#categorical-list-of-functions","text":"","title":"Categorical List of Functions"},{"location":"data-management/dates/index.html#creating-dates","text":"Function Description yy Create yearly dates hh Create half-yearly dates qq Create quarterly dates mm Create monthly dates ww Create weekly dates dd Create daily dates ii Create integer dates (numbered observations)","title":"Creating Dates"},{"location":"data-management/dates/index.html#converting-dates","text":"Function Description toString Print IrisT dates as formatted strings","title":"Converting Dates"},{"location":"data-management/dates/dd.html","text":"dd | Dater.dd | dater.dd Create daily dates Shortcut syntax for Dater objects date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year) Syntax for Dater objects date = Dater.dd(...) Syntax for numeric date codes date = dater.dd(...) Input arguments year [ numeric ] Calendar year. month=1 [ numeric ] Calendar month. day=1 [ numeric ] Week of the year; \"end\" means the last day of the respective month (considering leap years for February). Output arguments date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode. Description The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers. Example Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"dd"},{"location":"data-management/dates/dd.html#dd-daterdd-daterdd","text":"Create daily dates","title":"dd  |  Dater.dd  |  dater.dd"},{"location":"data-management/dates/dd.html#shortcut-syntax-for-dater-objects","text":"date = dd(year, month, day) date = dd(year, month, \"end\") date = dd(year, month) date = dd(year)","title":"Shortcut syntax for Dater objects"},{"location":"data-management/dates/dd.html#syntax-for-dater-objects","text":"date = Dater.dd(...)","title":"Syntax for Dater objects"},{"location":"data-management/dates/dd.html#syntax-for-numeric-date-codes","text":"date = dater.dd(...)","title":"Syntax for numeric date codes"},{"location":"data-management/dates/dd.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric ] Calendar month. day=1 [ numeric ] Week of the year; \"end\" means the last day of the respective month (considering leap years for February).","title":"Input arguments"},{"location":"data-management/dates/dd.html#output-arguments","text":"date [ Dater ] Daily date returned as a Dater object. dateCode [ numeric ] Daily date returned as a numeric datecode.","title":"Output arguments"},{"location":"data-management/dates/dd.html#description","text":"The underlying date codes of daily dates is exactly the same as the standard Matlab serial date numbers.","title":"Description"},{"location":"data-management/dates/dd.html#example","text":"Calculate the number of days between two daily dates t1 = dd(2020,02,01); t2 = dd(2020,02,\"end\"); n = t2 - t1","title":"Example"},{"location":"data-management/dates/hh.html","text":"hh | Dater.hh | dater.hh Create half-yearly dates Shortcut syntax to create Dater objects date = hh(year, half) date = hh(year, \"end\") date = hh(year) Syntax to create Dater objects date = hh(...) Syntax to create numeric date codes dateCode = dater.hh(...) Input arguments year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 . Output arguments date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode. Description Example Calculate the number of halfyears between two halfyearly dates t1 = hh ( 2020 , 1 ); t2 = hh ( 2024 , 2 ); n = t2 - t1","title":"hh"},{"location":"data-management/dates/hh.html#hh-daterhh-daterhh","text":"Create half-yearly dates","title":"hh  |  Dater.hh  |  dater.hh"},{"location":"data-management/dates/hh.html#shortcut-syntax-to-create-dater-objects","text":"date = hh(year, half) date = hh(year, \"end\") date = hh(year)","title":"Shortcut syntax to create Dater objects"},{"location":"data-management/dates/hh.html#syntax-to-create-dater-objects","text":"date = hh(...)","title":"Syntax to create Dater objects"},{"location":"data-management/dates/hh.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.hh(...)","title":"Syntax to create numeric date codes"},{"location":"data-management/dates/hh.html#input-arguments","text":"year [ numeric ] Calendar year. half=1 [ numeric ] Halfyear of the year; \"end\" means half=2 .","title":"Input arguments"},{"location":"data-management/dates/hh.html#output-arguments","text":"date [ Dater ] Halfyearly date returned as a Dater object. dateCode [ numeric ] Halfyearly date returned as a numeric datecode.","title":"Output arguments"},{"location":"data-management/dates/hh.html#description","text":"","title":"Description"},{"location":"data-management/dates/hh.html#example","text":"Calculate the number of halfyears between two halfyearly dates t1 = hh ( 2020 , 1 ); t2 = hh ( 2024 , 2 ); n = t2 - t1","title":"Example"},{"location":"data-management/dates/ii.html","text":"ii | Dater.ii | dater.ii Create integer dates (numbered observations) Shortcut Syntax to Create Dater Objects date = ii(integer) Syntax to Create Dater Objects date = Dater.ii(...) Syntax to Create Numeric Date Codes dateCode = dater.ii(...) Input Arguments integer [ numeric ] Integer number, any non-integers will be floored. Output Arguments date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode. Description This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed. Example Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"ii"},{"location":"data-management/dates/ii.html#ii-daterii-daterii","text":"Create integer dates (numbered observations)","title":"ii  |  Dater.ii  |  dater.ii"},{"location":"data-management/dates/ii.html#shortcut-syntax-to-create-dater-objects","text":"date = ii(integer)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/ii.html#syntax-to-create-dater-objects","text":"date = Dater.ii(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/ii.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.ii(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"data-management/dates/ii.html#input-arguments","text":"integer [ numeric ] Integer number, any non-integers will be floored.","title":"Input Arguments"},{"location":"data-management/dates/ii.html#output-arguments","text":"date [ Dater ] Integer date returned as a Dater object. dateCode [ numeric ] Inteeger date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/ii.html#description","text":"This function is unnecessary and exists for consistency only; simply use plain vectors of integers when integer dates are needed.","title":"Description"},{"location":"data-management/dates/ii.html#example","text":"Create time series whose observations are numbered 1:10 (no calendar dates): x = Series(ii(1:10), @rand); Instead of ii(1:10) , simply use 1:10 : x = Series(1:10, @rand);","title":"Example"},{"location":"data-management/dates/mm.html","text":"mm | Dater.mm | dater.mm Create monthly dates Shortcut Syntax to Create Dater Objects date = mm(year, month) date = mm(year, \"end\") date = mm(year) Syntax to Create Dater Objects date = mm(...) Syntax to Create Numeric Date Codes dateCode = dater.mm(...) Input Arguments year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 . Output Arguments date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode. Description Example Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"mm"},{"location":"data-management/dates/mm.html#mm-datermm-datermm","text":"Create monthly dates","title":"mm  |  Dater.mm  |  dater.mm"},{"location":"data-management/dates/mm.html#shortcut-syntax-to-create-dater-objects","text":"date = mm(year, month) date = mm(year, \"end\") date = mm(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/mm.html#syntax-to-create-dater-objects","text":"date = mm(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/mm.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.mm(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"data-management/dates/mm.html#input-arguments","text":"year [ numeric ] Calendar year. month=1 [ numeric ] Month of the year; \"end\" means month=12 .","title":"Input Arguments"},{"location":"data-management/dates/mm.html#output-arguments","text":"date [ Dater ] Monthly date returned as a Dater object. dateCode [ numeric ] Monthly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/mm.html#description","text":"","title":"Description"},{"location":"data-management/dates/mm.html#example","text":"Calculate the number of months between two monthly dates t1 = mm(2020,01); t2 = mm(2023,12); n = t2 - t1","title":"Example"},{"location":"data-management/dates/qq.html","text":"qq | Dater.qq | dater.qq Create quarterly dates Syntax shortcuts to create dater objects date = qq(year, quarter) date = qq(year, \"end\") date = qq(year) Syntax to create dater objects date = Dater.qq(...) Syntax to create numeric date codes dateCode = dater.qq(...) Input arguments year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 . Output arguments date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode. Description Examples Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"qq"},{"location":"data-management/dates/qq.html#qq-daterqq-daterqq","text":"Create quarterly dates","title":"qq  |  Dater.qq  |  dater.qq"},{"location":"data-management/dates/qq.html#syntax-shortcuts-to-create-dater-objects","text":"date = qq(year, quarter) date = qq(year, \"end\") date = qq(year)","title":"Syntax shortcuts to create dater objects"},{"location":"data-management/dates/qq.html#syntax-to-create-dater-objects","text":"date = Dater.qq(...)","title":"Syntax to create dater objects"},{"location":"data-management/dates/qq.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.qq(...)","title":"Syntax to create numeric date codes"},{"location":"data-management/dates/qq.html#input-arguments","text":"year [ numeric ] Calendar year. quarter=1 [ numeric | \"end\" ] Quarter of the year; \"end\" means quarter=4 .","title":"Input arguments"},{"location":"data-management/dates/qq.html#output-arguments","text":"date [ Dater ] Quarterly date returned as a Dater object. dateCode [ numeric ] Quarterly date returned as a numeric datecode.","title":"Output arguments"},{"location":"data-management/dates/qq.html#description","text":"","title":"Description"},{"location":"data-management/dates/qq.html#examples","text":"Calculate the number of quarters between two quarterly dates t1 = qq(2020,1); t2 = qq(2020,4); n = t2 - t1","title":"Examples"},{"location":"data-management/dates/toString.html","text":"toString Print IrisT dates as formatted strings Syntax outputString = toString(inputDate, format) Input Arguments inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string. Output Arguments outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format . Options Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Description The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed Example of Plain Vanilla Date Formatting Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\" Example of Open / Close Options Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"toString"},{"location":"data-management/dates/toString.html#tostring","text":"Print IrisT dates as formatted strings","title":"toString"},{"location":"data-management/dates/toString.html#syntax","text":"outputString = toString(inputDate, format)","title":"Syntax"},{"location":"data-management/dates/toString.html#input-arguments","text":"inputDate [ Dater | numeric ] Input date (a Dater object or a plain numeric representation) that will be printed as a string.","title":"Input Arguments"},{"location":"data-management/dates/toString.html#output-arguments","text":"outputString [ string ] Output string printed from the inputDate . format [ string ] Formatting string; see Description for formatting tokens that can be used in the format .","title":"Output Arguments"},{"location":"data-management/dates/toString.html#options","text":"Open=\"\" [ string ] String to denote the beginning of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters. Close=\"\" [ string ] String to denote the end of a date formating token; use the options Open and Close to handle more complex date formatting strings where you need to include literal text containing some of the formatting characters.","title":"Options"},{"location":"data-management/dates/toString.html#description","text":"The formatting string may consist of date formatting tokens and literal text. If you need to use plain literal text whose part or parts coincide with the formatting tokens, use the options Open and/or Close to delineate those tokens and differentiate them from plain literal text; see Example of Open/Close options. This is the list of the date formatting tokens available; all date formatting tokens are case sensitive: Token Result \"yyyy\" Four-digit year \"yy\" Last two digits of the year \"y\" Plain numeric year with as many digits as needed \"mmmm\" Full name of the month \"mmm\" Three-letter abbreviation of the month name \"mm\" Two-digit month \"m\" Plain numeric month with as many digits as needed \"n\" Month in lower-case romanu numeral \"N\" Month in upper-case romanu numeral \"pp\" Two-digit period \"p\" Plain numeric period with as many digits as needed \"r\" Period in lower-case roman numerals \"R\" Period in upper-case roman numerals \"f\" Frequency in lower-case letter \"F\" Frequency in upper-case letter \"dd\" Two-digit day \"d\" Plain numeric day with as many digits as needed","title":"Description"},{"location":"data-management/dates/toString.html#example-of-plain-vanilla-date-formatting","text":"Format Dater objects: t = qq(2020,1); toString(t, \"yyyy-p\") Format plain numeric dates: t = dater.qq(2020,1); dater.toString(t, \"yyyy-p\"); ans = \"2020-1\"","title":"Example of Plain Vanilla Date Formatting"},{"location":"data-management/dates/toString.html#example-of-openclose-options","text":"Print a quarterly date as \"y2020-q1\" . Because the leading literal \"y\" conflicts with the formatting token \"y\" , specify at least one of the options Open and/or Close to differentiate between plain text and formatting tokens: def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] cccc t = qq(2020,1) toString(t, \"y(yyyy)-q(p)\", \"open\", \"(\", \"close\", \")\") ans = \"y2020-q1\" Alternatively, do the same using the option Open only: t = qq ( 2020 , 1 ) toString ( t , \"y%yyyy-q%p\" , \"open\" , \"%\" ) ans = \"y2020-q1\"","title":"Example of Open/Close Options"},{"location":"data-management/dates/ww.html","text":"ww | Dater.ww | dater.ww Create weekly dates Shortcut Syntax to Create Dater Objects date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day) Syntax to Create Dater Objects date = Dater.ww(...) Syntax to Create Plain Numeric Date Codes dateCode = dater.ww(...) Input Arguments year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601. Output Arguments date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode. Description Example Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"ww"},{"location":"data-management/dates/ww.html#ww-daterww-daterww","text":"Create weekly dates","title":"ww  |  Dater.ww  |  dater.ww"},{"location":"data-management/dates/ww.html#shortcut-syntax-to-create-dater-objects","text":"date = ww(year, week) date = ww(year, \"end\") date = ww(year) date = ww(year, month, day)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/ww.html#syntax-to-create-dater-objects","text":"date = Dater.ww(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/ww.html#syntax-to-create-plain-numeric-date-codes","text":"dateCode = dater.ww(...)","title":"Syntax to Create Plain Numeric Date Codes"},{"location":"data-management/dates/ww.html#input-arguments","text":"year [ numeric ] Calendar year. week=1 [ numeric ] Week of the year; \"end\" means week=52 or week=53 depending on the number of weeks in the year as defined by ISO-8601.","title":"Input Arguments"},{"location":"data-management/dates/ww.html#output-arguments","text":"date [ Dater ] Weekly date returned as a Dater object. dateCode [ numeric ] Weekly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/ww.html#description","text":"","title":"Description"},{"location":"data-management/dates/ww.html#example","text":"Calculate the number of weeks between two weekly dates t1 = ww ( 2020 , 1 ); t2 = ww ( 2020 , \"end\" ); n = t2 - t1","title":"Example"},{"location":"data-management/dates/yy.html","text":"yy | Dater.yy | dater.yy Create yearly dates Shortcut Syntax to Create Dater Objects date = yy(year) Syntax to Create Dater Objects date = Dater.yy(...) Syntax to Create Numeric Date Codes dateCode = dater.yy(...) Input Arguments year [ numeric ] Calendar year. Output Arguments date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode. Description Example Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"yy"},{"location":"data-management/dates/yy.html#yy-dateryy-dateryy","text":"Create yearly dates","title":"yy  |  Dater.yy  |  dater.yy"},{"location":"data-management/dates/yy.html#shortcut-syntax-to-create-dater-objects","text":"date = yy(year)","title":"Shortcut Syntax to Create Dater Objects"},{"location":"data-management/dates/yy.html#syntax-to-create-dater-objects","text":"date = Dater.yy(...)","title":"Syntax to Create Dater Objects"},{"location":"data-management/dates/yy.html#syntax-to-create-numeric-date-codes","text":"dateCode = dater.yy(...)","title":"Syntax to Create Numeric Date Codes"},{"location":"data-management/dates/yy.html#input-arguments","text":"year [ numeric ] Calendar year.","title":"Input Arguments"},{"location":"data-management/dates/yy.html#output-arguments","text":"date [ Dater ] Yearly date returned as a Dater object. dateCode [ numeric ] Yearly date returned as a numeric datecode.","title":"Output Arguments"},{"location":"data-management/dates/yy.html#description","text":"","title":"Description"},{"location":"data-management/dates/yy.html#example","text":"Calculate the number of years between two yearly dates t1 = yy(2020); t2 = yy(2024); n = t2 - t1","title":"Example"},{"location":"data-management/imf/index.html","text":"Interfact to [IMF Data Portal] Categorical list of functions Download time series Function Description databank.fromCSV.data Download databank of time series from IMF Data Portal Download meta data and dataset structure information Function Description databank.fromCSV.datasets Download list of datasets from IMF Data Portal databank.fromCSV.codes Download code lists from IMF Data Portal","title":"Introduction"},{"location":"data-management/imf/index.html#interfact-to-imf-data-portal","text":"","title":"Interfact to [IMF Data Portal]"},{"location":"data-management/imf/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"data-management/imf/index.html#download-time-series","text":"Function Description databank.fromCSV.data Download databank of time series from IMF Data Portal","title":"Download time series"},{"location":"data-management/imf/index.html#download-meta-data-and-dataset-structure-information","text":"Function Description databank.fromCSV.datasets Download list of datasets from IMF Data Portal databank.fromCSV.codes Download code lists from IMF Data Portal","title":"Download meta data and dataset structure information"},{"location":"data-management/imf/codes.html","text":"databank.fromIMF.codes Download code lists from IMF Data Portal","title":"codes"},{"location":"data-management/imf/codes.html#databankfromimfcodes","text":"Download code lists from IMF Data Portal","title":"databank.fromIMF.codes"},{"location":"data-management/imf/data.html","text":"databank.fromIMF.data Download databank of time series from IMF Data Portal Syntax for Two-Dimensional Requests [outputDb, info] = databank.fromIMF.data(datasetId, frequency, areas, items, ...) Syntax for Three-Dimensional Requests outputDb = databank.fromIMF.data(datasetId, frequency, areas, items, counters, ...) Input Arguments databankId [ string ] IMF dataset ID; only one dataset is allowed in one data request. frequency [ Frequency ] Date frequency for the output time series; the frequency must be yearly, quarterly or monthly; only one frequency is allowed in one data request. areas [ string ] List of reference areas for which the output time series will be retrieved; an empty string or emtpy array means all reference areas. items [ string ] List of indicators that will be retrieved for each of the areas . counter=empty [ string ] List of counterparty reference areas for which the output time series will be retrieved; counterparty reference areas are needed for only some of the IMF databanks, such as Directions of Trade Statistics (DOT); an empty string or empty array means all counterparty reference areas. Output Arguments outputDb [ struct | Dictionary ] Output databank with time series retrieved from an IMF databank. info [ struct ] Output information struct with the following fields: .Request - the entire request string (including the URL) .Response - a JSON struct with the IMF data portal response Options for HTTP Request EndDate=-Inf [ Dater ] End date for the data requested; -Inf means the date of the latest observation for each series. StartDate=-Inf [ Dater ] Start date for the data requested; -Inf means the date of the earliest observation for each series. URL=\"http://dataservices.imf.org/REST/SDMX_JSON.svc/CompactData/\" [ string ] URL for the IMF data portal HTTP request. WebOptions=weboptions(\"Timeout\", 9999) [ weboption ] A weboptions object with HTTP settings. Options for Output Databank AddToDatabank=struct() [ struct | Dictionary ] Add the output time series to this databank. ApplyMultiplier=true [ true | false ] Apply the unit multiplier to the output time series data, scaling them to basic units (e.g. from millions). Options for Output Time Series Names NameFunc=[] [ empty | function_handle ] Function that will be applied to each time series name before it is stored in the outputDb . IncludeArea=true [ true | false ] Include the respective reference area code as a prefix in the name of each output time series. IncludeCounter=true [ true | false ] Three-dimensional requests only (with counterparty reference area): Include the respective counterparty reference area code as a suffix in the name of each output time series. Separator=\"_\" [ string ] Separator used in the area prefix and/or the counterparty area suffix in the output time series names. Description This function returns a databank of time series from the IMF data portal. To create a data request, you need to know the IMF dataset code, the reference area code(s), the indicator code(s), and for three-dimensional requests, also the counterparty reference area code(s). Leaving the reference area code, the indicator code or the counterparty reference area code empty will return data for all of those that exist in that dimension. The IMF data portal has bandwith restrictions. Sometimes, requests returning larger amounts of data need to be split into smaller, more specific requests. Sometimes, the function needs to be called several times before an actual data response is returned. Examples Two-Dimensional Requests Most of the IMF data requests need two dimensions to be specified: the reference area and the indicator (the concept). From the IMF IFS dataset, retrieve quarterly nominal GDP in localy currency for the US: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , \"NGDP_XDC\" ) Retrieve nominal GDP in localy currency for all areas (countries and regions) for which this indicator is available: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , [], \"NGDP_XDC\" ) Retrieve all indicators available from the IMF IFS databank for the US; do not include the country prefix (here, \"US_\") in the names of the output time series: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , [], \"includeArea\" , false ) Three-Dimensional Requests From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to Euro Area (code \"U2\"): d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , \"U2\" ); From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to all reported areas: d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , []);","title":"data"},{"location":"data-management/imf/data.html#databankfromimfdata","text":"Download databank of time series from IMF Data Portal","title":"databank.fromIMF.data"},{"location":"data-management/imf/data.html#syntax-for-two-dimensional-requests","text":"[outputDb, info] = databank.fromIMF.data(datasetId, frequency, areas, items, ...)","title":"Syntax for Two-Dimensional Requests"},{"location":"data-management/imf/data.html#syntax-for-three-dimensional-requests","text":"outputDb = databank.fromIMF.data(datasetId, frequency, areas, items, counters, ...)","title":"Syntax for Three-Dimensional Requests"},{"location":"data-management/imf/data.html#input-arguments","text":"databankId [ string ] IMF dataset ID; only one dataset is allowed in one data request. frequency [ Frequency ] Date frequency for the output time series; the frequency must be yearly, quarterly or monthly; only one frequency is allowed in one data request. areas [ string ] List of reference areas for which the output time series will be retrieved; an empty string or emtpy array means all reference areas. items [ string ] List of indicators that will be retrieved for each of the areas . counter=empty [ string ] List of counterparty reference areas for which the output time series will be retrieved; counterparty reference areas are needed for only some of the IMF databanks, such as Directions of Trade Statistics (DOT); an empty string or empty array means all counterparty reference areas.","title":"Input Arguments"},{"location":"data-management/imf/data.html#output-arguments","text":"outputDb [ struct | Dictionary ] Output databank with time series retrieved from an IMF databank. info [ struct ] Output information struct with the following fields: .Request - the entire request string (including the URL) .Response - a JSON struct with the IMF data portal response","title":"Output Arguments"},{"location":"data-management/imf/data.html#options-for-http-request","text":"EndDate=-Inf [ Dater ] End date for the data requested; -Inf means the date of the latest observation for each series. StartDate=-Inf [ Dater ] Start date for the data requested; -Inf means the date of the earliest observation for each series. URL=\"http://dataservices.imf.org/REST/SDMX_JSON.svc/CompactData/\" [ string ] URL for the IMF data portal HTTP request. WebOptions=weboptions(\"Timeout\", 9999) [ weboption ] A weboptions object with HTTP settings.","title":"Options for HTTP Request"},{"location":"data-management/imf/data.html#options-for-output-databank","text":"AddToDatabank=struct() [ struct | Dictionary ] Add the output time series to this databank. ApplyMultiplier=true [ true | false ] Apply the unit multiplier to the output time series data, scaling them to basic units (e.g. from millions).","title":"Options for Output Databank"},{"location":"data-management/imf/data.html#options-for-output-time-series-names","text":"NameFunc=[] [ empty | function_handle ] Function that will be applied to each time series name before it is stored in the outputDb . IncludeArea=true [ true | false ] Include the respective reference area code as a prefix in the name of each output time series. IncludeCounter=true [ true | false ] Three-dimensional requests only (with counterparty reference area): Include the respective counterparty reference area code as a suffix in the name of each output time series. Separator=\"_\" [ string ] Separator used in the area prefix and/or the counterparty area suffix in the output time series names.","title":"Options for Output Time Series Names"},{"location":"data-management/imf/data.html#description","text":"This function returns a databank of time series from the IMF data portal. To create a data request, you need to know the IMF dataset code, the reference area code(s), the indicator code(s), and for three-dimensional requests, also the counterparty reference area code(s). Leaving the reference area code, the indicator code or the counterparty reference area code empty will return data for all of those that exist in that dimension. The IMF data portal has bandwith restrictions. Sometimes, requests returning larger amounts of data need to be split into smaller, more specific requests. Sometimes, the function needs to be called several times before an actual data response is returned.","title":"Description"},{"location":"data-management/imf/data.html#examples","text":"","title":"Examples"},{"location":"data-management/imf/data.html#two-dimensional-requests","text":"Most of the IMF data requests need two dimensions to be specified: the reference area and the indicator (the concept). From the IMF IFS dataset, retrieve quarterly nominal GDP in localy currency for the US: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , \"NGDP_XDC\" ) Retrieve nominal GDP in localy currency for all areas (countries and regions) for which this indicator is available: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , [], \"NGDP_XDC\" ) Retrieve all indicators available from the IMF IFS databank for the US; do not include the country prefix (here, \"US_\") in the names of the output time series: d = databank . fromIMF . data ( \"IFS\" , Frequency . QUARTERLY , \"US\" , [], \"includeArea\" , false )","title":"Two-Dimensional Requests"},{"location":"data-management/imf/data.html#three-dimensional-requests","text":"From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to Euro Area (code \"U2\"): d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , \"U2\" ); From the IMF DOT databank (Directions of Trade Statistics), retrieve yearly exports from US to all reported areas: d = databank . fromIMF . data ( \"DOT\" , Frequency . YEARLY , \"US\" , \"TXG_FOB_USD\" , []);","title":"Three-Dimensional Requests"},{"location":"data-management/imf/datasets.html","text":"databank.fromIMF.datasets Download list of datasets from IMF Data Portal","title":"datasets"},{"location":"data-management/imf/datasets.html#databankfromimfdatasets","text":"Download list of datasets from IMF Data Portal","title":"databank.fromIMF.datasets"},{"location":"data-management/series/index.html","text":"Time series Categorical list of functions Creating new time series Function Description Series Create new time series object Series.linearTrend Create time series with linear trend Series.empty Create empty time series or empty existing time series Series.seasonDummy Create time series with seasonal dummies Series.randomlyGrowing Create randomly growing time series Modifying time series Function Description rebase Rebase times series data to specified period Filtering and aggregating time series Function Description moving Apply function to moving window of time series observations chainlink Calculate chain linked aggregate level series from level components and weights Regression and statistics Function Description regress Ordinary or weighted least-square regression","title":"Introduction"},{"location":"data-management/series/index.html#time-series","text":"","title":"Time series"},{"location":"data-management/series/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"data-management/series/index.html#creating-new-time-series","text":"Function Description Series Create new time series object Series.linearTrend Create time series with linear trend Series.empty Create empty time series or empty existing time series Series.seasonDummy Create time series with seasonal dummies Series.randomlyGrowing Create randomly growing time series","title":"Creating new time series"},{"location":"data-management/series/index.html#modifying-time-series","text":"Function Description rebase Rebase times series data to specified period","title":"Modifying time series"},{"location":"data-management/series/index.html#filtering-and-aggregating-time-series","text":"Function Description moving Apply function to moving window of time series observations chainlink Calculate chain linked aggregate level series from level components and weights","title":"Filtering and aggregating time series"},{"location":"data-management/series/index.html#regression-and-statistics","text":"Function Description regress Ordinary or weighted least-square regression","title":"Regression and statistics"},{"location":"data-management/series/Series.html","text":"Series Create new time series object Syntax X = Series() X = Series(dates, values) X = Series(dates, values, comments) X = Series(dates, values, comments, userData) Input Arguments dates [ numeric | char ] Dates for which observations will be supplied; dates do not need to be sorted in ascending order or create a continuous date range. If dates is scalar and values have multiple rows, then the date is interpreted as the start date for the entire time series. values [ numeric | function_handle ] Numerical values (observations) arranged columnwise, or a function that will be used to create an N-by-1 array of values, where N is the number of dates . comments [ string ] Comment(s) attached to each column of the time series; if omitted, comments will be empty strings. userData [ * ] Any kind of user data attached to the object; if omitted, user data will be empty; if userData is a struct, the Series methods accessUserData and assignUserData can be used access or assign/change them. Output Arguments x [ Series ] New times series. Description Example x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), @ rand , \"Random numbers\" );","title":"Series"},{"location":"data-management/series/Series.html#series","text":"Create new time series object","title":"Series"},{"location":"data-management/series/Series.html#syntax","text":"X = Series() X = Series(dates, values) X = Series(dates, values, comments) X = Series(dates, values, comments, userData)","title":"Syntax"},{"location":"data-management/series/Series.html#input-arguments","text":"dates [ numeric | char ] Dates for which observations will be supplied; dates do not need to be sorted in ascending order or create a continuous date range. If dates is scalar and values have multiple rows, then the date is interpreted as the start date for the entire time series. values [ numeric | function_handle ] Numerical values (observations) arranged columnwise, or a function that will be used to create an N-by-1 array of values, where N is the number of dates . comments [ string ] Comment(s) attached to each column of the time series; if omitted, comments will be empty strings. userData [ * ] Any kind of user data attached to the object; if omitted, user data will be empty; if userData is a struct, the Series methods accessUserData and assignUserData can be used access or assign/change them.","title":"Input Arguments"},{"location":"data-management/series/Series.html#output-arguments","text":"x [ Series ] New times series.","title":"Output Arguments"},{"location":"data-management/series/Series.html#description","text":"","title":"Description"},{"location":"data-management/series/Series.html#example","text":"x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ), rand ( 8 , 1 ), \"Random numbers\" ); x = Series ( qq ( 2020 , 1 ): qq ( 2021 , 4 ), @ rand , \"Random numbers\" );","title":"Example"},{"location":"data-management/series/chainlink.html","text":"chainlink Calculate chain linked aggregate level series from level components and weights Syntax [aggregateLevel, aggregateRate, info] = chainlink(levels, weights, ...) Input arguments levels [ Series ] Time series with level data of components that will be chain link aggregated. weights [ Series ] Time series with weights of the input components levels . Output arguments aggregateLevel [ Series ] Aggregate level series calculated by chain linking the levels components with weights . aggregateRate [ Series ] Aggregate rates of change relative with the end period of previous year set as the base period. info [ struct ] Output information struct with the following fields: .Rates - rates of change in the individual components with the end period of previous year set as the base period; .Weights - component weights; may potentially differ from the input weights because of normalization; see the option NormalizeWeights= . Options Range=Inf [ Inf | Dater ] Date range on which the aggregation will be calculated; Inf means the entire range available in levels and weights . RebaseDates=[] [ empty | Dates ] Dates of observations whose average will be used to rebase the resulting level aggregate; empty dates means to rebasing is performed. NormalizeWeights=true [ true | false ] Normalize the input weights so that they sum up to 1 in each period. Description Examples","title":"chainlink"},{"location":"data-management/series/chainlink.html#chainlink","text":"Calculate chain linked aggregate level series from level components and weights","title":"chainlink"},{"location":"data-management/series/chainlink.html#syntax","text":"[aggregateLevel, aggregateRate, info] = chainlink(levels, weights, ...)","title":"Syntax"},{"location":"data-management/series/chainlink.html#input-arguments","text":"levels [ Series ] Time series with level data of components that will be chain link aggregated. weights [ Series ] Time series with weights of the input components levels .","title":"Input arguments"},{"location":"data-management/series/chainlink.html#output-arguments","text":"aggregateLevel [ Series ] Aggregate level series calculated by chain linking the levels components with weights . aggregateRate [ Series ] Aggregate rates of change relative with the end period of previous year set as the base period. info [ struct ] Output information struct with the following fields: .Rates - rates of change in the individual components with the end period of previous year set as the base period; .Weights - component weights; may potentially differ from the input weights because of normalization; see the option NormalizeWeights= .","title":"Output arguments"},{"location":"data-management/series/chainlink.html#options","text":"Range=Inf [ Inf | Dater ] Date range on which the aggregation will be calculated; Inf means the entire range available in levels and weights . RebaseDates=[] [ empty | Dates ] Dates of observations whose average will be used to rebase the resulting level aggregate; empty dates means to rebasing is performed. NormalizeWeights=true [ true | false ] Normalize the input weights so that they sum up to 1 in each period.","title":"Options"},{"location":"data-management/series/chainlink.html#description","text":"","title":"Description"},{"location":"data-management/series/chainlink.html#examples","text":"","title":"Examples"},{"location":"data-management/series/convert.html","text":"convert Convert time series to another frequency Syntax outputSeries = convert(inputSeries, newFreq, ...) outputSeries = convert(inputSeries, newFreq, range, ...) Input Arguments inputSeries [ Series ] Input time series that will be converted to a new frequency, freq , aggregating or intrapolating the data. newFreq [ Frequency ] New frequency to which the input data will be converted; see Description for frequency formats allowed. range=Inf [ Dater ] Date range on which the input data will be converted; Inf means the conversion will be done on the entire time series range. Output Arguments outputSeries [ Series ] Output tseries created by converting the inputSeries to the new frequency (aggregating or interpolating). Options RemoveNaN=false [ true | false ] Exclude NaN values from agreggation. Missing=@default [ @default | numeric | \"previous\" | \"next\" ] Fill missing observations with this value before conversion: @default means no preprocessing; \"previous\" or \"next\" means fill in the nearest preceding or nearest following value available in the time series. Options for High- to Low-Frequency Aggregation Method=\"mean\" [ \"mean\" | \"sum\" | \"first\" | \"last\" | function_handle ] Aggregation method; \"first\" , \"last\" and \"random\" select the first, last or a random observation from the high-frequency periods contained in the correspoding low-frequency period. RemoveWeekends=false [ true | false ] For daily frequency time series only: remove all weekend observations before aggregation. Select=Inf [ numeric ] Select only these high-frequency observations within each low-frequency period; Inf means all observations will be used. Options for Low- to High-Frequency Interpolation Method=\"pchip\" [ string | \"quadSum\" | \"quadMean\" | \"flat\" | \"first\" | \"last\" ] Interpolation method; any option valid for the built-in function interp1 can be used, or 'QuadSum' or 'QuadMean' ; these two options use quadratic interpolation preserving the sum or the average of observations within each period. Position=\"center\" [ \"center\" | \"start\" | \"end\" ] Position of dates within each period in the low-frequency date grid. RemoveWeekends=false [ true | false ] For interpolation to daily frequency only: replace all weekend observations in the final time series (after interpolation) with NaN (or the default missing value as defined in the time series object property .MissingValue ). Description The function handle that you pass in through the Method option when you aggregate the data (convert higher frequency to lower frequency) should behave like the built-in functions mean , sum etc. In other words, it is expected to accept two input arguments: the data to be aggregated; the dimension along which the aggregation is calculated. The function will be called with the second input argument set to 1, as the data are processed en block columnwise. If this call fails, convert() will attempt to call the function with just one input argument, the data, but this is not a safe option under some circumstances since dimension mismatch may occur. Example -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"convert"},{"location":"data-management/series/convert.html#convert","text":"Convert time series to another frequency","title":"convert"},{"location":"data-management/series/convert.html#syntax","text":"outputSeries = convert(inputSeries, newFreq, ...) outputSeries = convert(inputSeries, newFreq, range, ...)","title":"Syntax"},{"location":"data-management/series/convert.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be converted to a new frequency, freq , aggregating or intrapolating the data. newFreq [ Frequency ] New frequency to which the input data will be converted; see Description for frequency formats allowed. range=Inf [ Dater ] Date range on which the input data will be converted; Inf means the conversion will be done on the entire time series range.","title":"Input Arguments"},{"location":"data-management/series/convert.html#output-arguments","text":"outputSeries [ Series ] Output tseries created by converting the inputSeries to the new frequency (aggregating or interpolating).","title":"Output Arguments"},{"location":"data-management/series/convert.html#options","text":"RemoveNaN=false [ true | false ] Exclude NaN values from agreggation. Missing=@default [ @default | numeric | \"previous\" | \"next\" ] Fill missing observations with this value before conversion: @default means no preprocessing; \"previous\" or \"next\" means fill in the nearest preceding or nearest following value available in the time series.","title":"Options"},{"location":"data-management/series/convert.html#options-for-high-to-low-frequency-aggregation","text":"Method=\"mean\" [ \"mean\" | \"sum\" | \"first\" | \"last\" | function_handle ] Aggregation method; \"first\" , \"last\" and \"random\" select the first, last or a random observation from the high-frequency periods contained in the correspoding low-frequency period. RemoveWeekends=false [ true | false ] For daily frequency time series only: remove all weekend observations before aggregation. Select=Inf [ numeric ] Select only these high-frequency observations within each low-frequency period; Inf means all observations will be used.","title":"Options for High- to Low-Frequency Aggregation"},{"location":"data-management/series/convert.html#options-for-low-to-high-frequency-interpolation","text":"Method=\"pchip\" [ string | \"quadSum\" | \"quadMean\" | \"flat\" | \"first\" | \"last\" ] Interpolation method; any option valid for the built-in function interp1 can be used, or 'QuadSum' or 'QuadMean' ; these two options use quadratic interpolation preserving the sum or the average of observations within each period. Position=\"center\" [ \"center\" | \"start\" | \"end\" ] Position of dates within each period in the low-frequency date grid. RemoveWeekends=false [ true | false ] For interpolation to daily frequency only: replace all weekend observations in the final time series (after interpolation) with NaN (or the default missing value as defined in the time series object property .MissingValue ).","title":"Options for Low- to High-Frequency Interpolation"},{"location":"data-management/series/convert.html#description","text":"The function handle that you pass in through the Method option when you aggregate the data (convert higher frequency to lower frequency) should behave like the built-in functions mean , sum etc. In other words, it is expected to accept two input arguments: the data to be aggregated; the dimension along which the aggregation is calculated. The function will be called with the second input argument set to 1, as the data are processed en block columnwise. If this call fails, convert() will attempt to call the function with just one input argument, the data, but this is not a safe option under some circumstances since dimension mismatch may occur.","title":"Description"},{"location":"data-management/series/convert.html#example","text":"-[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/series/empty.html","text":"Series.empty Create empty time series or empty existing time series Syntax x = Series.empty([0, size, ...]) x = Series.empty(0, size, ...) x = Series.empty(x) Input Arguments size [ numeric ] Size of new time series in 2nd and higher dimensions; first dimenstion (time) must be always 0. this [ Series ] Input time series that will be emptied. Output Arguments this [ Series ] Empty time series with the 2nd and higher dimensions the same size as the input time series, and comments preserved. Description Examples Plain Vanilla Example Create a 12-by-3-by-2 monthly time series, and then use Series.empty to create a new, empty series with now rows but the same size in 2nd and higher dimensions x = Series ( mm ( 2020 , 01 ), rand ( 12 , 3 , 2 )) x0 = Series . empty ( x )","title":"empty"},{"location":"data-management/series/empty.html#seriesempty","text":"Create empty time series or empty existing time series","title":"Series.empty"},{"location":"data-management/series/empty.html#syntax","text":"x = Series.empty([0, size, ...]) x = Series.empty(0, size, ...) x = Series.empty(x)","title":"Syntax"},{"location":"data-management/series/empty.html#input-arguments","text":"size [ numeric ] Size of new time series in 2nd and higher dimensions; first dimenstion (time) must be always 0. this [ Series ] Input time series that will be emptied.","title":"Input Arguments"},{"location":"data-management/series/empty.html#output-arguments","text":"this [ Series ] Empty time series with the 2nd and higher dimensions the same size as the input time series, and comments preserved.","title":"Output Arguments"},{"location":"data-management/series/empty.html#description","text":"","title":"Description"},{"location":"data-management/series/empty.html#examples","text":"","title":"Examples"},{"location":"data-management/series/empty.html#plain-vanilla-example","text":"Create a 12-by-3-by-2 monthly time series, and then use Series.empty to create a new, empty series with now rows but the same size in 2nd and higher dimensions x = Series ( mm ( 2020 , 01 ), rand ( 12 , 3 , 2 )) x0 = Series . empty ( x )","title":"Plain Vanilla Example"},{"location":"data-management/series/fillMissing.html","text":"fillMissings Fill missing time series observations Syntax outputSeries = fillMissing(inputSeries, range, method) outputSeries = fillMissing(inputSeries, range, method, specs) outputSeries = fillMissing(inputSeries, range, anotherSeries) Input Arguments inputSeries [ Series ] Input time series whose missing entries lying within the range will be filled with values determined by the method or from anotherSeries . range [ Dater | Inf ] Date range within which missing entries will be looked up in the inputSeries and filled with values determined by the method or from anotherSeries . method [ string | Series ] String specifying the method to obtain missing observations, or a time series with replacement values. The method can be any of the methods valid in the built-in fillmissing() function (see help fillmissing ) or one of the regression methods provided by IrisT: \"regressConstant\" , \"regressTrend\" or \"regressLogTrend\" for a regression on a constant, a regression on a constant and a linear time trend, and a log-regression on a constant and a time trend, respectively. specs [ * ] Some of the methods in the built-in fillmissing() function require addition specification (see help fillmissing ). anotherSeries [ Series ] Another time series whose values will be used to fill missing entries in the inputSeries . Output Arguments outputSeries [ Series ] Output time series whose missing observations found within the range have been filled with values given by the method or from anotherSeries . Description Example -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2019 [IrisToolbox] Solutions Team","title":"fillMissing"},{"location":"data-management/series/fillMissing.html#fillmissings","text":"Fill missing time series observations","title":"fillMissings"},{"location":"data-management/series/fillMissing.html#syntax","text":"outputSeries = fillMissing(inputSeries, range, method) outputSeries = fillMissing(inputSeries, range, method, specs) outputSeries = fillMissing(inputSeries, range, anotherSeries)","title":"Syntax"},{"location":"data-management/series/fillMissing.html#input-arguments","text":"inputSeries [ Series ] Input time series whose missing entries lying within the range will be filled with values determined by the method or from anotherSeries . range [ Dater | Inf ] Date range within which missing entries will be looked up in the inputSeries and filled with values determined by the method or from anotherSeries . method [ string | Series ] String specifying the method to obtain missing observations, or a time series with replacement values. The method can be any of the methods valid in the built-in fillmissing() function (see help fillmissing ) or one of the regression methods provided by IrisT: \"regressConstant\" , \"regressTrend\" or \"regressLogTrend\" for a regression on a constant, a regression on a constant and a linear time trend, and a log-regression on a constant and a time trend, respectively. specs [ * ] Some of the methods in the built-in fillmissing() function require addition specification (see help fillmissing ). anotherSeries [ Series ] Another time series whose values will be used to fill missing entries in the inputSeries .","title":"Input Arguments"},{"location":"data-management/series/fillMissing.html#output-arguments","text":"outputSeries [ Series ] Output time series whose missing observations found within the range have been filled with values given by the method or from anotherSeries .","title":"Output Arguments"},{"location":"data-management/series/fillMissing.html#description","text":"","title":"Description"},{"location":"data-management/series/fillMissing.html#example","text":"-[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2019 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/series/grow.html","text":"grow Cumulate level time series from differences or rates of growth Syntax outputSeries = grow(inputSeries, operator, changeSeries, dates) outputSeries = grow(inputSeries, operator, changeSeries, dates, shift) Input Arguments inputSeries [ Series ] Input time series including at least the initial condition for the level. operator [ \"diff\" | \"difflog\" | \"roc\" | \"pcr\" ] Function expressing the relationship between the resulting outputSeries and the input changeSeries . changeSeries [ Series | numeric ] Time series or numeric scalar specifying the change in the input time series (difference, difference of logs, gross rate of change, or percent change, see the input argument operator ). dates [ Dater ] Date range or a vector of dates on which the level series will be cumulated. shift=-1 [ numeric ] Negative number specifying the lag of the base period to which the change operator function applies. Output Arguments outputSeries [ Series ] Output time series constructed from the input time series, inputSeries , extended by its differences or growth rates, growth . Options Direction=\"forward\" [ \"forward\" | \"backward\" ] Direction of calculations in time; Direction=\"backward\" means that the calculations start from the last date in dates going backwards to the first one, and an inverse operator is applied. Description The function grow() calculates new values at dates (which may not constitute a continuous range, and be discrete time periods instead) using one of the the following formulas (depending on the operator ): $ x_t = x_{t-k} + g_t $ $ x_t = x_{t-k} \\cdot \\exp g_t $ $ x_t = x_{t-k} \\cdot g_t $ $ x_t = x_{t-k} \\cdot \\left( 1 + \\frac{g_t}{100} \\right) $ where $ k $ is a time lag specified by the input argument shift , and the values $ g_t $ are given by the second input series growth . Alternatively, the operator applied to $ x_{t-k} $ and $ g_t $ can be any user-specified function. Any values contained in the input time series inputSeries outside the dates are preserved in the output time series unchanged. Example Extend a quarterly time series x using the gross rates of growth calculated from another time series, y : x = grow(x, \"roc\", roc(y), qq(2020,1):qq(2030,4)); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"grow"},{"location":"data-management/series/grow.html#grow","text":"Cumulate level time series from differences or rates of growth","title":"grow"},{"location":"data-management/series/grow.html#syntax","text":"outputSeries = grow(inputSeries, operator, changeSeries, dates) outputSeries = grow(inputSeries, operator, changeSeries, dates, shift)","title":"Syntax"},{"location":"data-management/series/grow.html#input-arguments","text":"inputSeries [ Series ] Input time series including at least the initial condition for the level. operator [ \"diff\" | \"difflog\" | \"roc\" | \"pcr\" ] Function expressing the relationship between the resulting outputSeries and the input changeSeries . changeSeries [ Series | numeric ] Time series or numeric scalar specifying the change in the input time series (difference, difference of logs, gross rate of change, or percent change, see the input argument operator ). dates [ Dater ] Date range or a vector of dates on which the level series will be cumulated. shift=-1 [ numeric ] Negative number specifying the lag of the base period to which the change operator function applies.","title":"Input Arguments"},{"location":"data-management/series/grow.html#output-arguments","text":"outputSeries [ Series ] Output time series constructed from the input time series, inputSeries , extended by its differences or growth rates, growth .","title":"Output Arguments"},{"location":"data-management/series/grow.html#options","text":"Direction=\"forward\" [ \"forward\" | \"backward\" ] Direction of calculations in time; Direction=\"backward\" means that the calculations start from the last date in dates going backwards to the first one, and an inverse operator is applied.","title":"Options"},{"location":"data-management/series/grow.html#description","text":"The function grow() calculates new values at dates (which may not constitute a continuous range, and be discrete time periods instead) using one of the the following formulas (depending on the operator ): $ x_t = x_{t-k} + g_t $ $ x_t = x_{t-k} \\cdot \\exp g_t $ $ x_t = x_{t-k} \\cdot g_t $ $ x_t = x_{t-k} \\cdot \\left( 1 + \\frac{g_t}{100} \\right) $ where $ k $ is a time lag specified by the input argument shift , and the values $ g_t $ are given by the second input series growth . Alternatively, the operator applied to $ x_{t-k} $ and $ g_t $ can be any user-specified function. Any values contained in the input time series inputSeries outside the dates are preserved in the output time series unchanged.","title":"Description"},{"location":"data-management/series/grow.html#example","text":"Extend a quarterly time series x using the gross rates of growth calculated from another time series, y : x = grow(x, \"roc\", roc(y), qq(2020,1):qq(2030,4)); -[IrisToolbox] for Macroeconomic Modeling -Copyright (c) 2007-2020 [IrisToolbox] Solutions Team","title":"Example"},{"location":"data-management/series/linearTrend.html","text":"Series.linearTrend Create time series with linear trend Syntax x = Series.linearTrend(range) x = Series.linearTrend(range, step) x = Series.linearTrend(range, step, startValue) Input Arguments range [ Dater ] Date range on which the trend time series will be created. step=1 [ numeric ] Difference between two consecutive dates in the trend; if omitted, the increment of the trend will be 1. startValue=0 [ numeric ] Starting value for the trend; if omitted, the trend will startValue at zero. Output Arguments x [ Series ] Output time series with a linear trend. Description Example","title":"linearTrend"},{"location":"data-management/series/linearTrend.html#serieslineartrend","text":"Create time series with linear trend","title":"Series.linearTrend"},{"location":"data-management/series/linearTrend.html#syntax","text":"x = Series.linearTrend(range) x = Series.linearTrend(range, step) x = Series.linearTrend(range, step, startValue)","title":"Syntax"},{"location":"data-management/series/linearTrend.html#input-arguments","text":"range [ Dater ] Date range on which the trend time series will be created. step=1 [ numeric ] Difference between two consecutive dates in the trend; if omitted, the increment of the trend will be 1. startValue=0 [ numeric ] Starting value for the trend; if omitted, the trend will startValue at zero.","title":"Input Arguments"},{"location":"data-management/series/linearTrend.html#output-arguments","text":"x [ Series ] Output time series with a linear trend.","title":"Output Arguments"},{"location":"data-management/series/linearTrend.html#description","text":"","title":"Description"},{"location":"data-management/series/linearTrend.html#example","text":"","title":"Example"},{"location":"data-management/series/moving.html","text":"moving Apply function to moving window of time series observations Syntax outputSeries = moving(inputSeries, ...) Input arguments inputSeries [ Series ] Input times series. Output arguments outputSeries [ Series ] Output time series with their observations constructed by applying the the function Function= to a moving window Window= of observations from the inputSeries . Options Function=@mean [ function_handle ] Function to be applied to moving window of observations. By default, the function is supposed to accept two input arguments: an array of data, and the dimension along which the function will be calculated (this is the way the standard built-int @mean , @sum , etc. functions work). Period=false [ true | false ] Force the calculations to be put in a loop period by period and refrain from using dimension as a second input argument into the Function . This options works only when Window= is not a complex number (in which case the calculations are always period by period). Under the default Period=false , the function is evaluated on a whole array of observations, and supplied a second input argument 1 to indicate the dimension along which the function is to be calculated. This is consistent with standard functions such as mean , sum , etc. If Period=true , the function Function= is evaluated on a column vector of observations constituting the moving window for the current period only (determined by the Window= specification), one period at a time. Range=Inf [ Dater | Inf ] Date range to which the inputSeries will be trimmed before running the calculations. Window=@auto [ numeric | @auto ] The moving window of observations to which the function Function= will applied to construct the observations of the outputSeries ; see Description and Examples. Description The moving window of observations can be specificied in three different ways: Moving window Option Window= Comment Moving year of observations @auto The window depends on the date frequency of the inputSeries ; only available for yearly, half-yearly, quarterly and monthly frequencies Exact specification of lags and leads Vector of real integers Negative for lags, positive for leads, zero for current period Fixed number of non-missing observations Complex number (scalar) Negative imaginary part means the number of observations going back in time (starting from current), positive imaginary part means going forward in time Exact specification of moving window Use a vector of integers to specify an exact composition of the moving window. Negative numbers mean lags (observations before the current observation), positive numbers mean leads (observations after the current observation), zero means the current observation: \\[ \\begin{gathered} \\mathit{window} = \\left[ a, b, c, \\dots \\right] \\\\[5pt] y_t = f\\left( \\left[ x_{t+a}, x_{t+b}, x_{t+c}, \\dots \\right] \\right) \\end{gathered} \\] If some of the observations are missing, they are still included in the window (typically a NaN for plain numeric time series), and the result may be a missing observation again. This depends on the function used, consider, for instance, the difference between @mean and @nanmean . Moving window depending on the availability of observations Use a complex number (with a real part denoting the offset and the imaginary part specifying the length of the window) to specify a window consisting of a fixed number of available (non-missing) observations from the current observation backward, or from the current observation forward (positive imaginary part). The a nonzero offset means that the available (non-missing) observation will be looked up starting not from the current observation, but from an observation before (a negative offset) or after (a positive offset). If \\(\\mathit{window}=a + bi\\) , the algorithm is as follows: For each period \\(t\\) , define the output value \\(y_t\\) by applying the function \\(f\\) to a vector of a total of \\(b\\) observations from the input series \\(x_t\\) constructed as described in steps 2 and 3. If the window length (the imaginary part) \\(b\\) is a negative number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going backward, i.e. \\(x_{t+a}, x_{t+a-1}, x_{t+a-2}, \\dots\\) , all the way to the very first observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going backward. If the window length (the imaginary part) \\(b\\) is a positive number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going forward, i.e. \\(x_{t+a}, x_{t+a+1}, x_{t+a+2}, \\dots\\) , all the way to the very last observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going forward. Examples Centered moving average and sum Calculate a centered moving average with a total length of the window being 5 observations: x = moving ( x , \"window\" , [ - 2 , - 1 , 0 , 1 , 2 ]) or more concisely x = moving ( x , \"window\" , - 2 : 2 ) Calculate a moving sum on the same window of observations: x = moving(x, \"window\", -2:2, \"function\", @sum) Weighted centered moving average Supply a user defined function to calculate a weighted centered moving average (with the window specification as in the previous example); we have to use the option Period=true in this case because our function weightedAverage assumes that its input argument is only a vector of 5 numbers (the moving window of observations corresponding to the current period). func = @( x ) 0.10 * x ( 1 ) + 0.15 * x ( 2 ) + 0.50 * x ( 3 ) + 0.15 * x ( 4 ) + 0.10 * x ( 5 ); y = moving ( x , \"window\" , - 2 : 2 , \"function\" , func , \"period\" , true ) This is though equivalent to a more compact expression y = 0.10 * x { - 2 } + 0.15 * x { - 1 } + 0.50 * x + 0.15 * x { 1 } + 0.10 * x { 2 } Average of 5 last available observations Create a daily series of random observations, and remove weekends; the time series will therefore have NaN s in two out of every seven observations: x = Series ( dd ( 2000 , 1 , 1 ): dd ( 2020 , 12 , 31 ), @ randn ); x = removeWeekends ( x ); Create a time series by calculating the average of the five most recent observations available (i.e. excluding any missing observations): y0 = moving ( x , \"window\" , - 5 i ) Create a time series by calculating the average of the five most recent observations available as before, but now starting from the previous month (not including the current observation); in other words, select the latest available five observations among \\(x_{t-1}, x_{t-2}, \\dots\\) y1 = moving ( x , \"window\" , - 1 - 5 i )","title":"moving"},{"location":"data-management/series/moving.html#moving","text":"Apply function to moving window of time series observations","title":"moving"},{"location":"data-management/series/moving.html#syntax","text":"outputSeries = moving(inputSeries, ...)","title":"Syntax"},{"location":"data-management/series/moving.html#input-arguments","text":"inputSeries [ Series ] Input times series.","title":"Input arguments"},{"location":"data-management/series/moving.html#output-arguments","text":"outputSeries [ Series ] Output time series with their observations constructed by applying the the function Function= to a moving window Window= of observations from the inputSeries .","title":"Output arguments"},{"location":"data-management/series/moving.html#options","text":"Function=@mean [ function_handle ] Function to be applied to moving window of observations. By default, the function is supposed to accept two input arguments: an array of data, and the dimension along which the function will be calculated (this is the way the standard built-int @mean , @sum , etc. functions work). Period=false [ true | false ] Force the calculations to be put in a loop period by period and refrain from using dimension as a second input argument into the Function . This options works only when Window= is not a complex number (in which case the calculations are always period by period). Under the default Period=false , the function is evaluated on a whole array of observations, and supplied a second input argument 1 to indicate the dimension along which the function is to be calculated. This is consistent with standard functions such as mean , sum , etc. If Period=true , the function Function= is evaluated on a column vector of observations constituting the moving window for the current period only (determined by the Window= specification), one period at a time. Range=Inf [ Dater | Inf ] Date range to which the inputSeries will be trimmed before running the calculations. Window=@auto [ numeric | @auto ] The moving window of observations to which the function Function= will applied to construct the observations of the outputSeries ; see Description and Examples.","title":"Options"},{"location":"data-management/series/moving.html#description","text":"The moving window of observations can be specificied in three different ways: Moving window Option Window= Comment Moving year of observations @auto The window depends on the date frequency of the inputSeries ; only available for yearly, half-yearly, quarterly and monthly frequencies Exact specification of lags and leads Vector of real integers Negative for lags, positive for leads, zero for current period Fixed number of non-missing observations Complex number (scalar) Negative imaginary part means the number of observations going back in time (starting from current), positive imaginary part means going forward in time","title":"Description"},{"location":"data-management/series/moving.html#exact-specification-of-moving-window","text":"Use a vector of integers to specify an exact composition of the moving window. Negative numbers mean lags (observations before the current observation), positive numbers mean leads (observations after the current observation), zero means the current observation: \\[ \\begin{gathered} \\mathit{window} = \\left[ a, b, c, \\dots \\right] \\\\[5pt] y_t = f\\left( \\left[ x_{t+a}, x_{t+b}, x_{t+c}, \\dots \\right] \\right) \\end{gathered} \\] If some of the observations are missing, they are still included in the window (typically a NaN for plain numeric time series), and the result may be a missing observation again. This depends on the function used, consider, for instance, the difference between @mean and @nanmean .","title":"Exact specification of moving window"},{"location":"data-management/series/moving.html#moving-window-depending-on-the-availability-of-observations","text":"Use a complex number (with a real part denoting the offset and the imaginary part specifying the length of the window) to specify a window consisting of a fixed number of available (non-missing) observations from the current observation backward, or from the current observation forward (positive imaginary part). The a nonzero offset means that the available (non-missing) observation will be looked up starting not from the current observation, but from an observation before (a negative offset) or after (a positive offset). If \\(\\mathit{window}=a + bi\\) , the algorithm is as follows: For each period \\(t\\) , define the output value \\(y_t\\) by applying the function \\(f\\) to a vector of a total of \\(b\\) observations from the input series \\(x_t\\) constructed as described in steps 2 and 3. If the window length (the imaginary part) \\(b\\) is a negative number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going backward, i.e. \\(x_{t+a}, x_{t+a-1}, x_{t+a-2}, \\dots\\) , all the way to the very first observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going backward. If the window length (the imaginary part) \\(b\\) is a positive number: Take all observations starting from \\(x_{t+a}\\) (i.e. from the current observation if \\(a=0\\) , or from an observation before or after shifted by the offset \\(a\\) ) going forward, i.e. \\(x_{t+a}, x_{t+a+1}, x_{t+a+2}, \\dots\\) , all the way to the very last observation available. Exclude any missing observations from this collection. From the remaining non-missing observations, take a total of \\(b\\) observations starting from the most recent observation going forward.","title":"Moving window depending on the availability of observations"},{"location":"data-management/series/moving.html#examples","text":"","title":"Examples"},{"location":"data-management/series/moving.html#centered-moving-average-and-sum","text":"Calculate a centered moving average with a total length of the window being 5 observations: x = moving ( x , \"window\" , [ - 2 , - 1 , 0 , 1 , 2 ]) or more concisely x = moving ( x , \"window\" , - 2 : 2 ) Calculate a moving sum on the same window of observations: x = moving(x, \"window\", -2:2, \"function\", @sum)","title":"Centered moving average and sum"},{"location":"data-management/series/moving.html#weighted-centered-moving-average","text":"Supply a user defined function to calculate a weighted centered moving average (with the window specification as in the previous example); we have to use the option Period=true in this case because our function weightedAverage assumes that its input argument is only a vector of 5 numbers (the moving window of observations corresponding to the current period). func = @( x ) 0.10 * x ( 1 ) + 0.15 * x ( 2 ) + 0.50 * x ( 3 ) + 0.15 * x ( 4 ) + 0.10 * x ( 5 ); y = moving ( x , \"window\" , - 2 : 2 , \"function\" , func , \"period\" , true ) This is though equivalent to a more compact expression y = 0.10 * x { - 2 } + 0.15 * x { - 1 } + 0.50 * x + 0.15 * x { 1 } + 0.10 * x { 2 }","title":"Weighted centered moving average"},{"location":"data-management/series/moving.html#average-of-5-last-available-observations","text":"Create a daily series of random observations, and remove weekends; the time series will therefore have NaN s in two out of every seven observations: x = Series ( dd ( 2000 , 1 , 1 ): dd ( 2020 , 12 , 31 ), @ randn ); x = removeWeekends ( x ); Create a time series by calculating the average of the five most recent observations available (i.e. excluding any missing observations): y0 = moving ( x , \"window\" , - 5 i ) Create a time series by calculating the average of the five most recent observations available as before, but now starting from the previous month (not including the current observation); in other words, select the latest available five observations among \\(x_{t-1}, x_{t-2}, \\dots\\) y1 = moving ( x , \"window\" , - 1 - 5 i )","title":"Average of 5 last available observations"},{"location":"data-management/series/randomlyGrowing.html","text":"Series.randomlyGrowing Create randomly growing time series Syntax outputSeries = Series.randomlyGrowing(range) outputSeries = Series.randomlyGrowing(range, [mean, stdev], ...) Input Arguments range [ Dater ] Date range on which the randomly growing time series will be created. [mean=0, stdev=1] [ numeric ] The mean and std deviation of the Normal distribution from which the log-growth rate or the difference will be drawn; see Description. Output Arguments outputSeries [ Series ] Output time series. Options Comment=\"\" [ string ] Comment, or an array of comments (depending on the Dimensions option) that will be assigned to the outputSeries . Dimensions=1 [ numeric ] The size of the outputSeries in 2nd and higher dimensions. Exponentiate=true [ true | false ] Exponentiate the cumulative sum of random numbers to create the outputSeries . Initial=0 [ numeric ] Initial value for the cumulative sum of random numbers (before exponentiation when Exponentiate=true . Description The output series is created as follows: Generate a series of a total of N random numbers from \\(N(\\mu, \\sigma)\\) , where the mean \\(\\mu\\) and the std deviation \\(\\sigma\\) are determined by the input arguments mean and stdev , respectively, and N is the number of periods in the range . Replace the first random number in the series with Initial , and calculate the cumulative sum of these random numbers. When Exponentiate=true , exponentiate the cumulated series. Example x = Series . randomlyGrowing ( qq ( 2020 , 1 ): qq ( 2030 , 4 ), [ 0.01 , 0.02 ])","title":"randomlyGrowing"},{"location":"data-management/series/randomlyGrowing.html#seriesrandomlygrowing","text":"Create randomly growing time series","title":"Series.randomlyGrowing"},{"location":"data-management/series/randomlyGrowing.html#syntax","text":"outputSeries = Series.randomlyGrowing(range) outputSeries = Series.randomlyGrowing(range, [mean, stdev], ...)","title":"Syntax"},{"location":"data-management/series/randomlyGrowing.html#input-arguments","text":"range [ Dater ] Date range on which the randomly growing time series will be created. [mean=0, stdev=1] [ numeric ] The mean and std deviation of the Normal distribution from which the log-growth rate or the difference will be drawn; see Description.","title":"Input Arguments"},{"location":"data-management/series/randomlyGrowing.html#output-arguments","text":"outputSeries [ Series ] Output time series.","title":"Output Arguments"},{"location":"data-management/series/randomlyGrowing.html#options","text":"Comment=\"\" [ string ] Comment, or an array of comments (depending on the Dimensions option) that will be assigned to the outputSeries . Dimensions=1 [ numeric ] The size of the outputSeries in 2nd and higher dimensions. Exponentiate=true [ true | false ] Exponentiate the cumulative sum of random numbers to create the outputSeries . Initial=0 [ numeric ] Initial value for the cumulative sum of random numbers (before exponentiation when Exponentiate=true .","title":"Options"},{"location":"data-management/series/randomlyGrowing.html#description","text":"The output series is created as follows: Generate a series of a total of N random numbers from \\(N(\\mu, \\sigma)\\) , where the mean \\(\\mu\\) and the std deviation \\(\\sigma\\) are determined by the input arguments mean and stdev , respectively, and N is the number of periods in the range . Replace the first random number in the series with Initial , and calculate the cumulative sum of these random numbers. When Exponentiate=true , exponentiate the cumulated series.","title":"Description"},{"location":"data-management/series/randomlyGrowing.html#example","text":"x = Series . randomlyGrowing ( qq ( 2020 , 1 ): qq ( 2030 , 4 ), [ 0.01 , 0.02 ])","title":"Example"},{"location":"data-management/series/rebase.html","text":"rebase Rebase times series data to specified period Syntax outputSeries = rebase(inputSeries, basePeriod, baseValue, ...) Input Arguments inputSeries [ Series ] Input time series that will be rebased. basePeriod=\"allStart\" [ Dater | \"allStart\" | \"allEnd\" ] - Date relative to which the input data will be rebased (baseValue period); 'allStart' means the first date for which all time series columns have a NaN observation; 'allEnd' means the last such date. baseValue=1 [ 0 | 1 | 100 ] Rebasing mode and value: B=0 means additive rebasing with 0 in the basePeriod ; B=1 means multiplicative rebasing with 1 in the basePeriod ; B=100 means multiplicative rebasing with 100 in the basePeriod . Output Arguments outputSeries [ Series ] Rebased time series. Description Example","title":"rebase"},{"location":"data-management/series/rebase.html#rebase","text":"Rebase times series data to specified period","title":"rebase"},{"location":"data-management/series/rebase.html#syntax","text":"outputSeries = rebase(inputSeries, basePeriod, baseValue, ...)","title":"Syntax"},{"location":"data-management/series/rebase.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be rebased. basePeriod=\"allStart\" [ Dater | \"allStart\" | \"allEnd\" ] - Date relative to which the input data will be rebased (baseValue period); 'allStart' means the first date for which all time series columns have a NaN observation; 'allEnd' means the last such date. baseValue=1 [ 0 | 1 | 100 ] Rebasing mode and value: B=0 means additive rebasing with 0 in the basePeriod ; B=1 means multiplicative rebasing with 1 in the basePeriod ; B=100 means multiplicative rebasing with 100 in the basePeriod .","title":"Input Arguments"},{"location":"data-management/series/rebase.html#output-arguments","text":"outputSeries [ Series ] Rebased time series.","title":"Output Arguments"},{"location":"data-management/series/rebase.html#description","text":"","title":"Description"},{"location":"data-management/series/rebase.html#example","text":"","title":"Example"},{"location":"data-management/series/regress.html","text":"regress Ordinary or weighted least-square regression Syntax [res, stdEst, res, stdRes, fit, dates, covEst] = regress(lhs, rhs, ...) Input arguments lhs [ Series ] Time series of dependent (LHS) variables; can be a multivariate time series object for multiple dependent variables (sharing the same explanatory variables). rhs [ Series ] Time series of explanatory (RHS) variables; can be a multivariate time series object for multiple explanatory variables. Output arguments est [ numeric ] Vector of estimated regression parameters. stdEst [ numeric ] Vector of std errors of the parameter estimates. res [ Series ] Time series of the regression residuals. stdRes [ numeric ] Estimate of the std deviation of the regression residuals. fit [ Series ] Time series of fitted values for the LHS variable(s). Dates [ numeric ] The dates of observations actually used in the regression. covEst [ numeric ] Covariance matrix of the regression parameter estimates. Options Dates=Inf [ Dater | Inf ] Dates on which the regression will be run; Dates=Inf means the entire range available will be used. Intercept=false [ true | false ] Include an intercept in the regression; Intercept=true means the intercept will be placed last in the matrix of explanatory variables. Weights=[] [ Series | empty ] Time series of regression weights on the observations in individual periods; Weights=[] means equal unit weight on all observations. Description This function calls the built-in lscov function. Example Generate random explanatory variables x and y and noise e , construct a dependent variable a , and estimate two regressions, one excluding the intercept (not included in the \"true\" relationship), the other including the intercept. x = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); y = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); e = Series ( qq ( 2020 , 1 ), 0.1 * randn ( 1000 , 1 )); a = 0.5 * x - 0.5 * y + e ; [ est1 , stdEst2 ] = regress ( a , [ x , y ]) [ est2 , stdEst2 ] = regress ( a , [ x , y ], intercept = true )","title":"regress"},{"location":"data-management/series/regress.html#regress","text":"Ordinary or weighted least-square regression","title":"regress"},{"location":"data-management/series/regress.html#syntax","text":"[res, stdEst, res, stdRes, fit, dates, covEst] = regress(lhs, rhs, ...)","title":"Syntax"},{"location":"data-management/series/regress.html#input-arguments","text":"lhs [ Series ] Time series of dependent (LHS) variables; can be a multivariate time series object for multiple dependent variables (sharing the same explanatory variables). rhs [ Series ] Time series of explanatory (RHS) variables; can be a multivariate time series object for multiple explanatory variables.","title":"Input arguments"},{"location":"data-management/series/regress.html#output-arguments","text":"est [ numeric ] Vector of estimated regression parameters. stdEst [ numeric ] Vector of std errors of the parameter estimates. res [ Series ] Time series of the regression residuals. stdRes [ numeric ] Estimate of the std deviation of the regression residuals. fit [ Series ] Time series of fitted values for the LHS variable(s). Dates [ numeric ] The dates of observations actually used in the regression. covEst [ numeric ] Covariance matrix of the regression parameter estimates.","title":"Output arguments"},{"location":"data-management/series/regress.html#options","text":"Dates=Inf [ Dater | Inf ] Dates on which the regression will be run; Dates=Inf means the entire range available will be used. Intercept=false [ true | false ] Include an intercept in the regression; Intercept=true means the intercept will be placed last in the matrix of explanatory variables. Weights=[] [ Series | empty ] Time series of regression weights on the observations in individual periods; Weights=[] means equal unit weight on all observations.","title":"Options"},{"location":"data-management/series/regress.html#description","text":"This function calls the built-in lscov function.","title":"Description"},{"location":"data-management/series/regress.html#example","text":"Generate random explanatory variables x and y and noise e , construct a dependent variable a , and estimate two regressions, one excluding the intercept (not included in the \"true\" relationship), the other including the intercept. x = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); y = Series ( qq ( 2020 , 1 ), rand ( 1000 , 1 )); e = Series ( qq ( 2020 , 1 ), 0.1 * randn ( 1000 , 1 )); a = 0.5 * x - 0.5 * y + e ; [ est1 , stdEst2 ] = regress ( a , [ x , y ]) [ est2 , stdEst2 ] = regress ( a , [ x , y ], intercept = true )","title":"Example"},{"location":"data-management/series/seasonDummy.html","text":"Series.seasonDummy Create time series with seasonal dummies Syntax outputSeries = Series.seasonDummy(range, dummyPeriods, ...) Input Arguments range [ Dater ] Date range on which the time series will be created. dummyPeriods [ numeric ] Numeric periods in which the new outputSeries will be assigned the value 1 in each year of the range ; otherwise, the values will 0 ; the dummyPeriods are frequency specific and depend on the date frequency of the range , e.g. the dummyPeriods represent quarters for a quarterly range , months for a monthly range , etc. Any further input arguments (third, fourth, etc.) will be pased into the Series constructor as the third, fourth, etc. input arguments (i.e. the comments , userData , etc.) Output Arguments outputSeries [ Series ] New time series with the value 1 in the dummyPeriods in each year within the range , and with 0 otherwise. Description Examples x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), 1 ) x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), [ 1 , 7 ])","title":"seasonDummy"},{"location":"data-management/series/seasonDummy.html#seriesseasondummy","text":"Create time series with seasonal dummies","title":"Series.seasonDummy"},{"location":"data-management/series/seasonDummy.html#syntax","text":"outputSeries = Series.seasonDummy(range, dummyPeriods, ...)","title":"Syntax"},{"location":"data-management/series/seasonDummy.html#input-arguments","text":"range [ Dater ] Date range on which the time series will be created. dummyPeriods [ numeric ] Numeric periods in which the new outputSeries will be assigned the value 1 in each year of the range ; otherwise, the values will 0 ; the dummyPeriods are frequency specific and depend on the date frequency of the range , e.g. the dummyPeriods represent quarters for a quarterly range , months for a monthly range , etc. Any further input arguments (third, fourth, etc.) will be pased into the Series constructor as the third, fourth, etc. input arguments (i.e. the comments , userData , etc.)","title":"Input Arguments"},{"location":"data-management/series/seasonDummy.html#output-arguments","text":"outputSeries [ Series ] New time series with the value 1 in the dummyPeriods in each year within the range , and with 0 otherwise.","title":"Output Arguments"},{"location":"data-management/series/seasonDummy.html#description","text":"","title":"Description"},{"location":"data-management/series/seasonDummy.html#examples","text":"x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), 1 ) x = Series . seasonDummy ( mm ( 2020 , 01 ): mm ( 2029 , 12 ), [ 1 , 7 ])","title":"Examples"},{"location":"data-management/x13/index.html","text":"Interface to X13-Arima","title":"Introduction"},{"location":"data-management/x13/index.html#interface-to-x13-arima","text":"","title":"Interface to X13-Arima"},{"location":"data-management/x13/season.html","text":"x13.season Interface to X13-Arima seasonal adjustment procedure Syntax [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, ...) [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, range, ...) Input Arguments inputSeries [ Series ] Input time series that will be subjected to a X13-ARIMA seasonal adjustment procedure. range=Inf [ Dater ] Date range on which the seasonal adjustment will be performed; any observations outside the range will be clipped off before running the procedure; if not specified, all observations available will be used. Output Arguments outputSeries [ Series ] One or more output time series that correspond to the type of output requested in the option Output . info [ struct ] Information struct with details on the X13-ARIMA procedure run. The info struct includes the following fields and nested fields: .InputFiles - a struct with nested fields named after the extensions of the individual input files, with the content of the these input files. .OutputFiles - a struct with with nested fields named after the extensions of the individual output files produced by the X13-ARIMA procedure, with the content of these output files. The output files always included are .log , .out , and .err . Additional output files are included based on the output series (output tables) requested in the option Output . .Message - the screen output of the X13-ARIMA procedure; this output is also printed on the screen when the option Display=true . .OutputSpecs - selected specs based on the information captured from some output files; the output specs may include OutputSpecs.X11_Mode , OutputSpecs.Arima_Model , OutputSpecs.Arima_AR , OutputSPecs.Arima_MA . .Path - the entire path to the input and output files, including the file name wkithout and extension (the same file name with different extensions is used for both input and output files); when Cleanup=true , the input and output files are all deleted automatically. General Options Output=\"d10\" [ string ] Types of output requested to be returned as time series from the X13-ARIMA procedure; see the Output Tables in Description; the number of the outputSeries arguments corresponds to the number of elements in this option. Range=Inf [ Dater ] Date range that will be extracted from the inputSeries before running the X13-ARIMA procedure; the observations outside the range will be discarded. Display=false [ true | false ] Print the screen output produced by the X13-ARIMA procedure; the message is also captured in the output argument info.Message . Cleanup=true [ true | false ] Delete all input and output files automatically. X13-ARIMA Options Below are listed the X13-ARIMA specs that are supported in the current implemenation; refer to the X13-ARIMA-SEATS manual for details and explanation. To assign values to the individual specs and their settings, follow these rules: if a numeric scalar or vector is expected, assign the option a numeric scalar or vector; if a \"yes\" or \"no\" value is expected, assign a true or false ; if a text value or a list of more than onetext values is expected (such as log in Transform_Function , or td lpyear in Regression_Variables ), enter a single double-quoted string, or an array of strings (such as \"log\" or [\"td\", \"lpyear\"] ); if time series data are expected (such as in Regression_Data ), enter a time series object; if a fixed numeric value is expected (such as fixed coefficients in Arima_AR , as opposed to initial values in the same spec), enter an imaginary value (such as 0.8i ); imaginary values will be printed with an extra F in the input files (such as 0.8F ); Series Spec Series_Title Series_Span Series_ModelSpan Series_Precision Series_Decimals Series_CompType Series_CompWeight Series_AppendBcst Series_AppendFcst Series_Type Series_Save X11 Spec X11_SeasonalMA X11_TrendMA X11_SigmaLim X11_Title X11_AppendFcst X11_AppendBcst X11_Final X11_Print X11_Save X11_SaveLog Transform Spec Transform_Function Transform_Power Transform_Adjust Transform_Title Transform_AicDiff Transform_Print Transform_Save Transform_SaveLog Estimate Spec Estimate_Tol Estimate_MaxIter Estimate_Exact Estimate_OutOfSample Estimate_Print Estimate_Save Estimate_SaveLog Automdl Spec Automdl_MaxOrder Automdl_MaxDiff Automdl_Diff Automdl_AcceptDefault Automdl_CheckMu Automdl_LjungBoxLimit Automdl_Mixed Automdl_Print Automdl_SaveLog Arima Spec Arima_Model Arima_AR Arima_MA Arima_Title Force Spec Force_Type Force_Lambda Force_Rho Force_Round Force_Start Force_Target Force_UseFcst Force_Print Force_Save Forecast Spec Forecast_MaxLead Forecast_MaxBack Forecast_Exclude Forecast_LogNormal Forecast_Print Forecast_Save Regression Spec Regression_Variables Regression_TestAllEaster Regression_Data Regression_User Regression_UserType Regression_AicTest Regression_AicDiff Regression_PVAicTest Regression_TLimit Regression_Chi2Test Regression_Chi2TestCV Regression_Print Regression_Save Regression_SaveLog X11Regression Spec X11Regression_Variables X11Regression_Data X11Regression_User X11Regression_UserType X11Regression_AicTest X11Regression_AicDiff X11Regression_TDPrior X11Regression_Prior X11Regression_Span X11Regression_Sigma X11Regression_Critical X11Regression_OutlierMethod X11Regression_OutlierSpan X11Regression_Print X11Regression_Save X11Regression_SaveLog Seats Spec Seats_AppendFcst Seats_HpCycle Seats_NoAdmiss Seats_QMax Seats_RMod Seats_Out Seats_StatSeas Seats_TabTables Seats_PrintPhtrf Seats_Print Seats_Save Seats_SaveLog Description Bulding the Input File With no options specified, all specs (see their list above) are empty, meaning they are not included in the input file at all and the X13-ARIMA default values (see the X13-ARIMA-SEATS manual) are assumed, with the following exceptions: Series_Start , Series_Data and Series_Period are automatically created based on the inputSeries ; Series_Precision and Series_Decimals are both set to 5 (the maximum precision accepted by the X13-ARIMA procedure); Either an X11 spec or a pair of Seat and Automdl specs are included to force the execution of the X11 type of seasonal adjustment (if d.. types of output tables are requested in Output ) or the execution of the SEAT type of seasonal adjustment (if x.. types of output tables are requested in Output ). If no setting within a particular spec is not defined in the options, the spec itself is not included in the input file. To force the inclusion of an empty spec in the input file (assuming thus the default values for all the settings within that spece), use the name of the spec as an option and set it to true , e.g. (..., \"Automdl\", true, ...) to force the estimation of an ARIMA model based on an automatic model selection procedure. If at least one setting from a particular spec is specified as an option in the fuction call, that spec is included explicitly in the input file. Type of Seasonal Adjustment Two types of seasonal adjustments are available in X13-ARIMA: X11 and SEATS . Which one is invoked depends on the type of output requested in the option Output : the output tables starting with a d refer to X11 (hence, the default Output=\"d11\" invokes X11 and returns the final seasonally adjusted series) whereas the output tables starting with an s refer to SEATS . Depending on the output tables requested, the correct spec for the respective seasonal adjustment procedure will be included in the input file and invoked. The two procedures cannot be combined together in one run; i.e. the option Output cannot combine d.. and s.. output tables. Output Tables (Output Series) The following output tables (i.e. output series) can be requested in the option Output : Name in option Output Output table in X13 Description \"d10\" X11_d10 X11 final seasonal factors \"d11\" X11_d11 X11 final seasonally adjusted series \"d12\" X11_d12 X11 final trend-cycle \"d13\" X11_d13 X11 final irregular component \"d16\" X11_d16 X11 final combined seasonal and trading day factors \"d18\" X11_d18 X11 combined holiday and trading day factors \"s10\" Seats_s10 SEATS final seasonal component \"s11\" Seats_s11 SEATS final seasonal adjustment component \"s12\" Seats_s12 SEATS final trend component \"s13\" Seats_s13 SEATS final irregular component \"s14\" Seats_s14 SEATS final transitory component \"s16\" Seats_s16 SEATS final combined adjustment component \"s18\" Seats_s18 SEATS final adjustment ratio \"cyc\" Seats_cyc SEATS cycle component \"a18\" Series_a18 Original series adjusted for regARIMA calendar effects \"a19\" Series_a19 Original series adjusted for regARIMA outliers \"b1\" Series_b1 Original series, adjusted for prior effects and forecast extended \"mva\" Series_mva Original series with missing values replaced by regARIMA estimates \"saa\" Force_saa Final seasonally adjusted series with constrained yearly totals \"rnd\" Force_rnd Rounded final seasonally adjusted series \"fct\" Forecast_fct Point forecasts on the original scale \"bct\" Forecast_bct Point backcasts on the original scale \"ftr\" Forecast_ftr Point forecasts on the transformed scale \"btr\" Forecast_btr Point backcasts on the transformed scale Example A plain vanilla call xsa = x13 . season ( x ) or [ xsa , info ] = x13 . season ( x ) produces a seasonally adjusted series xsa with all default settings (hence no ARIMA model estimated). Example Estimate an ARIMA model based on an automatic model selection procedures, use the ARIMA information in the seasonal adjustment, and return the estimated ARIMA model in the output info struct: [xsa, info] = x13.season(x, \"Automdl\", true, \"Estimate_Save\", \"mdl\") Example Request additional output series: the seasonally adjusted series, the seasonal factors and the trend cycle component: [ xsa , xsf , xtc , info ] = x13 . season ( x , \"Output\" , [ \"d11\" , \"d10\" , \"d12\" ]); Example Run seasonal adjustment based on an automatically selected ARIMA model with dummy variables of additive outliers in period 2017Q3, 2017Q4 and 2018Q1: xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Variables\" , \"aos2017.3-2018.1\" ... ); This call is equivalent to creating the dummies manually (a time series object with three columns), and using the option Regression_Data instead: dummy = Series ( startDate : endDate , zeros ( 1 , 3 )); dummy ( qq ( 2017 , 3 ), 1 ) = 1 ; dummy ( qq ( 2017 , 4 ), 2 ) = 1 ; dummy ( qq ( 2018 , 1 ), 3 ) = 1 ; xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Data\" , dummy ... );","title":"season"},{"location":"data-management/x13/season.html#x13season","text":"Interface to X13-Arima seasonal adjustment procedure","title":"x13.season"},{"location":"data-management/x13/season.html#syntax","text":"[outputSeries, outputSeries, ..., info] = x13.season(inputSeries, ...) [outputSeries, outputSeries, ..., info] = x13.season(inputSeries, range, ...)","title":"Syntax"},{"location":"data-management/x13/season.html#input-arguments","text":"inputSeries [ Series ] Input time series that will be subjected to a X13-ARIMA seasonal adjustment procedure. range=Inf [ Dater ] Date range on which the seasonal adjustment will be performed; any observations outside the range will be clipped off before running the procedure; if not specified, all observations available will be used.","title":"Input Arguments"},{"location":"data-management/x13/season.html#output-arguments","text":"outputSeries [ Series ] One or more output time series that correspond to the type of output requested in the option Output . info [ struct ] Information struct with details on the X13-ARIMA procedure run. The info struct includes the following fields and nested fields: .InputFiles - a struct with nested fields named after the extensions of the individual input files, with the content of the these input files. .OutputFiles - a struct with with nested fields named after the extensions of the individual output files produced by the X13-ARIMA procedure, with the content of these output files. The output files always included are .log , .out , and .err . Additional output files are included based on the output series (output tables) requested in the option Output . .Message - the screen output of the X13-ARIMA procedure; this output is also printed on the screen when the option Display=true . .OutputSpecs - selected specs based on the information captured from some output files; the output specs may include OutputSpecs.X11_Mode , OutputSpecs.Arima_Model , OutputSpecs.Arima_AR , OutputSPecs.Arima_MA . .Path - the entire path to the input and output files, including the file name wkithout and extension (the same file name with different extensions is used for both input and output files); when Cleanup=true , the input and output files are all deleted automatically.","title":"Output Arguments"},{"location":"data-management/x13/season.html#general-options","text":"Output=\"d10\" [ string ] Types of output requested to be returned as time series from the X13-ARIMA procedure; see the Output Tables in Description; the number of the outputSeries arguments corresponds to the number of elements in this option. Range=Inf [ Dater ] Date range that will be extracted from the inputSeries before running the X13-ARIMA procedure; the observations outside the range will be discarded. Display=false [ true | false ] Print the screen output produced by the X13-ARIMA procedure; the message is also captured in the output argument info.Message . Cleanup=true [ true | false ] Delete all input and output files automatically.","title":"General Options"},{"location":"data-management/x13/season.html#x13-arima-options","text":"Below are listed the X13-ARIMA specs that are supported in the current implemenation; refer to the X13-ARIMA-SEATS manual for details and explanation. To assign values to the individual specs and their settings, follow these rules: if a numeric scalar or vector is expected, assign the option a numeric scalar or vector; if a \"yes\" or \"no\" value is expected, assign a true or false ; if a text value or a list of more than onetext values is expected (such as log in Transform_Function , or td lpyear in Regression_Variables ), enter a single double-quoted string, or an array of strings (such as \"log\" or [\"td\", \"lpyear\"] ); if time series data are expected (such as in Regression_Data ), enter a time series object; if a fixed numeric value is expected (such as fixed coefficients in Arima_AR , as opposed to initial values in the same spec), enter an imaginary value (such as 0.8i ); imaginary values will be printed with an extra F in the input files (such as 0.8F );","title":"X13-ARIMA Options"},{"location":"data-management/x13/season.html#series-spec","text":"Series_Title Series_Span Series_ModelSpan Series_Precision Series_Decimals Series_CompType Series_CompWeight Series_AppendBcst Series_AppendFcst Series_Type Series_Save","title":"Series Spec"},{"location":"data-management/x13/season.html#x11-spec","text":"X11_SeasonalMA X11_TrendMA X11_SigmaLim X11_Title X11_AppendFcst X11_AppendBcst X11_Final X11_Print X11_Save X11_SaveLog","title":"X11 Spec"},{"location":"data-management/x13/season.html#transform-spec","text":"Transform_Function Transform_Power Transform_Adjust Transform_Title Transform_AicDiff Transform_Print Transform_Save Transform_SaveLog","title":"Transform Spec"},{"location":"data-management/x13/season.html#estimate-spec","text":"Estimate_Tol Estimate_MaxIter Estimate_Exact Estimate_OutOfSample Estimate_Print Estimate_Save Estimate_SaveLog","title":"Estimate Spec"},{"location":"data-management/x13/season.html#automdl-spec","text":"Automdl_MaxOrder Automdl_MaxDiff Automdl_Diff Automdl_AcceptDefault Automdl_CheckMu Automdl_LjungBoxLimit Automdl_Mixed Automdl_Print Automdl_SaveLog","title":"Automdl Spec"},{"location":"data-management/x13/season.html#arima-spec","text":"Arima_Model Arima_AR Arima_MA Arima_Title","title":"Arima Spec"},{"location":"data-management/x13/season.html#force-spec","text":"Force_Type Force_Lambda Force_Rho Force_Round Force_Start Force_Target Force_UseFcst Force_Print Force_Save","title":"Force Spec"},{"location":"data-management/x13/season.html#forecast-spec","text":"Forecast_MaxLead Forecast_MaxBack Forecast_Exclude Forecast_LogNormal Forecast_Print Forecast_Save","title":"Forecast Spec"},{"location":"data-management/x13/season.html#regression-spec","text":"Regression_Variables Regression_TestAllEaster Regression_Data Regression_User Regression_UserType Regression_AicTest Regression_AicDiff Regression_PVAicTest Regression_TLimit Regression_Chi2Test Regression_Chi2TestCV Regression_Print Regression_Save Regression_SaveLog","title":"Regression Spec"},{"location":"data-management/x13/season.html#x11regression-spec","text":"X11Regression_Variables X11Regression_Data X11Regression_User X11Regression_UserType X11Regression_AicTest X11Regression_AicDiff X11Regression_TDPrior X11Regression_Prior X11Regression_Span X11Regression_Sigma X11Regression_Critical X11Regression_OutlierMethod X11Regression_OutlierSpan X11Regression_Print X11Regression_Save X11Regression_SaveLog","title":"X11Regression Spec"},{"location":"data-management/x13/season.html#seats-spec","text":"Seats_AppendFcst Seats_HpCycle Seats_NoAdmiss Seats_QMax Seats_RMod Seats_Out Seats_StatSeas Seats_TabTables Seats_PrintPhtrf Seats_Print Seats_Save Seats_SaveLog","title":"Seats Spec"},{"location":"data-management/x13/season.html#description","text":"","title":"Description"},{"location":"data-management/x13/season.html#bulding-the-input-file","text":"With no options specified, all specs (see their list above) are empty, meaning they are not included in the input file at all and the X13-ARIMA default values (see the X13-ARIMA-SEATS manual) are assumed, with the following exceptions: Series_Start , Series_Data and Series_Period are automatically created based on the inputSeries ; Series_Precision and Series_Decimals are both set to 5 (the maximum precision accepted by the X13-ARIMA procedure); Either an X11 spec or a pair of Seat and Automdl specs are included to force the execution of the X11 type of seasonal adjustment (if d.. types of output tables are requested in Output ) or the execution of the SEAT type of seasonal adjustment (if x.. types of output tables are requested in Output ). If no setting within a particular spec is not defined in the options, the spec itself is not included in the input file. To force the inclusion of an empty spec in the input file (assuming thus the default values for all the settings within that spece), use the name of the spec as an option and set it to true , e.g. (..., \"Automdl\", true, ...) to force the estimation of an ARIMA model based on an automatic model selection procedure. If at least one setting from a particular spec is specified as an option in the fuction call, that spec is included explicitly in the input file.","title":"Bulding the Input File"},{"location":"data-management/x13/season.html#type-of-seasonal-adjustment","text":"Two types of seasonal adjustments are available in X13-ARIMA: X11 and SEATS . Which one is invoked depends on the type of output requested in the option Output : the output tables starting with a d refer to X11 (hence, the default Output=\"d11\" invokes X11 and returns the final seasonally adjusted series) whereas the output tables starting with an s refer to SEATS . Depending on the output tables requested, the correct spec for the respective seasonal adjustment procedure will be included in the input file and invoked. The two procedures cannot be combined together in one run; i.e. the option Output cannot combine d.. and s.. output tables.","title":"Type of Seasonal Adjustment"},{"location":"data-management/x13/season.html#output-tables-output-series","text":"The following output tables (i.e. output series) can be requested in the option Output : Name in option Output Output table in X13 Description \"d10\" X11_d10 X11 final seasonal factors \"d11\" X11_d11 X11 final seasonally adjusted series \"d12\" X11_d12 X11 final trend-cycle \"d13\" X11_d13 X11 final irregular component \"d16\" X11_d16 X11 final combined seasonal and trading day factors \"d18\" X11_d18 X11 combined holiday and trading day factors \"s10\" Seats_s10 SEATS final seasonal component \"s11\" Seats_s11 SEATS final seasonal adjustment component \"s12\" Seats_s12 SEATS final trend component \"s13\" Seats_s13 SEATS final irregular component \"s14\" Seats_s14 SEATS final transitory component \"s16\" Seats_s16 SEATS final combined adjustment component \"s18\" Seats_s18 SEATS final adjustment ratio \"cyc\" Seats_cyc SEATS cycle component \"a18\" Series_a18 Original series adjusted for regARIMA calendar effects \"a19\" Series_a19 Original series adjusted for regARIMA outliers \"b1\" Series_b1 Original series, adjusted for prior effects and forecast extended \"mva\" Series_mva Original series with missing values replaced by regARIMA estimates \"saa\" Force_saa Final seasonally adjusted series with constrained yearly totals \"rnd\" Force_rnd Rounded final seasonally adjusted series \"fct\" Forecast_fct Point forecasts on the original scale \"bct\" Forecast_bct Point backcasts on the original scale \"ftr\" Forecast_ftr Point forecasts on the transformed scale \"btr\" Forecast_btr Point backcasts on the transformed scale","title":"Output Tables (Output Series)"},{"location":"data-management/x13/season.html#example","text":"A plain vanilla call xsa = x13 . season ( x ) or [ xsa , info ] = x13 . season ( x ) produces a seasonally adjusted series xsa with all default settings (hence no ARIMA model estimated).","title":"Example"},{"location":"data-management/x13/season.html#example_1","text":"Estimate an ARIMA model based on an automatic model selection procedures, use the ARIMA information in the seasonal adjustment, and return the estimated ARIMA model in the output info struct: [xsa, info] = x13.season(x, \"Automdl\", true, \"Estimate_Save\", \"mdl\")","title":"Example"},{"location":"data-management/x13/season.html#example_2","text":"Request additional output series: the seasonally adjusted series, the seasonal factors and the trend cycle component: [ xsa , xsf , xtc , info ] = x13 . season ( x , \"Output\" , [ \"d11\" , \"d10\" , \"d12\" ]);","title":"Example"},{"location":"data-management/x13/season.html#example_3","text":"Run seasonal adjustment based on an automatically selected ARIMA model with dummy variables of additive outliers in period 2017Q3, 2017Q4 and 2018Q1: xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Variables\" , \"aos2017.3-2018.1\" ... ); This call is equivalent to creating the dummies manually (a time series object with three columns), and using the option Regression_Data instead: dummy = Series ( startDate : endDate , zeros ( 1 , 3 )); dummy ( qq ( 2017 , 3 ), 1 ) = 1 ; dummy ( qq ( 2017 , 4 ), 2 ) = 1 ; dummy ( qq ( 2018 , 1 ), 3 ) = 1 ; xsa = x13 . season ( x ... , \"Automdl\" , true ... , \"Regression_Data\" , dummy ... );","title":"Example"},{"location":"numerical-utilities/solver/index.html","text":"Nonlinear equations solver General settings display=\"iter\" [ \"iter\" | \"final\" | \"none\" | numeric ] Level of display in numeric iterations: display=\"iter\" - print every iteration and the final convergence message; display=\"final\" - print the final convergence message only; display=\"none\" - do not print any message; display=numeric - same as \"display=\"iter\" but print every display iterations only. Objective function settings functionNorm=2 [ numeric | Inf | function ] A vector norm applied to the array of discrepancies between the LHS and RHS of individual equations; see help on the builtin norm function for numeric specification of the norm; or specify your own function norm as an anonymous function. In most situations, one of the following norms are the appropriate choice: functionNorm=2 - a quadratic norm, i.e. sum of squared discrepancies; functionNorm=Inf - an infinity norm, i.e. sum of absolute discrepancies. __ trimObjectiveFunction=false [ true | false ] After evaluating the objective function, replace the value smaller than functionTolerance with zeros. Convergence settings maxIterations=5000 [ numeric ] Maximum number of iterations. maxFunctionEvaluations=@(x) 200*x.NumUknowns [ numeric | functions ] Maximum number of function evaluations. functionTolerance=1e-12 [ numeric ] Convergence tolerance for the functionNorm . stepTolerance=1e-12 [ numeric ] Convergence tolerance for the maximum absolute change in the value of the unknowns; set stepTolerance=Inf to turn step tolerance off. Jacobian settings jacobCalculation=\"analytical\" [ \"analytical\" | \"forwardDiff\" ] Calculate the Jacobian analytically or numerically. lastJacobUpdate=Inf [ numeric | Inf ] Last iteration in which the Jacobian will be updated: lastJacobUpdate=Inf means the Jacobian will be always updated; lastJacobUpdate=0 means the Jacobian will be calculated once at the beginning and never updated afterwards; lastJacobUpdate=-1 means the Jacobian will not be calculated, and an identity matrix will be used in its place; lastJacobUpdate=n means the Jacobian will be update until the n -the iteration (inclusive). skipJacobUpdate=0 [ numeric ] The Jacobian will be reused (without recalculation) in the next skipJacobUpdate iteration; then it will get updated again.","title":"Nonlinear solver"},{"location":"numerical-utilities/solver/index.html#nonlinear-equations-solver","text":"","title":"Nonlinear equations solver"},{"location":"numerical-utilities/solver/index.html#general-settings","text":"display=\"iter\" [ \"iter\" | \"final\" | \"none\" | numeric ] Level of display in numeric iterations: display=\"iter\" - print every iteration and the final convergence message; display=\"final\" - print the final convergence message only; display=\"none\" - do not print any message; display=numeric - same as \"display=\"iter\" but print every display iterations only.","title":"General settings"},{"location":"numerical-utilities/solver/index.html#objective-function-settings","text":"functionNorm=2 [ numeric | Inf | function ] A vector norm applied to the array of discrepancies between the LHS and RHS of individual equations; see help on the builtin norm function for numeric specification of the norm; or specify your own function norm as an anonymous function. In most situations, one of the following norms are the appropriate choice: functionNorm=2 - a quadratic norm, i.e. sum of squared discrepancies; functionNorm=Inf - an infinity norm, i.e. sum of absolute discrepancies. __ trimObjectiveFunction=false [ true | false ] After evaluating the objective function, replace the value smaller than functionTolerance with zeros.","title":"Objective function settings"},{"location":"numerical-utilities/solver/index.html#convergence-settings","text":"maxIterations=5000 [ numeric ] Maximum number of iterations. maxFunctionEvaluations=@(x) 200*x.NumUknowns [ numeric | functions ] Maximum number of function evaluations. functionTolerance=1e-12 [ numeric ] Convergence tolerance for the functionNorm . stepTolerance=1e-12 [ numeric ] Convergence tolerance for the maximum absolute change in the value of the unknowns; set stepTolerance=Inf to turn step tolerance off.","title":"Convergence settings"},{"location":"numerical-utilities/solver/index.html#jacobian-settings","text":"jacobCalculation=\"analytical\" [ \"analytical\" | \"forwardDiff\" ] Calculate the Jacobian analytically or numerically. lastJacobUpdate=Inf [ numeric | Inf ] Last iteration in which the Jacobian will be updated: lastJacobUpdate=Inf means the Jacobian will be always updated; lastJacobUpdate=0 means the Jacobian will be calculated once at the beginning and never updated afterwards; lastJacobUpdate=-1 means the Jacobian will not be calculated, and an identity matrix will be used in its place; lastJacobUpdate=n means the Jacobian will be update until the n -the iteration (inclusive). skipJacobUpdate=0 [ numeric ] The Jacobian will be reused (without recalculation) in the next skipJacobUpdate iteration; then it will get updated again.","title":"Jacobian settings"},{"location":"reporting/index.html","text":"Reporting","title":"Introduction"},{"location":"reporting/index.html#reporting","text":"","title":"Reporting"},{"location":"reporting/chartpack/index.html","text":"Databank Chartpacks Categorical list of functions Creating new chartpacks Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields Defining the content Function Description add Add new chart to a databank.Chartpack object clear Clear all charts from the chartpack Drawing the charts Function Description draw Render charts defined in Chartpack","title":"Introduction"},{"location":"reporting/chartpack/index.html#databank-chartpacks","text":"","title":"Databank Chartpacks"},{"location":"reporting/chartpack/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"reporting/chartpack/index.html#creating-new-chartpacks","text":"Function Description databank.Chartpack Create a new Chartpack object for plotting databank fields","title":"Creating new chartpacks"},{"location":"reporting/chartpack/index.html#defining-the-content","text":"Function Description add Add new chart to a databank.Chartpack object clear Clear all charts from the chartpack","title":"Defining the content"},{"location":"reporting/chartpack/index.html#drawing-the-charts","text":"Function Description draw Render charts defined in Chartpack","title":"Drawing the charts"},{"location":"reporting/chartpack/Chartpack.html","text":"databank.Chartpack Create a new Chartpack object for plotting databank fields Syntax ch = databank.Chartpack() Output Arguments ch [ databank.Chartpack ] New empty databank.Chartpack object Customizable properties After creating a new Chartpack object, set the following properties to customize the way the charts are produced and styled: Customize visual aspects of individual charts PlotFunc=@plot [ @plot ] Plot function used to create each of the charts. Highlight=[] [ Dater | cell | empty ] Date range, or a cell array of date ranges, that will be highlighted in each chart. Customize data plotted Range=Inf [ Dater | Inf ] Date range or horizontal axis range on which the charts will be created. Range=Inf means each chart will encompass the range necessary to accommodate the entire time series plotted. Round=Inf [ numeric ] Round the data to this number of decimal places before plotting them. Transform=[] [ function | empty ] Function that will be applied to each data input before it gets plotted, except input data entered with a \"^\" at the beginning of their expression string. Customize chart captions CaptionFromComment=false [ true | false ] If chart caption is missing, use the time series comments to create the captions. Newline=\"//\" [ string ] Separator between lines in the captions of the charts. ShowFormulas=false [ true | false ] Add formulas from the input strings to the chart captions; the formula is always used for the chart caption whenever the caption is not supplied in the input string and the time series does not have a non-empty comment (or CaptionFromComment=false ). ShowTransform=false [ true | false ] Add the Transform function to the chart captions. Customize figure window Tiles=@auto [ numeric | @auto ] Number of rows and columns of tiles within one figure window. Tiles=@auto means the layout will be determined automatically based on the total number of charts, respecting also the option MaxTilesPerWindow . MaxTilesPerWindow=40 [ numeric ] Maximum number of tiles (charts) in each figure window. Customize graphics objects FigureSettings={} [ cell ] Cell array of settings passed to the standard Matlab figure constructor. AxesSettings={} [ cell ] Cell array of settings passed to the standard Matlab axes constructor. PlotSettings={} [ cell ] Cell array of settings passed to the plot functions as extra input arguments at the end. TitleSettings={} [ cell ] Cell array of settings passed to the title constructor as extra input arguments at the end.","title":"Chartpack"},{"location":"reporting/chartpack/Chartpack.html#databankchartpack","text":"Create a new Chartpack object for plotting databank fields","title":"databank.Chartpack"},{"location":"reporting/chartpack/Chartpack.html#syntax","text":"ch = databank.Chartpack()","title":"Syntax"},{"location":"reporting/chartpack/Chartpack.html#output-arguments","text":"ch [ databank.Chartpack ] New empty databank.Chartpack object","title":"Output Arguments"},{"location":"reporting/chartpack/Chartpack.html#customizable-properties","text":"After creating a new Chartpack object, set the following properties to customize the way the charts are produced and styled:","title":"Customizable properties"},{"location":"reporting/chartpack/Chartpack.html#customize-visual-aspects-of-individual-charts","text":"PlotFunc=@plot [ @plot ] Plot function used to create each of the charts. Highlight=[] [ Dater | cell | empty ] Date range, or a cell array of date ranges, that will be highlighted in each chart.","title":"Customize visual aspects of individual charts"},{"location":"reporting/chartpack/Chartpack.html#customize-data-plotted","text":"Range=Inf [ Dater | Inf ] Date range or horizontal axis range on which the charts will be created. Range=Inf means each chart will encompass the range necessary to accommodate the entire time series plotted. Round=Inf [ numeric ] Round the data to this number of decimal places before plotting them. Transform=[] [ function | empty ] Function that will be applied to each data input before it gets plotted, except input data entered with a \"^\" at the beginning of their expression string.","title":"Customize data plotted"},{"location":"reporting/chartpack/Chartpack.html#customize-chart-captions","text":"CaptionFromComment=false [ true | false ] If chart caption is missing, use the time series comments to create the captions. Newline=\"//\" [ string ] Separator between lines in the captions of the charts. ShowFormulas=false [ true | false ] Add formulas from the input strings to the chart captions; the formula is always used for the chart caption whenever the caption is not supplied in the input string and the time series does not have a non-empty comment (or CaptionFromComment=false ). ShowTransform=false [ true | false ] Add the Transform function to the chart captions.","title":"Customize chart captions"},{"location":"reporting/chartpack/Chartpack.html#customize-figure-window","text":"Tiles=@auto [ numeric | @auto ] Number of rows and columns of tiles within one figure window. Tiles=@auto means the layout will be determined automatically based on the total number of charts, respecting also the option MaxTilesPerWindow . MaxTilesPerWindow=40 [ numeric ] Maximum number of tiles (charts) in each figure window.","title":"Customize figure window"},{"location":"reporting/chartpack/Chartpack.html#customize-graphics-objects","text":"FigureSettings={} [ cell ] Cell array of settings passed to the standard Matlab figure constructor. AxesSettings={} [ cell ] Cell array of settings passed to the standard Matlab axes constructor. PlotSettings={} [ cell ] Cell array of settings passed to the plot functions as extra input arguments at the end. TitleSettings={} [ cell ] Cell array of settings passed to the title constructor as extra input arguments at the end.","title":"Customize graphics objects"},{"location":"reporting/chartpack/add.html","text":"add Add new chart to a databank.Chartpack object Syntax add(ch, inputString, ...) ch < inputString ch < [inputString, inputString, inputString] Input arguments inputString [ string ] String, or an array of strings, specifying the expression to be plotted in a new chart, optionally with a caption preceding the expression and separated by a colon. Output arguments No output arguments are needed because the databank.Chartpack object ch is a handle object, and updating handle objects does not require capturing them as output arguments. Options ApplyTransform=true [ true | false ] Apply the function specified in the option Transform to the data in this chart; ApplyTransform=false can be also achieved by using a hat sign ^ at the beginning of the expression in the inputString . Expansion=@parent [ cell | empty | @parent ] Replace a substring in the expression with a mutliple strings, creating multiple expression to be plotted in the same chart; overrides the property Expansion defined at the level of the databank.Chartpack object. Transform=@parent [ function | empty | @parent ] Function that will be applied to this data input before it gets plotted; overrides the property Transform defined at the level of the databank.Chartpack object.","title":"add"},{"location":"reporting/chartpack/add.html#add","text":"Add new chart to a databank.Chartpack object","title":"add"},{"location":"reporting/chartpack/add.html#syntax","text":"add(ch, inputString, ...) ch < inputString ch < [inputString, inputString, inputString]","title":"Syntax"},{"location":"reporting/chartpack/add.html#input-arguments","text":"inputString [ string ] String, or an array of strings, specifying the expression to be plotted in a new chart, optionally with a caption preceding the expression and separated by a colon.","title":"Input arguments"},{"location":"reporting/chartpack/add.html#output-arguments","text":"No output arguments are needed because the databank.Chartpack object ch is a handle object, and updating handle objects does not require capturing them as output arguments.","title":"Output arguments"},{"location":"reporting/chartpack/add.html#options","text":"ApplyTransform=true [ true | false ] Apply the function specified in the option Transform to the data in this chart; ApplyTransform=false can be also achieved by using a hat sign ^ at the beginning of the expression in the inputString . Expansion=@parent [ cell | empty | @parent ] Replace a substring in the expression with a mutliple strings, creating multiple expression to be plotted in the same chart; overrides the property Expansion defined at the level of the databank.Chartpack object. Transform=@parent [ function | empty | @parent ] Function that will be applied to this data input before it gets plotted; overrides the property Transform defined at the level of the databank.Chartpack object.","title":"Options"},{"location":"reporting/chartpack/clear.html","text":"clear Clear all charts from the chartpack Syntax clear(ch) Input arguments ch [ Chartpack ] Chartpack object from which all existing charts will be cleared; all settings assigned by the user will be preserved. Description The clear function is useful when you wish to reuse a Chartpack objects with particular settings for another set of charts. Examples","title":"clear"},{"location":"reporting/chartpack/clear.html#clear","text":"Clear all charts from the chartpack","title":"clear"},{"location":"reporting/chartpack/clear.html#syntax","text":"clear(ch)","title":"Syntax"},{"location":"reporting/chartpack/clear.html#input-arguments","text":"ch [ Chartpack ] Chartpack object from which all existing charts will be cleared; all settings assigned by the user will be preserved.","title":"Input arguments"},{"location":"reporting/chartpack/clear.html#description","text":"The clear function is useful when you wish to reuse a Chartpack objects with particular settings for another set of charts.","title":"Description"},{"location":"reporting/chartpack/clear.html#examples","text":"","title":"Examples"},{"location":"reporting/chartpack/draw.html","text":"draw Render charts defined in Chartpack Syntax info = draw(ch, inputDb) Input arguments ch [ Chartpack ] Chartpack object whose charts will be rendered on the screen. inputDb [ struct | Dictionary ] Input databank within which the expressions defining the charts will be evaluated, and the results plotted. Output arguments info [ struct ] Output information structure with the following fields: .FigureHandles - handles to all figure objects created; .AxesHandles - cell array of handles to all axes objects created, grouped by figures; .PlotHandles - cell array of cell arrays of handles to all objects plotted within axes, grouped by figures and by axes; .TitleHandles - cell array of handles to all title objects created, grouped by figures; .SubtitleHandles - cell array of handles to all subtitle objects created, grouped by figures; Description Examples","title":"draw"},{"location":"reporting/chartpack/draw.html#draw","text":"Render charts defined in Chartpack","title":"draw"},{"location":"reporting/chartpack/draw.html#syntax","text":"info = draw(ch, inputDb)","title":"Syntax"},{"location":"reporting/chartpack/draw.html#input-arguments","text":"ch [ Chartpack ] Chartpack object whose charts will be rendered on the screen. inputDb [ struct | Dictionary ] Input databank within which the expressions defining the charts will be evaluated, and the results plotted.","title":"Input arguments"},{"location":"reporting/chartpack/draw.html#output-arguments","text":"info [ struct ] Output information structure with the following fields: .FigureHandles - handles to all figure objects created; .AxesHandles - cell array of handles to all axes objects created, grouped by figures; .PlotHandles - cell array of cell arrays of handles to all objects plotted within axes, grouped by figures and by axes; .TitleHandles - cell array of handles to all title objects created, grouped by figures; .SubtitleHandles - cell array of handles to all subtitle objects created, grouped by figures;","title":"Output arguments"},{"location":"reporting/chartpack/draw.html#description","text":"","title":"Description"},{"location":"reporting/chartpack/draw.html#examples","text":"","title":"Examples"},{"location":"reporting/rephrase/index.html","text":"Interface to rephrase.js","title":"Introduction"},{"location":"reporting/rephrase/index.html#interface-to-rephrasejs","text":"","title":"Interface to rephrase.js"},{"location":"statistics-utilities/index.html","text":"Statistics Utilities","title":"Introduction"},{"location":"statistics-utilities/index.html#statistics-utilities","text":"","title":"Statistics Utilities"},{"location":"statistics-utilities/distribution/index.html","text":"Distribution Package","title":"Introduction"},{"location":"statistics-utilities/distribution/index.html#distribution-package","text":"","title":"Distribution Package"},{"location":"statistics-utilities/distribution/beta/index.html","text":"Beta Distribution Constructors The following are static constructors and need to be called with distribution.Beta. preceding their names. fromAB - Beta distribution from parameters A and B fromMeanVar - Beta distribution from mean and variance fromMeanStd - Beta distribution from mean and std deviation fromModeVar - Beta distribution from mode and variance fromModeStd - Beta distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution A - Parameter A of Beta distribution Beta - Beta distribution object Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Introduction"},{"location":"statistics-utilities/distribution/beta/index.html#beta-distribution","text":"Constructors The following are static constructors and need to be called with distribution.Beta. preceding their names. fromAB - Beta distribution from parameters A and B fromMeanVar - Beta distribution from mean and variance fromMeanStd - Beta distribution from mean and std deviation fromModeVar - Beta distribution from mode and variance fromModeStd - Beta distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution A - Parameter A of Beta distribution Beta - Beta distribution object Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Beta Distribution"},{"location":"statistics-utilities/distribution/gamma/index.html","text":"Gamma Distribution Constructors The following are static constructors and need to be called with distribution.Gamma. preceding their names. fromShapeScale - Gamma distribution from shape and scale parameters fromAlphaBeta - Gamma distribution from alpha and beta parameters fromMeanVar - Gamma distribution from mean and variance fromMeanStd - Gamma distribution from mean and std deviation fromModeVar - Gamma distribution from mode and variance fromModeStd - Gamma distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution Alpha - Alpha (shape) parameter of Gamma distribution Beta - Beta (scale) parameter of Gamma distribution Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Shape - Shape parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Introduction"},{"location":"statistics-utilities/distribution/gamma/index.html#gamma-distribution","text":"Constructors The following are static constructors and need to be called with distribution.Gamma. preceding their names. fromShapeScale - Gamma distribution from shape and scale parameters fromAlphaBeta - Gamma distribution from alpha and beta parameters fromMeanVar - Gamma distribution from mean and variance fromMeanStd - Gamma distribution from mean and std deviation fromModeVar - Gamma distribution from mode and variance fromModeStd - Gamma distribution from mode and std deviation Distribution Properties These properties are directly accessible through the distribution object, followed by a dot and the name of a property. Name - Name of the distribution Domain - Domain of the distribution Alpha - Alpha (shape) parameter of Gamma distribution Beta - Beta (scale) parameter of Gamma distribution Mean - Mean (expected value) of distribution Var - Variance of distribution Std - Standard deviation of distribution Mode - Mode of distribution Median - Median of distribution Location - Location parameter of distribution Shape - Shape parameter of distribution Scale - Scale parameter of distribution Density Related Functions pdf - Probability density function logPdf - Log of probability density function up to constant info - Minus second derivative of log of probability density function inDomain - True for data points within domain of distribution function Description","title":"Gamma Distribution"},{"location":"structural-modeling/index.html","text":"Structural Modeling","title":"Introduction"},{"location":"structural-modeling/index.html#structural-modeling","text":"","title":"Structural Modeling"},{"location":"structural-modeling/explanatory/index.html","text":"Explanatory Equations","title":"Introduction"},{"location":"structural-modeling/explanatory/index.html#explanatory-equations","text":"","title":"Explanatory Equations"},{"location":"structural-modeling/explanatory/collectResidualNames.html","text":"collectLhsNames Collect names of LHS variables Syntax residualNames = collectRhsNames(this) Input Arguments this [ Explanatory ] Explanatory object or array from which the names of all residuals will be collected and returned. Output Arguments residualNames [ string ] The names of all residuals collected from this Explanatory object or array. Description Examples x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); collectResidualNames ( x ) ans = 1x2 string array \"res_a\" \"res_b\" x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); x ( 1 ). ResidualNamePattern = [ \"shock_\" , \"_f2\" ]; collectResidualNames ( x ) ans = 1x2 string array \"shock_a_f2\" \"res_b\"","title":"collectResidualNames"},{"location":"structural-modeling/explanatory/collectResidualNames.html#collectlhsnames","text":"Collect names of LHS variables","title":"collectLhsNames"},{"location":"structural-modeling/explanatory/collectResidualNames.html#syntax","text":"residualNames = collectRhsNames(this)","title":"Syntax"},{"location":"structural-modeling/explanatory/collectResidualNames.html#input-arguments","text":"this [ Explanatory ] Explanatory object or array from which the names of all residuals will be collected and returned.","title":"Input Arguments"},{"location":"structural-modeling/explanatory/collectResidualNames.html#output-arguments","text":"residualNames [ string ] The names of all residuals collected from this Explanatory object or array.","title":"Output Arguments"},{"location":"structural-modeling/explanatory/collectResidualNames.html#description","text":"","title":"Description"},{"location":"structural-modeling/explanatory/collectResidualNames.html#examples","text":"x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); collectResidualNames ( x ) ans = 1x2 string array \"res_a\" \"res_b\" x = Explanatory . fromString ([ \"a = a{-1}\" , \"b = a + c\" ]); x ( 1 ). ResidualNamePattern = [ \"shock_\" , \"_f2\" ]; collectResidualNames ( x ) ans = 1x2 string array \"shock_a_f2\" \"res_b\"","title":"Examples"},{"location":"structural-modeling/explanatory/regress.html","text":"regress Estimate parameters and residual models in Explanatory object Syntax [expy, outputDb, info] = regress(expy, inputDb, fittedRange, ...) Input Arguments expy [ Explanatory ] Explanatory object or array whose parameters (associated with regression terms) will be estimated by running a single-equation linear regression; only those parameters that have the corresonding element in .Fixed set to NaN will be estimated.k inputDb [ struct | Dictionary ] Input databank from which the time series for each variable in the Explanatory object or array will be retrieved. fittedRange [ DateWrapper ] Date range on which the linear regression(s) will be fitted; this range does not include the pre-sample initial condition if there are lags in the Explanatory object or array. Output Arguments expy [ Explanatory ] Output Explanatory object or array with the parameters estimated. outputDb [ struct | Dictionary ] Output databank inclusive of the fitted values and residuals (whose names will be created using the .FittedNamePattern and .ResidualNamePattern . info [ struct ] Information structure with the following fields: .FittedRange - A K-by-N cell array with the dates of the fitted periods for each of the K equations and each of the N data pages or parameter variants. .ExitFlagsResidualModels - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the residual models; NaN means no residual model was estimated. .ExitFlagsParameters - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the parameters; NaN means the parameters were estimated by linear regression with no iterative procedure. Options AppendInput=false [ true | false ] Append post-sample data from the inputDb to the outputDb . __ MissingObservations=\"warning\" [ \"error\" | \"warning\" | \"silent\" ] Action taken when some within-sample observations are missing: \"error\" means an error message will be thrown; \"warning\" means these observations will be excluded from the estimation sample with a warning; \"silent\" means these observations will be excluded from the estimation sample silently. PrependInput=false [ true | false ] Prepend pre-sample data from the inputDb to the outputDb . Description Example Create an Explanatory object from a string inclusive of three regression terms, i.e. additive terms preceded by +@* or -@* : expy0 = Explanatory . fromString ( \"difflog(x) = @ + @*difflog(x{-1}) + @*log(z)\" ); expy0 . Parameters Assign some parameters to the three regression terms: expy0 . Parameters = [ 0.002 , 0.8 , 1 ]; Simulate the equation period by period, using random shocks (names 'res_x' by default) and random observations for z : rng ( 981 ); d0 = struct (); d0 . x = Series ( qq ( 2020 , 1 ), ones ( 40 , 1 )); d0 . z = Series ( qq ( 2020 , 1 ), exp ( randn ( 40 , 1 ) / 10 )); d0 . res_x = Series ( qq ( 2020 , 1 ), randn ( 40 , 1 ) / 50 ); d1 = simulate ( expy0 , d0 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); Estimate the parameters using the simulated data, and compare the parameter estimates and the estimated residuals with their \"true\" values: [ expy2 , d2 ] = regress ( expy0 , d1 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); [ expy0 . Parameters ; expy2 . Parameters ] plot ([ d0 . res_x , d2 . res_x ]);","title":"regress"},{"location":"structural-modeling/explanatory/regress.html#regress","text":"Estimate parameters and residual models in Explanatory object","title":"regress"},{"location":"structural-modeling/explanatory/regress.html#syntax","text":"[expy, outputDb, info] = regress(expy, inputDb, fittedRange, ...)","title":"Syntax"},{"location":"structural-modeling/explanatory/regress.html#input-arguments","text":"expy [ Explanatory ] Explanatory object or array whose parameters (associated with regression terms) will be estimated by running a single-equation linear regression; only those parameters that have the corresonding element in .Fixed set to NaN will be estimated.k inputDb [ struct | Dictionary ] Input databank from which the time series for each variable in the Explanatory object or array will be retrieved. fittedRange [ DateWrapper ] Date range on which the linear regression(s) will be fitted; this range does not include the pre-sample initial condition if there are lags in the Explanatory object or array.","title":"Input Arguments"},{"location":"structural-modeling/explanatory/regress.html#output-arguments","text":"expy [ Explanatory ] Output Explanatory object or array with the parameters estimated. outputDb [ struct | Dictionary ] Output databank inclusive of the fitted values and residuals (whose names will be created using the .FittedNamePattern and .ResidualNamePattern . info [ struct ] Information structure with the following fields: .FittedRange - A K-by-N cell array with the dates of the fitted periods for each of the K equations and each of the N data pages or parameter variants. .ExitFlagsResidualModels - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the residual models; NaN means no residual model was estimated. .ExitFlagsParameters - A K-by-N numeric array with the Optimization Tbx exit flags from estimating the parameters; NaN means the parameters were estimated by linear regression with no iterative procedure.","title":"Output Arguments"},{"location":"structural-modeling/explanatory/regress.html#options","text":"AppendInput=false [ true | false ] Append post-sample data from the inputDb to the outputDb . __ MissingObservations=\"warning\" [ \"error\" | \"warning\" | \"silent\" ] Action taken when some within-sample observations are missing: \"error\" means an error message will be thrown; \"warning\" means these observations will be excluded from the estimation sample with a warning; \"silent\" means these observations will be excluded from the estimation sample silently. PrependInput=false [ true | false ] Prepend pre-sample data from the inputDb to the outputDb .","title":"Options"},{"location":"structural-modeling/explanatory/regress.html#description","text":"","title":"Description"},{"location":"structural-modeling/explanatory/regress.html#example","text":"Create an Explanatory object from a string inclusive of three regression terms, i.e. additive terms preceded by +@* or -@* : expy0 = Explanatory . fromString ( \"difflog(x) = @ + @*difflog(x{-1}) + @*log(z)\" ); expy0 . Parameters Assign some parameters to the three regression terms: expy0 . Parameters = [ 0.002 , 0.8 , 1 ]; Simulate the equation period by period, using random shocks (names 'res_x' by default) and random observations for z : rng ( 981 ); d0 = struct (); d0 . x = Series ( qq ( 2020 , 1 ), ones ( 40 , 1 )); d0 . z = Series ( qq ( 2020 , 1 ), exp ( randn ( 40 , 1 ) / 10 )); d0 . res_x = Series ( qq ( 2020 , 1 ), randn ( 40 , 1 ) / 50 ); d1 = simulate ( expy0 , d0 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); Estimate the parameters using the simulated data, and compare the parameter estimates and the estimated residuals with their \"true\" values: [ expy2 , d2 ] = regress ( expy0 , d1 , qq ( 2021 , 1 ): qq ( 2029 , 4 )); [ expy0 . Parameters ; expy2 . Parameters ] plot ([ d0 . res_x , d2 . res_x ]);","title":"Example"},{"location":"structural-modeling/linear/index.html","text":"Linear Systems","title":"Introduction"},{"location":"structural-modeling/linear/index.html#linear-systems","text":"","title":"Linear Systems"},{"location":"structural-modeling/model/index.html","text":"Models Categorical list of functions Constructing model objects Function Description Model.fromFile Create new Model object from model source file(s) Model.fromSnippet Create new Model object from snippet of code within m-file Model.fromString Create new Model object from snippet of code within m-file Solving and simulating models Function Description solve Calculate first-order solution matrices simulate Run a model simulation Getting information about models Function Description table Create table based on selected indicators from Model object","title":"Introduction"},{"location":"structural-modeling/model/index.html#models","text":"","title":"Models"},{"location":"structural-modeling/model/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"structural-modeling/model/index.html#constructing-model-objects","text":"Function Description Model.fromFile Create new Model object from model source file(s) Model.fromSnippet Create new Model object from snippet of code within m-file Model.fromString Create new Model object from snippet of code within m-file","title":"Constructing model objects"},{"location":"structural-modeling/model/index.html#solving-and-simulating-models","text":"Function Description solve Calculate first-order solution matrices simulate Run a model simulation","title":"Solving and simulating models"},{"location":"structural-modeling/model/index.html#getting-information-about-models","text":"Function Description table Create table based on selected indicators from Model object","title":"Getting information about models"},{"location":"structural-modeling/model/access.html","text":"access Access properties of Model objects Syntax output = access(model, what) Input arguments model [ Model ] Model objects that will be queried about what . what [ string ] One of the valid queries into the model object properties listed below. Output arguments output [ * ] Response to the query about what . Valid queries \"transition-variables\" \"transition-shocks\" \"measurement-variables\" \"measurement-shocks\" \"parameters\" \"exogenous-variables\" Return a string array of all the names of the respective type in order of their apperance in the declaration sections of the source model file(s). Description Example","title":"access"},{"location":"structural-modeling/model/access.html#access","text":"Access properties of Model objects","title":"access"},{"location":"structural-modeling/model/access.html#syntax","text":"output = access(model, what)","title":"Syntax"},{"location":"structural-modeling/model/access.html#input-arguments","text":"model [ Model ] Model objects that will be queried about what . what [ string ] One of the valid queries into the model object properties listed below.","title":"Input arguments"},{"location":"structural-modeling/model/access.html#output-arguments","text":"output [ * ] Response to the query about what .","title":"Output arguments"},{"location":"structural-modeling/model/access.html#valid-queries","text":"\"transition-variables\" \"transition-shocks\" \"measurement-variables\" \"measurement-shocks\" \"parameters\" \"exogenous-variables\" Return a string array of all the names of the respective type in order of their apperance in the declaration sections of the source model file(s).","title":"Valid queries"},{"location":"structural-modeling/model/access.html#description","text":"","title":"Description"},{"location":"structural-modeling/model/access.html#example","text":"","title":"Example"},{"location":"structural-modeling/model/checkSteady.html","text":"checkSteady Check if equations hold for currently assigned steady-state values","title":"checkSteady"},{"location":"structural-modeling/model/checkSteady.html#checksteady","text":"Check if equations hold for currently assigned steady-state values","title":"checkSteady"},{"location":"structural-modeling/model/fromFile.html","text":"Model.fromFile Create new Model object from model source file(s) Syntax m = Model.fromFile(fileName, ...) Input arguments fileName [ string ] Name(s) of model source file(s) that will be loaded, parsed, and converted to a new Model object. Output arguments m [ Model ] New Model object based on the input model source file or files listed in fileNames . General options Assign=struct( ) [ struct | empty ] Assign model parameters and/or steady states from this database at the time the model objects is being created. AutoDeclareParameters=false [ true | false ] If true , disregard any parameter declaration sections in the model file, and determine the list of parameters automatically as residual names found in equations but not declared. BaseYear=@config [ numeric | @config ] Base year for constructing deterministic time trends; @config means the base year will be read from iris configuration. Comment='' [ char ] Text comment attached to the model object. CheckSyntax=true [ true | false ] Perform syntax checks on model equations; setting CheckSyntax=false may help reduce load time for larger model objects (provided the model file is known to be free of syntax errors). Epsilon=eps^(1/4) [ numeric ] The minimum relative step size for numerical differentiation. Linear=false [ true | false ] Indicate linear models. MakeBkw=@auto [ @auto | @all | string ] Variables included in the list will be made part of the vector of backward-looking variables; @auto means the variables that do not have any lag in model equations will be put in the vector of forward-looking variables. AllowMultiple=false [ true | false ] Allow each variable, shock, or parameter name to be declared (and assigned) more than once in the model file. Optimal={ } [ cell ] Specify optimal policy options, see Optimal for policy options models below; only applicable when the keyword min is used in the model source file. OrderLinks=true [ true | false ] Reorder !links so that they can be executed sequentially. RemoveLeads=false [ true | false ] Remove all leads (aka forward-looking variables) from the state-space vector and keep included only current dates and lags; the leads are not a necessary part of the model solution and can dropped e.g. for memory efficiency reasons in larger model objects. SteadyOnly=false [ true | false ] Read in only the steady-state versions of equations (if available). Std=@auto [ numeric | @auto ] Default standard deviation for model shocks; @auto means 1 for linear models and log(1.01) for nonlinear models. UserData=[ ] [ ... ] Attach user data to the model object. Options for optimal policy models The following options for optimal policy models need to be nested within the 'Optimal=' option. MultiplierPrefix='Mu_' [ char ] Prefix used to create names for lagrange multipliers associated with the optimal policy problem; the prefix is followed by the equation number. Nonnegative=[] [ string ] List of variables constrained to be nonnegative. Type=\"discretion\" [ \"commitment\" | \"discretion\" ] Type of optimal policy; \"discretion\" means leads (expectations) are taken as given and not differentiated w.r.t. whereas \"commitment\" means both lags and leads are differentiated w.r.t. Description Loading a model file The Model.fromFile constructor can be used to read in a model source file named fileNames , and create a model object m based on these. If fileNames is an array of more than one file names then all these files get combined together in order of appearance. Examples Plain vanilla model constructor Read in a model source file named some.model , and declare the model as linear: m = Model . fromFile ( \"some.model\" , Linear = true ); Construct model object and immedidately assign parameters Read in a model source file named some.model , declare the model as linear, and assign some of the model parameters: m = Model . fromFile ( \"some.model\" , linear = true , assign = p ); Note that this is equivalent to m = Model . fromFile ( \"some.model\" , linear = true ); m = assign ( m , p ); unless some of the parameters passed in to the Model.fromFile constructor are needed to evaluate Matlab expressions inside the model source files, such as conditions in the !if or !switch expressions, or angle bracket expressions <...> .","title":"fromFile"},{"location":"structural-modeling/model/fromFile.html#modelfromfile","text":"Create new Model object from model source file(s)","title":"Model.fromFile"},{"location":"structural-modeling/model/fromFile.html#syntax","text":"m = Model.fromFile(fileName, ...)","title":"Syntax"},{"location":"structural-modeling/model/fromFile.html#input-arguments","text":"fileName [ string ] Name(s) of model source file(s) that will be loaded, parsed, and converted to a new Model object.","title":"Input arguments"},{"location":"structural-modeling/model/fromFile.html#output-arguments","text":"m [ Model ] New Model object based on the input model source file or files listed in fileNames .","title":"Output arguments"},{"location":"structural-modeling/model/fromFile.html#general-options","text":"Assign=struct( ) [ struct | empty ] Assign model parameters and/or steady states from this database at the time the model objects is being created. AutoDeclareParameters=false [ true | false ] If true , disregard any parameter declaration sections in the model file, and determine the list of parameters automatically as residual names found in equations but not declared. BaseYear=@config [ numeric | @config ] Base year for constructing deterministic time trends; @config means the base year will be read from iris configuration. Comment='' [ char ] Text comment attached to the model object. CheckSyntax=true [ true | false ] Perform syntax checks on model equations; setting CheckSyntax=false may help reduce load time for larger model objects (provided the model file is known to be free of syntax errors). Epsilon=eps^(1/4) [ numeric ] The minimum relative step size for numerical differentiation. Linear=false [ true | false ] Indicate linear models. MakeBkw=@auto [ @auto | @all | string ] Variables included in the list will be made part of the vector of backward-looking variables; @auto means the variables that do not have any lag in model equations will be put in the vector of forward-looking variables. AllowMultiple=false [ true | false ] Allow each variable, shock, or parameter name to be declared (and assigned) more than once in the model file. Optimal={ } [ cell ] Specify optimal policy options, see Optimal for policy options models below; only applicable when the keyword min is used in the model source file. OrderLinks=true [ true | false ] Reorder !links so that they can be executed sequentially. RemoveLeads=false [ true | false ] Remove all leads (aka forward-looking variables) from the state-space vector and keep included only current dates and lags; the leads are not a necessary part of the model solution and can dropped e.g. for memory efficiency reasons in larger model objects. SteadyOnly=false [ true | false ] Read in only the steady-state versions of equations (if available). Std=@auto [ numeric | @auto ] Default standard deviation for model shocks; @auto means 1 for linear models and log(1.01) for nonlinear models. UserData=[ ] [ ... ] Attach user data to the model object.","title":"General options"},{"location":"structural-modeling/model/fromFile.html#options-for-optimal-policy-models","text":"The following options for optimal policy models need to be nested within the 'Optimal=' option. MultiplierPrefix='Mu_' [ char ] Prefix used to create names for lagrange multipliers associated with the optimal policy problem; the prefix is followed by the equation number. Nonnegative=[] [ string ] List of variables constrained to be nonnegative. Type=\"discretion\" [ \"commitment\" | \"discretion\" ] Type of optimal policy; \"discretion\" means leads (expectations) are taken as given and not differentiated w.r.t. whereas \"commitment\" means both lags and leads are differentiated w.r.t.","title":"Options for optimal policy models"},{"location":"structural-modeling/model/fromFile.html#description","text":"","title":"Description"},{"location":"structural-modeling/model/fromFile.html#loading-a-model-file","text":"The Model.fromFile constructor can be used to read in a model source file named fileNames , and create a model object m based on these. If fileNames is an array of more than one file names then all these files get combined together in order of appearance.","title":"Loading a model file"},{"location":"structural-modeling/model/fromFile.html#examples","text":"","title":"Examples"},{"location":"structural-modeling/model/fromFile.html#plain-vanilla-model-constructor","text":"Read in a model source file named some.model , and declare the model as linear: m = Model . fromFile ( \"some.model\" , Linear = true );","title":"Plain vanilla model constructor"},{"location":"structural-modeling/model/fromFile.html#construct-model-object-and-immedidately-assign-parameters","text":"Read in a model source file named some.model , declare the model as linear, and assign some of the model parameters: m = Model . fromFile ( \"some.model\" , linear = true , assign = p ); Note that this is equivalent to m = Model . fromFile ( \"some.model\" , linear = true ); m = assign ( m , p ); unless some of the parameters passed in to the Model.fromFile constructor are needed to evaluate Matlab expressions inside the model source files, such as conditions in the !if or !switch expressions, or angle bracket expressions <...> .","title":"Construct model object and immedidately assign parameters"},{"location":"structural-modeling/model/fromSnippet.html","text":"Model.fromSnippet Create new Model object from snippet of code within m-file Syntax m = Model.fromSnippet(snippetName, ...) Input arguments snippetName [ string ] Name(s) of snippet(s) of code embedded in the same m-file as the call to this function. Output arguments m [ Model ] New Model object based on the snippet(s) of code. Options The options are the same as in Model.fromFile . Description The snippet of model source code is placed within the very m-file (script or function) from where the Model.fromSnippet is called. In that file, the snippet needs to be enclosed within Matlab block comment signs, and inside those, within a start and and end mark as follows: %{ snippetName>>> ... ... % Here goes the model source code ... <<<snippetName %} Note there is no space between the name of the snippet and the start and end markes, >>> and <<< , respectively. The snippet can be placed anywhere in the m-file, before or after the Model.fromSnippet function. Examples m = Model . fromSnippet ( \"example\" , Linear = true ); m . rho_x = 0.8 ; %{ example>>> !variables x !parameters rho_x !shocks eps_x !equations x = rho_x*x{-1} + eps_x; <<<example %} m = solve ( m ); m = steady ( m );","title":"fromSnippet"},{"location":"structural-modeling/model/fromSnippet.html#modelfromsnippet","text":"Create new Model object from snippet of code within m-file","title":"Model.fromSnippet"},{"location":"structural-modeling/model/fromSnippet.html#syntax","text":"m = Model.fromSnippet(snippetName, ...)","title":"Syntax"},{"location":"structural-modeling/model/fromSnippet.html#input-arguments","text":"snippetName [ string ] Name(s) of snippet(s) of code embedded in the same m-file as the call to this function.","title":"Input arguments"},{"location":"structural-modeling/model/fromSnippet.html#output-arguments","text":"m [ Model ] New Model object based on the snippet(s) of code.","title":"Output arguments"},{"location":"structural-modeling/model/fromSnippet.html#options","text":"The options are the same as in Model.fromFile .","title":"Options"},{"location":"structural-modeling/model/fromSnippet.html#description","text":"The snippet of model source code is placed within the very m-file (script or function) from where the Model.fromSnippet is called. In that file, the snippet needs to be enclosed within Matlab block comment signs, and inside those, within a start and and end mark as follows: %{ snippetName>>> ... ... % Here goes the model source code ... <<<snippetName %} Note there is no space between the name of the snippet and the start and end markes, >>> and <<< , respectively. The snippet can be placed anywhere in the m-file, before or after the Model.fromSnippet function.","title":"Description"},{"location":"structural-modeling/model/fromSnippet.html#examples","text":"m = Model . fromSnippet ( \"example\" , Linear = true ); m . rho_x = 0.8 ; %{ example>>> !variables x !parameters rho_x !shocks eps_x !equations x = rho_x*x{-1} + eps_x; <<<example %} m = solve ( m ); m = steady ( m );","title":"Examples"},{"location":"structural-modeling/model/fromString.html","text":"Model.fromString Create new Model object from string array Syntax m = Model.fromString(inputString, ...) Input arguments inputString [ string ] Input string array whose elements will be joined as lines of model source codemodel source code. Output arguments m [ Model ] New Model object based on the inputString . Options The options are the same as in Model.fromFile . Description Examples m = Model . fromString ([ \"!variables x\" \"!shocks eps\" \"!parameters rho\" \"!equations x = rho*x{-1} + eps;\" ], \"linear\" , true ); m = solve ( m ); m = steady ( m );","title":"fromString"},{"location":"structural-modeling/model/fromString.html#modelfromstring","text":"Create new Model object from string array","title":"Model.fromString"},{"location":"structural-modeling/model/fromString.html#syntax","text":"m = Model.fromString(inputString, ...)","title":"Syntax"},{"location":"structural-modeling/model/fromString.html#input-arguments","text":"inputString [ string ] Input string array whose elements will be joined as lines of model source codemodel source code.","title":"Input arguments"},{"location":"structural-modeling/model/fromString.html#output-arguments","text":"m [ Model ] New Model object based on the inputString .","title":"Output arguments"},{"location":"structural-modeling/model/fromString.html#options","text":"The options are the same as in Model.fromFile .","title":"Options"},{"location":"structural-modeling/model/fromString.html#description","text":"","title":"Description"},{"location":"structural-modeling/model/fromString.html#examples","text":"m = Model . fromString ([ \"!variables x\" \"!shocks eps\" \"!parameters rho\" \"!equations x = rho*x{-1} + eps;\" ], \"linear\" , true ); m = solve ( m ); m = steady ( m );","title":"Examples"},{"location":"structural-modeling/model/replaceNames.html","text":"replaceNames Replace model names with some other names Syntax model = replaceNames(model, oldNames, newNames) Input arguments model [ Model ] Model object in which some names (variables, shocks, parameters) will be replaced with new names. oldNames [ string ] List of existing model names that will be replace with newNames . newNames [ string ] List of new names that will replace the oldNames in the model . The lenght of the newNames list must be the same as oldNames . The new names must be such that the entire list of all the model names after replacement has all names unique. Output arguments model [ Model ] Model object with the newNames assigned. Description Use this function to rename some of the model names (variables, shocks, parameters). The replacement affects the names under which model quantities are being assigned, read in from input databanks, or written out to output databanks in functions like Model/simulate . The internal representation of the model variables, shocks and parameters in the model equations is independent of their names. Examples Run the same univariate model for multiple variables Create a model object from the following","title":"replaceNames"},{"location":"structural-modeling/model/replaceNames.html#replacenames","text":"Replace model names with some other names","title":"replaceNames"},{"location":"structural-modeling/model/replaceNames.html#syntax","text":"model = replaceNames(model, oldNames, newNames)","title":"Syntax"},{"location":"structural-modeling/model/replaceNames.html#input-arguments","text":"model [ Model ] Model object in which some names (variables, shocks, parameters) will be replaced with new names. oldNames [ string ] List of existing model names that will be replace with newNames . newNames [ string ] List of new names that will replace the oldNames in the model . The lenght of the newNames list must be the same as oldNames . The new names must be such that the entire list of all the model names after replacement has all names unique.","title":"Input arguments"},{"location":"structural-modeling/model/replaceNames.html#output-arguments","text":"model [ Model ] Model object with the newNames assigned.","title":"Output arguments"},{"location":"structural-modeling/model/replaceNames.html#description","text":"Use this function to rename some of the model names (variables, shocks, parameters). The replacement affects the names under which model quantities are being assigned, read in from input databanks, or written out to output databanks in functions like Model/simulate . The internal representation of the model variables, shocks and parameters in the model equations is independent of their names.","title":"Description"},{"location":"structural-modeling/model/replaceNames.html#examples","text":"","title":"Examples"},{"location":"structural-modeling/model/replaceNames.html#run-the-same-univariate-model-for-multiple-variables","text":"Create a model object from the following","title":"Run the same univariate model for multiple variables"},{"location":"structural-modeling/model/simulate.html","text":"simulate Run a model simulation Syntax [outputDb, outputInfo, frameDb] = simulate(model, inputDb, range, ...) Input Arguments model [ Model ] Model object with a valid solution avalaible for each of its parameter variants. inputDb [ struct | Dictionary ] Input databank from which the following data will be retrieved: initial conditions for the lags of transition variables; use access(model, \"initials\") to get the list of the necessary initial conditions; shocks within the simulation range; if shocks are missing, the default zero value is used in the simulation; data points for the transition variables exogenized in the simulation Plan (entered optionally through the plan= option); initial paths for transition variables in nonlinear simulations ( method=\"stacked\" or method=\"period\" ) when the initial iteration is requested to be taken from the input data and not the default first-order simulation, startIterationsFrom=\"data\" . range [ DateWrapper | numeric ] Simulation range; the simulation range is always from the first date to the last date specified in the range . Output Arguments outputDb [ struct | Dictionary ] Databank (struct or Dictionary) with the simulation results; if options prependInput= or appendInput= are not used, the time series in outputDb span the simulation range plus all necessary initial conditions for those variables that have lags in the model. outputInfo [ struct ] Info struct with details on the simulation; the outputInfo struct contains the following fields: .FrameColumns .FrameDates .BaseRange .ExtendedRange .Success .ExitFlags .DiscrepancyTables .ProgressBar frameDb [ cell ] Only returned nonempty when method=\"stacked\" : Nested cell arrays with databanks containing the simulation results of each individual frame; the frameDb{i}{j} element is the output databank from simulating the j-th frame in the i-th variant or data page. Options method=\"firstOrder\" [ \"firstOrder\" | \"stacked\" | \"period\" ] Simulation method: method=\"firstOrder\" - use a first-order approximate solution; method=\"stacked\" - solve the model numerically as a stacked-time system of nonlinear-equations using a quasi-Newton method. method=\"period\" - solve the model numerically as a system of nonlinear-equations period by period using a quasi-Newton method; in forward-looking models, the model-consistent expectations are replaced with the values found in the inputDb The nonlinear simulation methods also further use the solver= option to specify the settings for the nonlinear solver. deviation=false [ true | false ] If true, both the input data and the output data are (and are expected to be) in the form of deviations from steady state: for variables not declared as log-variables , the deviations from steady state are calculated as a plain difference: \\(x_t - \\bar x_t\\) for variables declared as log-variables , the deviations from steady state are calculated as a ratio: \\(x_t / \\bar x_t\\) . prependInput=false [ true | false ] If true , the data from inputDb preceding the simulation range will be included in the output time series returned in outputDb . appendInput=false [ true | false ] If true , the data from inputDb succeeding the simulation range will be included in the output time series returned in outputDb . solver=@auto [ @auto | string | cell ] The name of the numerical solver to use for solving nonlinear simulations ( method=\"stacked\" or method=\"period\" ), optionally also with solver settings; see Description. Description Numerical solver settings in nonlinear simulations When method=\"stacked\" or method=\"period\" , the model is solved as a nonlinear system of equations using an IrisT quasi-Newton solver. There are two basic varieties of the numerical solver in IrisT: a quasi-Newton, called \"iris-newton\" ; this is a traditional Newton algorithm with optional step size optimization; a quasi-Newton-steepest-descent, called \"iris-qnsd\" ; this solver combines the quasi-Newton step with a Cauchy (steepest descent) step and regularizes the Jacobian matrix in the process. For most simulations, the \"iris-newton\" (which is the default choice) is the appropriate choice; however, you can still modify some of the settings by specifying a cell array whose first element is the name of the solver ( \"iris-newton\" or \"iris-qnsd\" ) followed by any number of name-value pairs for the individual settings; for instance: outputDb = simulate ( ... model , inputDb , range ... , method = \"stacked\" ... , solver ={ \"iris-newton\" , \"maxIterations\" , 100 , \"functionTolerance\" , 1e-5 } ... ); See Numerical solver settings for the description of all settings. Example","title":"simulate"},{"location":"structural-modeling/model/simulate.html#simulate","text":"Run a model simulation","title":"simulate"},{"location":"structural-modeling/model/simulate.html#syntax","text":"[outputDb, outputInfo, frameDb] = simulate(model, inputDb, range, ...)","title":"Syntax"},{"location":"structural-modeling/model/simulate.html#input-arguments","text":"model [ Model ] Model object with a valid solution avalaible for each of its parameter variants. inputDb [ struct | Dictionary ] Input databank from which the following data will be retrieved: initial conditions for the lags of transition variables; use access(model, \"initials\") to get the list of the necessary initial conditions; shocks within the simulation range; if shocks are missing, the default zero value is used in the simulation; data points for the transition variables exogenized in the simulation Plan (entered optionally through the plan= option); initial paths for transition variables in nonlinear simulations ( method=\"stacked\" or method=\"period\" ) when the initial iteration is requested to be taken from the input data and not the default first-order simulation, startIterationsFrom=\"data\" . range [ DateWrapper | numeric ] Simulation range; the simulation range is always from the first date to the last date specified in the range .","title":"Input Arguments"},{"location":"structural-modeling/model/simulate.html#output-arguments","text":"outputDb [ struct | Dictionary ] Databank (struct or Dictionary) with the simulation results; if options prependInput= or appendInput= are not used, the time series in outputDb span the simulation range plus all necessary initial conditions for those variables that have lags in the model. outputInfo [ struct ] Info struct with details on the simulation; the outputInfo struct contains the following fields: .FrameColumns .FrameDates .BaseRange .ExtendedRange .Success .ExitFlags .DiscrepancyTables .ProgressBar frameDb [ cell ] Only returned nonempty when method=\"stacked\" : Nested cell arrays with databanks containing the simulation results of each individual frame; the frameDb{i}{j} element is the output databank from simulating the j-th frame in the i-th variant or data page.","title":"Output Arguments"},{"location":"structural-modeling/model/simulate.html#options","text":"method=\"firstOrder\" [ \"firstOrder\" | \"stacked\" | \"period\" ] Simulation method: method=\"firstOrder\" - use a first-order approximate solution; method=\"stacked\" - solve the model numerically as a stacked-time system of nonlinear-equations using a quasi-Newton method. method=\"period\" - solve the model numerically as a system of nonlinear-equations period by period using a quasi-Newton method; in forward-looking models, the model-consistent expectations are replaced with the values found in the inputDb The nonlinear simulation methods also further use the solver= option to specify the settings for the nonlinear solver. deviation=false [ true | false ] If true, both the input data and the output data are (and are expected to be) in the form of deviations from steady state: for variables not declared as log-variables , the deviations from steady state are calculated as a plain difference: \\(x_t - \\bar x_t\\) for variables declared as log-variables , the deviations from steady state are calculated as a ratio: \\(x_t / \\bar x_t\\) . prependInput=false [ true | false ] If true , the data from inputDb preceding the simulation range will be included in the output time series returned in outputDb . appendInput=false [ true | false ] If true , the data from inputDb succeeding the simulation range will be included in the output time series returned in outputDb . solver=@auto [ @auto | string | cell ] The name of the numerical solver to use for solving nonlinear simulations ( method=\"stacked\" or method=\"period\" ), optionally also with solver settings; see Description.","title":"Options"},{"location":"structural-modeling/model/simulate.html#description","text":"","title":"Description"},{"location":"structural-modeling/model/simulate.html#numerical-solver-settings-in-nonlinear-simulations","text":"When method=\"stacked\" or method=\"period\" , the model is solved as a nonlinear system of equations using an IrisT quasi-Newton solver. There are two basic varieties of the numerical solver in IrisT: a quasi-Newton, called \"iris-newton\" ; this is a traditional Newton algorithm with optional step size optimization; a quasi-Newton-steepest-descent, called \"iris-qnsd\" ; this solver combines the quasi-Newton step with a Cauchy (steepest descent) step and regularizes the Jacobian matrix in the process. For most simulations, the \"iris-newton\" (which is the default choice) is the appropriate choice; however, you can still modify some of the settings by specifying a cell array whose first element is the name of the solver ( \"iris-newton\" or \"iris-qnsd\" ) followed by any number of name-value pairs for the individual settings; for instance: outputDb = simulate ( ... model , inputDb , range ... , method = \"stacked\" ... , solver ={ \"iris-newton\" , \"maxIterations\" , 100 , \"functionTolerance\" , 1e-5 } ... ); See Numerical solver settings for the description of all settings.","title":"Numerical solver settings in nonlinear simulations"},{"location":"structural-modeling/model/simulate.html#example","text":"","title":"Example"},{"location":"structural-modeling/model/solve.html","text":"solve Calculate first-order solution matrices Syntax m = solve(model, ...) Input arguments model [ Model ] Model object with all active parameters assigned; nonlinear models must also have the steady state values assigned for all variables. Output arguments model [ Model ] Model with a newly computed solution for each parameter variant. Options Expand=0 [ numeric | NaN ] Number of periods ahead up to which the model solution will be expanded; if NaN the matrices needed to support solution expansion are not calculated and stored at all and the model cannot be used later in simulations or forecasts with anticipated shocks or plans. Eqtn=@all [ @all | \"measurement\" | \"transition\" ] Update existing solution in the measurement block, or the transition block, or both. Error=false [ true | false ] Throw an error if no unique stable solution exists; if false , a warning message only will be displayed. PreferredSchur=\"schur\" [ \"schur\" | \"qz\" ] The preferred form of Schur decomposition for purely backward looking models; PreferredSchur=\"schur\" means plain Schur decomposition (faster), PreferredSchur=\"qz\" means generalized Schur decomposition (unnecessary for backward looking models but consistent with forward looking model solutions). Progress=false [ true | false ] Display progress bar in the command window. Select=true [ true | false ] Automatically detect which equations need to be re-differentiated based on parameter changes from the last time the system matrices were calculated. Warning=true [ true | false ] Display warnings produced by this function. Description The IrisT solver uses an ordered QZ (or generalised Schur) decomposition to integrate out future expectations. The QZ may (very rarely) fail for numerical reasons. IrisT includes two patches to handle the some of the QZ failures: a SEVN2 patch (Sum-of-EigenValues-Near-Two), and an E2C2S patch (Eigenvalues-Too-Close-To-Swap). The SEVN2 patch: The model contains two or more unit roots, and the QZ algorithm interprets some of them incorrectly as pairs of eigenvalues that sum up accurately to 2, but with one of them significantly below 1 and the other significantly above 1. IrisT replaces the entries on the diagonal of one of the QZ factor matrices with numbers that evaluate to two unit roots. The E2C2S patch: The re-ordering of thq QZ matrices fails with a warning \"Reordering failed because some eigenvalues are too close to swap.\" IrisT attempts to re-order the equations until QZ works. The number of attempts is limited to N-1 at most where N is the total number of equations. Example","title":"solve"},{"location":"structural-modeling/model/solve.html#solve","text":"Calculate first-order solution matrices","title":"solve"},{"location":"structural-modeling/model/solve.html#syntax","text":"m = solve(model, ...)","title":"Syntax"},{"location":"structural-modeling/model/solve.html#input-arguments","text":"model [ Model ] Model object with all active parameters assigned; nonlinear models must also have the steady state values assigned for all variables.","title":"Input arguments"},{"location":"structural-modeling/model/solve.html#output-arguments","text":"model [ Model ] Model with a newly computed solution for each parameter variant.","title":"Output arguments"},{"location":"structural-modeling/model/solve.html#options","text":"Expand=0 [ numeric | NaN ] Number of periods ahead up to which the model solution will be expanded; if NaN the matrices needed to support solution expansion are not calculated and stored at all and the model cannot be used later in simulations or forecasts with anticipated shocks or plans. Eqtn=@all [ @all | \"measurement\" | \"transition\" ] Update existing solution in the measurement block, or the transition block, or both. Error=false [ true | false ] Throw an error if no unique stable solution exists; if false , a warning message only will be displayed. PreferredSchur=\"schur\" [ \"schur\" | \"qz\" ] The preferred form of Schur decomposition for purely backward looking models; PreferredSchur=\"schur\" means plain Schur decomposition (faster), PreferredSchur=\"qz\" means generalized Schur decomposition (unnecessary for backward looking models but consistent with forward looking model solutions). Progress=false [ true | false ] Display progress bar in the command window. Select=true [ true | false ] Automatically detect which equations need to be re-differentiated based on parameter changes from the last time the system matrices were calculated. Warning=true [ true | false ] Display warnings produced by this function.","title":"Options"},{"location":"structural-modeling/model/solve.html#description","text":"The IrisT solver uses an ordered QZ (or generalised Schur) decomposition to integrate out future expectations. The QZ may (very rarely) fail for numerical reasons. IrisT includes two patches to handle the some of the QZ failures: a SEVN2 patch (Sum-of-EigenValues-Near-Two), and an E2C2S patch (Eigenvalues-Too-Close-To-Swap). The SEVN2 patch: The model contains two or more unit roots, and the QZ algorithm interprets some of them incorrectly as pairs of eigenvalues that sum up accurately to 2, but with one of them significantly below 1 and the other significantly above 1. IrisT replaces the entries on the diagonal of one of the QZ factor matrices with numbers that evaluate to two unit roots. The E2C2S patch: The re-ordering of thq QZ matrices fails with a warning \"Reordering failed because some eigenvalues are too close to swap.\" IrisT attempts to re-order the equations until QZ works. The number of attempts is limited to N-1 at most where N is the total number of equations.","title":"Description"},{"location":"structural-modeling/model/solve.html#example","text":"","title":"Example"},{"location":"structural-modeling/model/steady.html","text":"steady Compute steady state or balance-growth path of the model Syntax [model, success, info] = steady(model, ...) Input arguments model [ Model ] Model for which the steady state values of its variables will be calculated. Output arguments model [ Model ] Model with its newly calculated steady state values assigned. success [ logical ] A 1-by-n array of true or false where n is the number of parameter variants in the model ; each true indicates a successeful completion (convergence) of steady state calculations. info [ struct ] Output info structure with the following fields: .ExitFlags - a 1-by-n cell array of arrays of solver.ExitFlag objects; the {i}(j) element indicates the exit flag for the i-th parameter variant and j-th block of steady equations. .Blazer - contains a solver.blazer.Steady object used when calculating the steady state values for each parameter variant. Options Warning=true [ true | false ] Display IrisT warning messages produced by this function. Options for nonlinear models Blocks=true [ true | false ] - Rearrange steady-state equations in sequential blocks before computing steady state. Endogenize=[ ] [ @auto | cellstr | char | empty ] - List of parameters that will be endogenized when computing the steady state; the number of endogenized parameters must match the number of transtion variables exogenized in the Exogenize= option; the use of the keyword @auto is explained in Description. Exogenize= [ @auto | cellstr | char | empty ] - List of transition variables that will be exogenized when computing the steady state; the number of exogenized variables must match the number of parameters exogenized in the 'Exogenize=' option; the use of the keyword @auto is explained in Description. Fix=[ ] [ cellstr | Except | empty ] - List of variables whose steady state (both level and change) will not be computed and kept fixed to the currently assigned values; alternatively an Except wrapper object can be used to specify that all variables are to be fixed except those listed. FixGrowth=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state first difference (variables not declared as log) or the steady-state rates of change (variables declared as log) of each variables listed. FixLevel=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state level of each variable listed. Growth=[] [ true | false | empty ] If true , both the steady-state levels and steady-state changes (differences or growth rates, depending on the log status of the respective variable) will be computed; if false , only the levels will be computed assuming that either all model variables are stationary, have stochastic trend without deterministic drift, or that the correct steady-state changes are already assigned in the model object. LogMinus=empty [ cell | char | empty ] - List of log variables whose steady state will be restricted to negative values in this run of sstate(~) . Reuse=false [ true | false ] - Reuse the steady-state values calculated for one parameter variant to initialize the steady-state calculation for the next parameter variant. Solver=\"qnsd\" [ \"qnsd\" | \"newton\" | \"fsolve\" | \"lsqnonlin\" | cell ] Numerical nonlinear solver (optionally also specified including non-default settings) used in steady state calculations; see Description; the default solver, \"qnsd\", is an IrisT quasi-Newton steepest-descent based algorithm. Unlog=[ ] [ cell | char | empty ] - List of log variables that will be temporarily treated as non-log variables in this run of steady(~) , i.e. their steady-state levels will not be restricted to either positive or negative values. Options for linear models Solve=false [ true | false ] Calculate first-order solution before steady state. Description Option Growth= The option Growth= is false by default which is consistent with one of the following situations: all model variables are either stationary or have stochastic trend but no deterministic trend (no deterministic trend: the simplest example is a plain vanilla random walk with no drift); the steady-state first differences (for variables not declared as log) and steady-state rates of growth (for variables declared as log) have been assigned (as imaginary parts) in the model object for all variables before running sstate(~)(~) . If some variables have an unknown deterministic trend (drift) in steady state (for instance, a balanced growth path model), sstate(~)(~) needs to be run with Growth=true . Lower and Upper Bounds Use options 'LevelWithin=' and 'ChangeWithin=' to impose lower and/or upper bounds on steady-state levels and/or growth rates of selected variables. Create a struct with a 1-by-2 vector [lower, upper] for each variable that is supposed to be bounded when the steady state is being calculated, and pass the struct into the respective option. User -Inf or Inf if only one of the bounds is specified. For instance, the following piece of code bnd = struct( ); bnd.X = [0, 10]; bnd.Y = [-Inf, 20]; bnd.Z = [5, Inf]; specifies lower bounds for variables X and Z , and upper bounds for variables X and Y . The variables that are not bounded do not need to be included in the struct. Using @auto in Options Exogenize= and Endogenize= The keyword @auto refers to !steady-autoswaps definitions and can be used in the options Exogenize= and Exogenize= in the following three possible combinations: Setting both Exogenize= and Endogenize= to @auto will exogenize all variables from !steady-autoswaps definitions and endogenize all corresponding parameters. Assigning the option Exogenize= an explicit list of variables while setting Endogenize= to @auto will exogenize only the listed variables while endogenizing the same number of the corresponding parameters from !steady-autoswaps definitions. The listed variables must each be found on the left-hand sides of a !steady-autoswaps definition. Setting Exogenize= to @auto while assigning the option Endogenize= an explicit list of parameters will exogenize only the variables that occur on the left-hand sides of those !steady-autoswaps definitions that have the listed parameters on their right-hand sides. The listed parameters must each be found on the right-hand side of a !steady-autoswaps definition. Options Fix=, FixLevel= and FixGrowth= Options Fix= , FixLevel= and FixGrowth= can be used for fixing the steady state of a subset of variables (their steady-state levels, changes, or both) to values supplied by the user before running sstate(~) . The fixed values need to be assigned to the respective variables directly in the model object, and obviously need to be the correct steady-state values. The variables are excluded from the list of unknowns when the steady-state equations are being solved. The list of variables assigned to the three options can be also defined inversely using a Except wrapper object, constructed by passing the list of variables that are not to be fixed. For instance, in sstate(m, 'FixGrowth=', Except('x', 'y')) the steady-state growth of all variables except x and y will be fixed (and needs to be supplied before calling this sstate(~) ). Example This example illustrates the use of the keyword @auto in exogenizing/endogenizing variabes/parameters. Assume that the underlying model file included the following sections: !variables W, X, Y, Z !parameters alpha, beta, gamma, delta !steady-autoswaps W := alpha; Y := beta; Z := delta; Running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', @auto) will calculate the steady state with all three variables from the !steady-autoswaps defintions, W , Y , and Z , exogenized to their currently assigned values while endogenizing the three corresponding parameters, alpha , beta , and delta . Running the following command m = sstate(m, 'Exogenize=', {'W', 'Z'}, 'Endogenize=', @auto) will calculate the steady state with the two listed variables, W and Z , exogenized and the corresponding parameters, alpha and delta , endogenized. Finally, running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', {'delta', 'beta'}) will calculate the steady state with two variables, Z and Y , (corresponding to the endogenized parameters listed) exogenized while endogenizing the listed parameters, alpha and delta . %","title":"steady"},{"location":"structural-modeling/model/steady.html#steady","text":"Compute steady state or balance-growth path of the model","title":"steady"},{"location":"structural-modeling/model/steady.html#syntax","text":"[model, success, info] = steady(model, ...)","title":"Syntax"},{"location":"structural-modeling/model/steady.html#input-arguments","text":"model [ Model ] Model for which the steady state values of its variables will be calculated.","title":"Input arguments"},{"location":"structural-modeling/model/steady.html#output-arguments","text":"model [ Model ] Model with its newly calculated steady state values assigned. success [ logical ] A 1-by-n array of true or false where n is the number of parameter variants in the model ; each true indicates a successeful completion (convergence) of steady state calculations. info [ struct ] Output info structure with the following fields: .ExitFlags - a 1-by-n cell array of arrays of solver.ExitFlag objects; the {i}(j) element indicates the exit flag for the i-th parameter variant and j-th block of steady equations. .Blazer - contains a solver.blazer.Steady object used when calculating the steady state values for each parameter variant.","title":"Output arguments"},{"location":"structural-modeling/model/steady.html#options","text":"Warning=true [ true | false ] Display IrisT warning messages produced by this function.","title":"Options"},{"location":"structural-modeling/model/steady.html#options-for-nonlinear-models","text":"Blocks=true [ true | false ] - Rearrange steady-state equations in sequential blocks before computing steady state. Endogenize=[ ] [ @auto | cellstr | char | empty ] - List of parameters that will be endogenized when computing the steady state; the number of endogenized parameters must match the number of transtion variables exogenized in the Exogenize= option; the use of the keyword @auto is explained in Description. Exogenize= [ @auto | cellstr | char | empty ] - List of transition variables that will be exogenized when computing the steady state; the number of exogenized variables must match the number of parameters exogenized in the 'Exogenize=' option; the use of the keyword @auto is explained in Description. Fix=[ ] [ cellstr | Except | empty ] - List of variables whose steady state (both level and change) will not be computed and kept fixed to the currently assigned values; alternatively an Except wrapper object can be used to specify that all variables are to be fixed except those listed. FixGrowth=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state first difference (variables not declared as log) or the steady-state rates of change (variables declared as log) of each variables listed. FixLevel=[ ] [ cellstr | empty ] - Same as Fix= except that this option fixes only the steady-state level of each variable listed. Growth=[] [ true | false | empty ] If true , both the steady-state levels and steady-state changes (differences or growth rates, depending on the log status of the respective variable) will be computed; if false , only the levels will be computed assuming that either all model variables are stationary, have stochastic trend without deterministic drift, or that the correct steady-state changes are already assigned in the model object. LogMinus=empty [ cell | char | empty ] - List of log variables whose steady state will be restricted to negative values in this run of sstate(~) . Reuse=false [ true | false ] - Reuse the steady-state values calculated for one parameter variant to initialize the steady-state calculation for the next parameter variant. Solver=\"qnsd\" [ \"qnsd\" | \"newton\" | \"fsolve\" | \"lsqnonlin\" | cell ] Numerical nonlinear solver (optionally also specified including non-default settings) used in steady state calculations; see Description; the default solver, \"qnsd\", is an IrisT quasi-Newton steepest-descent based algorithm. Unlog=[ ] [ cell | char | empty ] - List of log variables that will be temporarily treated as non-log variables in this run of steady(~) , i.e. their steady-state levels will not be restricted to either positive or negative values.","title":"Options for nonlinear models"},{"location":"structural-modeling/model/steady.html#options-for-linear-models","text":"Solve=false [ true | false ] Calculate first-order solution before steady state.","title":"Options for linear models"},{"location":"structural-modeling/model/steady.html#description","text":"Option Growth= The option Growth= is false by default which is consistent with one of the following situations: all model variables are either stationary or have stochastic trend but no deterministic trend (no deterministic trend: the simplest example is a plain vanilla random walk with no drift); the steady-state first differences (for variables not declared as log) and steady-state rates of growth (for variables declared as log) have been assigned (as imaginary parts) in the model object for all variables before running sstate(~)(~) . If some variables have an unknown deterministic trend (drift) in steady state (for instance, a balanced growth path model), sstate(~)(~) needs to be run with Growth=true . Lower and Upper Bounds Use options 'LevelWithin=' and 'ChangeWithin=' to impose lower and/or upper bounds on steady-state levels and/or growth rates of selected variables. Create a struct with a 1-by-2 vector [lower, upper] for each variable that is supposed to be bounded when the steady state is being calculated, and pass the struct into the respective option. User -Inf or Inf if only one of the bounds is specified. For instance, the following piece of code bnd = struct( ); bnd.X = [0, 10]; bnd.Y = [-Inf, 20]; bnd.Z = [5, Inf]; specifies lower bounds for variables X and Z , and upper bounds for variables X and Y . The variables that are not bounded do not need to be included in the struct. Using @auto in Options Exogenize= and Endogenize= The keyword @auto refers to !steady-autoswaps definitions and can be used in the options Exogenize= and Exogenize= in the following three possible combinations: Setting both Exogenize= and Endogenize= to @auto will exogenize all variables from !steady-autoswaps definitions and endogenize all corresponding parameters. Assigning the option Exogenize= an explicit list of variables while setting Endogenize= to @auto will exogenize only the listed variables while endogenizing the same number of the corresponding parameters from !steady-autoswaps definitions. The listed variables must each be found on the left-hand sides of a !steady-autoswaps definition. Setting Exogenize= to @auto while assigning the option Endogenize= an explicit list of parameters will exogenize only the variables that occur on the left-hand sides of those !steady-autoswaps definitions that have the listed parameters on their right-hand sides. The listed parameters must each be found on the right-hand side of a !steady-autoswaps definition. Options Fix=, FixLevel= and FixGrowth= Options Fix= , FixLevel= and FixGrowth= can be used for fixing the steady state of a subset of variables (their steady-state levels, changes, or both) to values supplied by the user before running sstate(~) . The fixed values need to be assigned to the respective variables directly in the model object, and obviously need to be the correct steady-state values. The variables are excluded from the list of unknowns when the steady-state equations are being solved. The list of variables assigned to the three options can be also defined inversely using a Except wrapper object, constructed by passing the list of variables that are not to be fixed. For instance, in sstate(m, 'FixGrowth=', Except('x', 'y')) the steady-state growth of all variables except x and y will be fixed (and needs to be supplied before calling this sstate(~) ).","title":"Description"},{"location":"structural-modeling/model/steady.html#example","text":"This example illustrates the use of the keyword @auto in exogenizing/endogenizing variabes/parameters. Assume that the underlying model file included the following sections: !variables W, X, Y, Z !parameters alpha, beta, gamma, delta !steady-autoswaps W := alpha; Y := beta; Z := delta; Running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', @auto) will calculate the steady state with all three variables from the !steady-autoswaps defintions, W , Y , and Z , exogenized to their currently assigned values while endogenizing the three corresponding parameters, alpha , beta , and delta . Running the following command m = sstate(m, 'Exogenize=', {'W', 'Z'}, 'Endogenize=', @auto) will calculate the steady state with the two listed variables, W and Z , exogenized and the corresponding parameters, alpha and delta , endogenized. Finally, running the following command m = sstate(m, 'Exogenize=', @auto, 'Endogenize=', {'delta', 'beta'}) will calculate the steady state with two variables, Z and Y , (corresponding to the endogenized parameters listed) exogenized while endogenizing the listed parameters, alpha and delta . %","title":"Example"},{"location":"structural-modeling/model/table.html","text":"table Create table based on selected indicators from Model object Syntax outputTable = table(model, request, ...) # Input arguments model [ Model ] Model object based on which the table will be prepared. requests [ char | cellstr | string ] Requested columns for the table; see Description for the list of valid requests. Output arguments outputTable [ table ] Table object with requested values. Options CompareFirstColumn=true [ true | false ] Include the first column in comparison tables (first column compares itself with itself). Diary=\"\" [ string ] If Diary= is not empty, the table will be printed on the screen in the command window, and captured in a text file under this file name. SelectRows=false [ false | string ] Select only a subset of rows (names of variables, shocks and/or parameters) to be included in the outputTable . Sort=false [ true | false ] If true sort the table rows alphabetically by the row names. Round=Inf [ Inf | numeric ] Round numeric entries in the table to the specified number of digits; Inf means no rounding. WriteTable=\"\" [ string | cell ] If non-empty, the table will be exported to a text or spreadsheet file (depending on the file extension provided) under this file name using the standard writetable( ) function; Description This is the list of valid requests that can be combined in one call of the table() function: \"SteadyLevel\" - Steady-state level for each model variable. \"SteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables. \"SteadyDiff\" - Steady-state difference for each model variable not declared as log-variables; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables; NaN for nonlog-variables. \"Form\" - Indicator of the form in which steady-state change and/or comparison are reported for each model variable: \"Diff-\" (meaning a first difference when reporting steady-state growth, or a difference between two steady states when reporting steady-state comparison) for each nonlog-variable, and \"Rate/\" for each log-variable. \"CompareSteadyLevel\" - Steady-state level for each model variable compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyDiff\" - Steady-state difference for each model variable not declared as log-variables, compared to the first parameter variant; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables, compared to the first parameter variant; NaN for nonlog-variables. \"Description\" - Description text from the model file. \"Log\" - Indicator of log-variables: true for each model variable declared as a log-variable, false otherwise. This is the list of valid requests that can be called individually: \"Parameters\" - The currently assigned value for each parameter; this request can be combined with \"Description\" . \"Stationary\" - Indicator of stationarity of variables or log variables. \"Std\" - The currently assigned value for the standard deviation of each model shock. \"Corr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks. \"CompareParameters\" - The currently assigned value for each parameter compared to the first parameter variant (a difference); this request can be combined with \"Description\" . \"CompareStd\" - The currently assigned value for the standard deviation of each model shock compared to the first parameter variant (a difference). \"CompareCorr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks compared to the first parameter variant (a difference). \"AllRoots\" - All eigenvalues associated with the current solution. \"StableRoots\" - All stable eigenvalues (smaller than 1 in magnitude) associated with the current solution. \"UnitRoots\" - All unit eigenvalues (equal 1 in magnitude) associated with the current solution. \"UnstableRoots\" - All unstable eigenvalues (greater than 1 in magnitude) associated with the current solution. Examples Plain vanilla table Create table with a steady state summary: table ( m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ]) Save table to spreadsheet Create the same table as before, and save it to an Excel spreadsheet file: table ( ... m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ] ... writeTable = \"steadyState.xls\" ... )","title":"table"},{"location":"structural-modeling/model/table.html#table","text":"Create table based on selected indicators from Model object","title":"table"},{"location":"structural-modeling/model/table.html#syntax","text":"outputTable = table(model, request, ...) # Input arguments model [ Model ] Model object based on which the table will be prepared. requests [ char | cellstr | string ] Requested columns for the table; see Description for the list of valid requests.","title":"Syntax"},{"location":"structural-modeling/model/table.html#output-arguments","text":"outputTable [ table ] Table object with requested values.","title":"Output arguments"},{"location":"structural-modeling/model/table.html#options","text":"CompareFirstColumn=true [ true | false ] Include the first column in comparison tables (first column compares itself with itself). Diary=\"\" [ string ] If Diary= is not empty, the table will be printed on the screen in the command window, and captured in a text file under this file name. SelectRows=false [ false | string ] Select only a subset of rows (names of variables, shocks and/or parameters) to be included in the outputTable . Sort=false [ true | false ] If true sort the table rows alphabetically by the row names. Round=Inf [ Inf | numeric ] Round numeric entries in the table to the specified number of digits; Inf means no rounding. WriteTable=\"\" [ string | cell ] If non-empty, the table will be exported to a text or spreadsheet file (depending on the file extension provided) under this file name using the standard writetable( ) function;","title":"Options"},{"location":"structural-modeling/model/table.html#description","text":"This is the list of valid requests that can be combined in one call of the table() function: \"SteadyLevel\" - Steady-state level for each model variable. \"SteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables. \"SteadyDiff\" - Steady-state difference for each model variable not declared as log-variables; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables; NaN for nonlog-variables. \"Form\" - Indicator of the form in which steady-state change and/or comparison are reported for each model variable: \"Diff-\" (meaning a first difference when reporting steady-state growth, or a difference between two steady states when reporting steady-state comparison) for each nonlog-variable, and \"Rate/\" for each log-variable. \"CompareSteadyLevel\" - Steady-state level for each model variable compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyChange\" - Steady-state difference (for nonlog-variables) or steady-state gross rate of change (for log-variables) for each model variables compared to the first parameter variant (a difference for each nonlog-variable, a ratio for each log-variable). \"CompareSteadyDiff\" - Steady-state difference for each model variable not declared as log-variables, compared to the first parameter variant; NaN for log-variables. \"SteadyRate\" - Steady-state gross rate of growth for each model variable declared as log-variables, compared to the first parameter variant; NaN for nonlog-variables. \"Description\" - Description text from the model file. \"Log\" - Indicator of log-variables: true for each model variable declared as a log-variable, false otherwise. This is the list of valid requests that can be called individually: \"Parameters\" - The currently assigned value for each parameter; this request can be combined with \"Description\" . \"Stationary\" - Indicator of stationarity of variables or log variables. \"Std\" - The currently assigned value for the standard deviation of each model shock. \"Corr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks. \"CompareParameters\" - The currently assigned value for each parameter compared to the first parameter variant (a difference); this request can be combined with \"Description\" . \"CompareStd\" - The currently assigned value for the standard deviation of each model shock compared to the first parameter variant (a difference). \"CompareCorr\" - The currently assigned value for the cross-correlation coefficient of each pair of model shocks compared to the first parameter variant (a difference). \"AllRoots\" - All eigenvalues associated with the current solution. \"StableRoots\" - All stable eigenvalues (smaller than 1 in magnitude) associated with the current solution. \"UnitRoots\" - All unit eigenvalues (equal 1 in magnitude) associated with the current solution. \"UnstableRoots\" - All unstable eigenvalues (greater than 1 in magnitude) associated with the current solution.","title":"Description"},{"location":"structural-modeling/model/table.html#examples","text":"","title":"Examples"},{"location":"structural-modeling/model/table.html#plain-vanilla-table","text":"Create table with a steady state summary: table ( m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ])","title":"Plain vanilla table"},{"location":"structural-modeling/model/table.html#save-table-to-spreadsheet","text":"Create the same table as before, and save it to an Excel spreadsheet file: table ( ... m , [ \"steadyLevel\" , \"steadyChange\" , \"form\" , \"description\" ] ... writeTable = \"steadyState.xls\" ... )","title":"Save table to spreadsheet"},{"location":"structural-modeling/plan/index.html","text":"Simulation plans Categorical list of functions Constructing model objects Function Description Plan.forModel Create simulation Plan for Model object Plan.forExplanatory Create simulation Plan for Explanatory object Exogenizing variables, endogenizing shocks Function Description autoswap Exogenize variables and endogenize shocks autoswap pairs","title":"Introduction"},{"location":"structural-modeling/plan/index.html#simulation-plans","text":"","title":"Simulation plans"},{"location":"structural-modeling/plan/index.html#categorical-list-of-functions","text":"","title":"Categorical list of functions"},{"location":"structural-modeling/plan/index.html#constructing-model-objects","text":"Function Description Plan.forModel Create simulation Plan for Model object Plan.forExplanatory Create simulation Plan for Explanatory object","title":"Constructing model objects"},{"location":"structural-modeling/plan/index.html#exogenizing-variables-endogenizing-shocks","text":"Function Description autoswap Exogenize variables and endogenize shocks autoswap pairs","title":"Exogenizing variables, endogenizing shocks"},{"location":"structural-modeling/plan/autoswap.html","text":"autoswap Exogenize variables and endogenize shocks autoswap pairs Syntax Input arguments Output arguments Description Examples","title":"autoswap"},{"location":"structural-modeling/plan/autoswap.html#autoswap","text":"Exogenize variables and endogenize shocks autoswap pairs","title":"autoswap"},{"location":"structural-modeling/plan/autoswap.html#syntax","text":"","title":"Syntax"},{"location":"structural-modeling/plan/autoswap.html#input-arguments","text":"","title":"Input arguments"},{"location":"structural-modeling/plan/autoswap.html#output-arguments","text":"","title":"Output arguments"},{"location":"structural-modeling/plan/autoswap.html#description","text":"","title":"Description"},{"location":"structural-modeling/plan/autoswap.html#examples","text":"","title":"Examples"},{"location":"structural-modeling/plan/forExplanatory.html","text":"Plan.forExplanatory Create simulation Plan for Explanatory object Syntax Input arguments Output arguments Description Examples","title":"forExplanatory"},{"location":"structural-modeling/plan/forExplanatory.html#planforexplanatory","text":"Create simulation Plan for Explanatory object","title":"Plan.forExplanatory"},{"location":"structural-modeling/plan/forExplanatory.html#syntax","text":"","title":"Syntax"},{"location":"structural-modeling/plan/forExplanatory.html#input-arguments","text":"","title":"Input arguments"},{"location":"structural-modeling/plan/forExplanatory.html#output-arguments","text":"","title":"Output arguments"},{"location":"structural-modeling/plan/forExplanatory.html#description","text":"","title":"Description"},{"location":"structural-modeling/plan/forExplanatory.html#examples","text":"","title":"Examples"},{"location":"structural-modeling/plan/forModel.html","text":"Plan.forModel Create simulation Plan for Model object Syntax Input arguments Output arguments Description Examples","title":"forModel"},{"location":"structural-modeling/plan/forModel.html#planformodel","text":"Create simulation Plan for Model object","title":"Plan.forModel"},{"location":"structural-modeling/plan/forModel.html#syntax","text":"","title":"Syntax"},{"location":"structural-modeling/plan/forModel.html#input-arguments","text":"","title":"Input arguments"},{"location":"structural-modeling/plan/forModel.html#output-arguments","text":"","title":"Output arguments"},{"location":"structural-modeling/plan/forModel.html#description","text":"","title":"Description"},{"location":"structural-modeling/plan/forModel.html#examples","text":"","title":"Examples"},{"location":"structural-modeling/slang/index.html","text":"Model file language Model file language is a system of keywords that define the structure of model source files. The model source files are plain text files (saved under any file name with any extension) that describe the model: its equations, variables, parameters, etc. The model files do not describe what tasks to do with the model. To run the tasks you want to perform with the model, you need first to load the model file into Matlab using the Model.fromFile function. This function creates a model object. Then you write your own m-files using Matlab and IrisT functions to perform the desired tasks with the model object. When writing model files, you can also use the IrisT preparsing commands that introduce tools for writing reusable and well-structured model code base and minimize repetitive model code writing tasks. You can get the model source files syntax highlighted in the Matlab editor to improve the readability of the files, and helps navigate the model more quickly; see the setup instructions . Categorical list of keywords Declaring model names: Variables, parameters and shocks See Declare model names: Variables, shocks, parameters for details on declaring model names. See Guideline for writing and structuring model source files . Keyword Description !transition-variables Declare names of transition variables !transition-shocks Declare names of transition shocks !measurement-variables Declare names fo measurement variables !measurement-shocks Declare names of measurement shocks !parameters Declare names of parameters !exogenous-variables Declare names exogenous variables Writing model equations See Write model equations for details on declaring model equations. See Guideline for writing and structuring model source files for writing model source files. Keyword Description !transition-equations !measurement-equations !dtrends !links !preprocessor !postprocessor Controlling log status of variables Keyword Description !log-variables !all-but Defining autoswap pairs !autoswaps-simulate | !autoswaps-steady | Other keywords and syntax Keyword Description min !! || {...} & !ttrend Pseudofunctions Pseudofunctions do not start with an exclamation point Keyword Description diff roc pct difflog movavg movgeom movprod movsum Preparsing keywords Keyword Description % %{...%} <...> !export !for !function !if !import !substitutions !switch Matlab and user-defined functions in model files You can use any of the built-in functions (Matlab functions, functions within the Toolboxes you have on your computer, or your own m-file functions). The only requirement is that the function needs to be visible to Matlab, i.e. located either in the current working directory or in a folder on the Matlab search path. In addition, when using your own m-file functions, you can also (optionally) supply the first derivatives that will be used to compute Taylor expansions when the model is being solved, and the second derivatives that will be used when the function occurs in a loss function. When asked for the derivatives, the function is called with two extra input arguments on top of that function's regular input arguments. The first extra input argument is a text string \"diff\" (indicating the call to the function is supposed to return a derivative). The second extra input argument is a number or a vector of two numbers; it determines with respect to which input argument or arguments the first derivative or the second derivative is requested. For instance, your function takes three input arguments, myfunc(x, y, z) . To be able to supply derivates avoiding thus numerical differentiation, the function must be written so that the following three calls myfunc(x, y, z, \"diff\", 1) myfunc(x, y, z, \"diff\", 2) myfunc(x, y, z, \"diff\", 3) return the first derivative wrt to the first, second, and third input argument, respectively, while myfunc(x, y, z, \"diff\", [1, 2]) returns the second derivative wrt to the first and second input arguments. Note that second derivatives are only needed for functions that occur in an equation defining optimal policy objective, min . If any of these calls fail, the respective derivative will be simply evaluated numerically. Basic rules for writing IrisT model source files There can be four types of equations in IrisT models: transition equations which are simply the endogenous dynamic equations, measurement equations which link the model to observables, deterministic trend equations which can be added at the top of measurement equations, and dynamic links which can be used to link some parameters or steady-state values to each other. There can be two types of variables and two types of shocks in IrisT models: transition variables and shocks, and measurement variables and shocks. Each model must have at least one transition (aka endogenous) variable and one transition equation. Each variable, shock, or parameter must be declared in the appropriate declaration section. The declaration sections and equations sections can be written in any order. You can have as many declaration sections or equations sections of the same kind as you wish in one model file; they all get combined together at the time the model is being loaded. Transition variables can occur with lags and leads in transition equations. Transition variables cannot, though, have leads in measurement equations. Measurement variables and the shocks cannot have any lags or leads. Transition shocks cannot occur in measurement equations, and the measurement shocks cannot occur in transition equations. Exogenous variables can only occur in dtrends (deterministic trend equations), and must be always supplied as part of the input database to commands like Model/simulate , Model/filter , Model/estimate , etc. They are not returned in the output databases. You can choose between linearisation and log-linearisation for each individual transition and measurement variable. Shocks are always linearized. Exogenous variables must be always introduced so that their effect on the respective measurement variable is linear.","title":"Introduction"},{"location":"structural-modeling/slang/index.html#model-file-language","text":"Model file language is a system of keywords that define the structure of model source files. The model source files are plain text files (saved under any file name with any extension) that describe the model: its equations, variables, parameters, etc. The model files do not describe what tasks to do with the model. To run the tasks you want to perform with the model, you need first to load the model file into Matlab using the Model.fromFile function. This function creates a model object. Then you write your own m-files using Matlab and IrisT functions to perform the desired tasks with the model object. When writing model files, you can also use the IrisT preparsing commands that introduce tools for writing reusable and well-structured model code base and minimize repetitive model code writing tasks. You can get the model source files syntax highlighted in the Matlab editor to improve the readability of the files, and helps navigate the model more quickly; see the setup instructions .","title":"Model file language"},{"location":"structural-modeling/slang/index.html#categorical-list-of-keywords","text":"","title":"Categorical list of keywords"},{"location":"structural-modeling/slang/index.html#declaring-model-names-variables-parameters-and-shocks","text":"See Declare model names: Variables, shocks, parameters for details on declaring model names. See Guideline for writing and structuring model source files . Keyword Description !transition-variables Declare names of transition variables !transition-shocks Declare names of transition shocks !measurement-variables Declare names fo measurement variables !measurement-shocks Declare names of measurement shocks !parameters Declare names of parameters !exogenous-variables Declare names exogenous variables","title":"Declaring model names: Variables, parameters and shocks"},{"location":"structural-modeling/slang/index.html#writing-model-equations","text":"See Write model equations for details on declaring model equations. See Guideline for writing and structuring model source files for writing model source files. Keyword Description !transition-equations !measurement-equations !dtrends !links !preprocessor !postprocessor","title":"Writing model equations"},{"location":"structural-modeling/slang/index.html#controlling-log-status-of-variables","text":"Keyword Description !log-variables !all-but","title":"Controlling log status of variables"},{"location":"structural-modeling/slang/index.html#defining-autoswap-pairs","text":"!autoswaps-simulate | !autoswaps-steady |","title":"Defining autoswap pairs"},{"location":"structural-modeling/slang/index.html#other-keywords-and-syntax","text":"Keyword Description min !! || {...} & !ttrend","title":"Other keywords and syntax"},{"location":"structural-modeling/slang/index.html#pseudofunctions","text":"Pseudofunctions do not start with an exclamation point Keyword Description diff roc pct difflog movavg movgeom movprod movsum","title":"Pseudofunctions"},{"location":"structural-modeling/slang/index.html#preparsing-keywords","text":"Keyword Description % %{...%} <...> !export !for !function !if !import !substitutions !switch","title":"Preparsing keywords"},{"location":"structural-modeling/slang/index.html#matlab-and-user-defined-functions-in-model-files","text":"You can use any of the built-in functions (Matlab functions, functions within the Toolboxes you have on your computer, or your own m-file functions). The only requirement is that the function needs to be visible to Matlab, i.e. located either in the current working directory or in a folder on the Matlab search path. In addition, when using your own m-file functions, you can also (optionally) supply the first derivatives that will be used to compute Taylor expansions when the model is being solved, and the second derivatives that will be used when the function occurs in a loss function. When asked for the derivatives, the function is called with two extra input arguments on top of that function's regular input arguments. The first extra input argument is a text string \"diff\" (indicating the call to the function is supposed to return a derivative). The second extra input argument is a number or a vector of two numbers; it determines with respect to which input argument or arguments the first derivative or the second derivative is requested. For instance, your function takes three input arguments, myfunc(x, y, z) . To be able to supply derivates avoiding thus numerical differentiation, the function must be written so that the following three calls myfunc(x, y, z, \"diff\", 1) myfunc(x, y, z, \"diff\", 2) myfunc(x, y, z, \"diff\", 3) return the first derivative wrt to the first, second, and third input argument, respectively, while myfunc(x, y, z, \"diff\", [1, 2]) returns the second derivative wrt to the first and second input arguments. Note that second derivatives are only needed for functions that occur in an equation defining optimal policy objective, min . If any of these calls fail, the respective derivative will be simply evaluated numerically.","title":"Matlab and user-defined functions in model files"},{"location":"structural-modeling/slang/index.html#basic-rules-for-writing-irist-model-source-files","text":"There can be four types of equations in IrisT models: transition equations which are simply the endogenous dynamic equations, measurement equations which link the model to observables, deterministic trend equations which can be added at the top of measurement equations, and dynamic links which can be used to link some parameters or steady-state values to each other. There can be two types of variables and two types of shocks in IrisT models: transition variables and shocks, and measurement variables and shocks. Each model must have at least one transition (aka endogenous) variable and one transition equation. Each variable, shock, or parameter must be declared in the appropriate declaration section. The declaration sections and equations sections can be written in any order. You can have as many declaration sections or equations sections of the same kind as you wish in one model file; they all get combined together at the time the model is being loaded. Transition variables can occur with lags and leads in transition equations. Transition variables cannot, though, have leads in measurement equations. Measurement variables and the shocks cannot have any lags or leads. Transition shocks cannot occur in measurement equations, and the measurement shocks cannot occur in transition equations. Exogenous variables can only occur in dtrends (deterministic trend equations), and must be always supplied as part of the input database to commands like Model/simulate , Model/filter , Model/estimate , etc. They are not returned in the output databases. You can choose between linearisation and log-linearisation for each individual transition and measurement variable. Shocks are always linearized. Exogenous variables must be always introduced so that their effect on the respective measurement variable is linear.","title":"Basic rules for writing IrisT model source files"},{"location":"structural-modeling/slang/%21all-but.html","text":"!all-but Inverse list of log-linearised variables Syntax !log-variables !all-but VariableName, VariableName, VariableName, ... Description See help on !log-variables .","title":"!all-but"},{"location":"structural-modeling/slang/%21all-but.html#all-but","text":"Inverse list of log-linearised variables","title":"!all-but"},{"location":"structural-modeling/slang/%21all-but.html#syntax","text":"!log-variables !all-but VariableName, VariableName, VariableName, ...","title":"Syntax"},{"location":"structural-modeling/slang/%21all-but.html#description","text":"See help on !log-variables .","title":"Description"},{"location":"structural-modeling/slang/%21autoswaps-simulate.html","text":"!autoswaps-simulate Definitions of variable-shock pairs to be autoswapped in dynamic simulations Syntax !autoswaps-simulate variableName := shockName; variableName := shockName; variableName := shockName; Description The section !autoswaps-simulate defines pairs of variables and shocks that can be used to simplify and automate the specification of dynamic simulation Plan objects by calling the function autoswap . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid measurement or transition shock name. Example !transition-variables x, y, z !transition-shocks ex, ey, ez !measurement-variables x_obs, y_obs, z_obs !autoswaps-simulate x := ex; y_obs := ey;","title":"!autoswaps-simulate"},{"location":"structural-modeling/slang/%21autoswaps-simulate.html#autoswaps-simulate","text":"Definitions of variable-shock pairs to be autoswapped in dynamic simulations","title":"!autoswaps-simulate"},{"location":"structural-modeling/slang/%21autoswaps-simulate.html#syntax","text":"!autoswaps-simulate variableName := shockName; variableName := shockName; variableName := shockName;","title":"Syntax"},{"location":"structural-modeling/slang/%21autoswaps-simulate.html#description","text":"The section !autoswaps-simulate defines pairs of variables and shocks that can be used to simplify and automate the specification of dynamic simulation Plan objects by calling the function autoswap . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid measurement or transition shock name.","title":"Description"},{"location":"structural-modeling/slang/%21autoswaps-simulate.html#example","text":"!transition-variables x, y, z !transition-shocks ex, ey, ez !measurement-variables x_obs, y_obs, z_obs !autoswaps-simulate x := ex; y_obs := ey;","title":"Example"},{"location":"structural-modeling/slang/%21autoswaps-steady.html","text":"!autoswaps-steady Definitions of variable-parameter pairs to be autoexogenized in steady-state calculations Syntax !autoswaps-steady variableName := parameterName; variableName := parameterName; variableName := parameterName; Description The section !autoswaps-steady defines pairs of variables and parameters that can be used to simplify and automate the definition of exogenized variables and endogenized parameters in steady-state calculations, i.e. in calling the function Model/steady . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid parameter name. Examples !transition_variables x, y, z !parameters alpha, beta, gamma !measurement_variables x_obs, y_obs, z_obs !dynamic_autoexog x := alpha; y_obs := beta;","title":"!autoswaps-steady"},{"location":"structural-modeling/slang/%21autoswaps-steady.html#autoswaps-steady","text":"Definitions of variable-parameter pairs to be autoexogenized in steady-state calculations","title":"!autoswaps-steady"},{"location":"structural-modeling/slang/%21autoswaps-steady.html#syntax","text":"!autoswaps-steady variableName := parameterName; variableName := parameterName; variableName := parameterName;","title":"Syntax"},{"location":"structural-modeling/slang/%21autoswaps-steady.html#description","text":"The section !autoswaps-steady defines pairs of variables and parameters that can be used to simplify and automate the definition of exogenized variables and endogenized parameters in steady-state calculations, i.e. in calling the function Model/steady . On the left-hand side of the definition must be a valid measurement or transition variable name. On the right-hand side must be a valid parameter name.","title":"Description"},{"location":"structural-modeling/slang/%21autoswaps-steady.html#examples","text":"!transition_variables x, y, z !parameters alpha, beta, gamma !measurement_variables x_obs, y_obs, z_obs !dynamic_autoexog x := alpha; y_obs := beta;","title":"Examples"},{"location":"structural-modeling/slang/%21dtrends.html","text":"!dtrends Block of deterministic trend equations Syntax for linearised measurement variables !dtrends VariableName += Expression; VariableName += Expression; ... Syntax for log-linearised measurement variables !dtrends log(VariableName) += Expression; log(VariableName) += Expression; ... Syntax with equation labels !dtrends 'Equation label' VariableName += Expression; 'Equation label' LOG(VariableName) += Expression; Description Example !dtrends Infl += pi_; Rate += rho_ + pi_;","title":"!dtrends"},{"location":"structural-modeling/slang/%21dtrends.html#dtrends","text":"Block of deterministic trend equations","title":"!dtrends"},{"location":"structural-modeling/slang/%21dtrends.html#syntax-for-linearised-measurement-variables","text":"!dtrends VariableName += Expression; VariableName += Expression; ...","title":"Syntax for linearised measurement variables"},{"location":"structural-modeling/slang/%21dtrends.html#syntax-for-log-linearised-measurement-variables","text":"!dtrends log(VariableName) += Expression; log(VariableName) += Expression; ...","title":"Syntax for log-linearised measurement variables"},{"location":"structural-modeling/slang/%21dtrends.html#syntax-with-equation-labels","text":"!dtrends 'Equation label' VariableName += Expression; 'Equation label' LOG(VariableName) += Expression;","title":"Syntax with equation labels"},{"location":"structural-modeling/slang/%21dtrends.html#description","text":"","title":"Description"},{"location":"structural-modeling/slang/%21dtrends.html#example","text":"!dtrends Infl += pi_; Rate += rho_ + pi_;","title":"Example"},{"location":"structural-modeling/slang/%21exogenous-variables.html","text":"!exogenous-variables Declare names exogenous variables See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!exogenous-variables"},{"location":"structural-modeling/slang/%21exogenous-variables.html#exogenous-variables","text":"Declare names exogenous variables See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!exogenous-variables"},{"location":"structural-modeling/slang/%21export.html","text":"!export Create exportable file to be saved in working directory. Syntax !export(FileName) FileContents !end Description You can include in the model file the contents of files you need or want to carry around together with the model; a typical example is your own m-file functions used in model equations. The file or files are created and saved under the name specified in the !export keyword at the time you load the model using the function model . The contents of the export files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export . If no filename is provided or FileName is empty, an error is thrown.","title":"!export"},{"location":"structural-modeling/slang/%21export.html#export","text":"Create exportable file to be saved in working directory.","title":"!export"},{"location":"structural-modeling/slang/%21export.html#syntax","text":"!export(FileName) FileContents !end","title":"Syntax"},{"location":"structural-modeling/slang/%21export.html#description","text":"You can include in the model file the contents of files you need or want to carry around together with the model; a typical example is your own m-file functions used in model equations. The file or files are created and saved under the name specified in the !export keyword at the time you load the model using the function model . The contents of the export files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export . If no filename is provided or FileName is empty, an error is thrown.","title":"Description"},{"location":"structural-modeling/slang/%21for.html","text":"!for...!do...!end For loop for automated creation of model code. Abbreviated syntax (cannot be nested) !for ListOfTokens !do Template !end Full syntax !for ?ControlName = ListOfTokens !do Template !end Description Use the '!for...!do...!end' command to specify a template and let the IRIS preparser automatically create multiple instances of the template by iterating over a list of tokens. The preparser cycles over the individual strings from the list; in each iteration, the current string is used to replace all occurences of the control variable in the template. The name of the control name is either implicitly a question mark, '?', in the abbreviated syntax, or any string starting with a question mark and not containing blank spaces, question marks (other than the leading question mark), colons or periods; for example, '?x', '?#', '?NAME+'. The tokens (text strings) in the list must be separated by commas, blank spaces, or line breaks and they themselves must not contain any of those. In each iteration, all occurrences of the control variable in the template are replaced with the currently processed string; all occurrences in the template of ?.ControlName are replaced with the currently processed string converted to lower case; this option is NOT available with the abbreviated syntax; all occurrences in the template of ?:ControlName are replaced with the currently processed string converted to upper case; this option is NOT available with the abbreviated syntax; The list of tokens can be based on Matlab expressions, including the interpolation syntax: Enclose an expression in a pair of angle braces, <...> . The expression must evaluate to either a numeric vector, a char vector, or a cell array of numerics and/or strings; the value will be then converted to a comma-separted list. Example In a model code file, instead of writing a number of definitions of growth rates like the following ones dP = P/P{-1} - 1; dW = W/W{-1} - 1; dX = X/X{-1} - 1; dY = Y/Y{-1} - 1; you can use '!for...!do...!end' as follows: !for P, W, X, Y !do d? = ?/?{-1} - 1; !end Example We redo the example 1, but using now the fact that you can have as many variable declaration sections or equation sections as you wish. The '!for...!do...!end' structure can therefore not only produce the equations for you, but also make sure all the growth rate variables are properly declared. !for P, W, X, Y !do !transition_variables d? !transition_equations d? = ?/?{-1} - 1; !end The preparser expands this structure as follows: !transition_variables dP !transition_equations dP = P/P{-1} - 1; !transition_variables dW !transition_equations dW = W/W{-1} - 1; !transition_variables dX !transition_equations dX = X/X{-1} - 1; !transition_variables dY !transition_equations dY = Y/Y{-1} - 1; Obviously, you now do not include the growth rate variables in the section where you declare the rest of the variables. Example In a model code file, instead of writing a number of autoregression processes like the following ones X = rhox*X{-1} + ex; Y = rhoy*Y{-1} + ey; Z = rhoz*Z{-1} + ez; you can use '!for...!do...!end' as follows: !for ?# = X, Y, Z !do ?# = rho?.#*?{-1} + e?.#; !end Example We redo Example 3, but now for six variables named 'A1', 'A2', 'B1', 'B2', 'C1', 'C2', nesting two '!for...!do...!end' structures one within the other: !for ?letter = A, B, C !do !for ?number = 1, 2 !do ?letter?number = rho?.letter?number*?letter?number{-1} + e?.letter?number; !end !end The preparser produces the following six equations: A1 = rhoa1*A1{-1} + ea1; A2 = rhoa2*A2{-1} + ea2; B1 = rhob1*B1{-1} + eb1; B2 = rhob2*B2{-1} + eb2; C1 = rhoc1*C1{-1} + ec1; C2 = rhoc2*C2{-1} + ec2; Example We use a Matlab expression (the colon operator) to simplify the list of tokens. The following block of code !for 1, 2, 3, 4, 5, 6, 7 !do a? = a?{-1} + res_a?; !end can be simplified as follow: !for $[ 1 : 7 ]$ !do a? = a?{-1} + res_a?; !end","title":"!for"},{"location":"structural-modeling/slang/%21for.html#fordoend","text":"For loop for automated creation of model code.","title":"!for...!do...!end"},{"location":"structural-modeling/slang/%21for.html#abbreviated-syntax-cannot-be-nested","text":"!for ListOfTokens !do Template !end","title":"Abbreviated syntax (cannot be nested)"},{"location":"structural-modeling/slang/%21for.html#full-syntax","text":"!for ?ControlName = ListOfTokens !do Template !end","title":"Full syntax"},{"location":"structural-modeling/slang/%21for.html#description","text":"Use the '!for...!do...!end' command to specify a template and let the IRIS preparser automatically create multiple instances of the template by iterating over a list of tokens. The preparser cycles over the individual strings from the list; in each iteration, the current string is used to replace all occurences of the control variable in the template. The name of the control name is either implicitly a question mark, '?', in the abbreviated syntax, or any string starting with a question mark and not containing blank spaces, question marks (other than the leading question mark), colons or periods; for example, '?x', '?#', '?NAME+'. The tokens (text strings) in the list must be separated by commas, blank spaces, or line breaks and they themselves must not contain any of those. In each iteration, all occurrences of the control variable in the template are replaced with the currently processed string; all occurrences in the template of ?.ControlName are replaced with the currently processed string converted to lower case; this option is NOT available with the abbreviated syntax; all occurrences in the template of ?:ControlName are replaced with the currently processed string converted to upper case; this option is NOT available with the abbreviated syntax; The list of tokens can be based on Matlab expressions, including the interpolation syntax: Enclose an expression in a pair of angle braces, <...> . The expression must evaluate to either a numeric vector, a char vector, or a cell array of numerics and/or strings; the value will be then converted to a comma-separted list.","title":"Description"},{"location":"structural-modeling/slang/%21for.html#example","text":"In a model code file, instead of writing a number of definitions of growth rates like the following ones dP = P/P{-1} - 1; dW = W/W{-1} - 1; dX = X/X{-1} - 1; dY = Y/Y{-1} - 1; you can use '!for...!do...!end' as follows: !for P, W, X, Y !do d? = ?/?{-1} - 1; !end","title":"Example"},{"location":"structural-modeling/slang/%21for.html#example_1","text":"We redo the example 1, but using now the fact that you can have as many variable declaration sections or equation sections as you wish. The '!for...!do...!end' structure can therefore not only produce the equations for you, but also make sure all the growth rate variables are properly declared. !for P, W, X, Y !do !transition_variables d? !transition_equations d? = ?/?{-1} - 1; !end The preparser expands this structure as follows: !transition_variables dP !transition_equations dP = P/P{-1} - 1; !transition_variables dW !transition_equations dW = W/W{-1} - 1; !transition_variables dX !transition_equations dX = X/X{-1} - 1; !transition_variables dY !transition_equations dY = Y/Y{-1} - 1; Obviously, you now do not include the growth rate variables in the section where you declare the rest of the variables.","title":"Example"},{"location":"structural-modeling/slang/%21for.html#example_2","text":"In a model code file, instead of writing a number of autoregression processes like the following ones X = rhox*X{-1} + ex; Y = rhoy*Y{-1} + ey; Z = rhoz*Z{-1} + ez; you can use '!for...!do...!end' as follows: !for ?# = X, Y, Z !do ?# = rho?.#*?{-1} + e?.#; !end","title":"Example"},{"location":"structural-modeling/slang/%21for.html#example_3","text":"We redo Example 3, but now for six variables named 'A1', 'A2', 'B1', 'B2', 'C1', 'C2', nesting two '!for...!do...!end' structures one within the other: !for ?letter = A, B, C !do !for ?number = 1, 2 !do ?letter?number = rho?.letter?number*?letter?number{-1} + e?.letter?number; !end !end The preparser produces the following six equations: A1 = rhoa1*A1{-1} + ea1; A2 = rhoa2*A2{-1} + ea2; B1 = rhob1*B1{-1} + eb1; B2 = rhob2*B2{-1} + eb2; C1 = rhoc1*C1{-1} + ec1; C2 = rhoc2*C2{-1} + ec2;","title":"Example"},{"location":"structural-modeling/slang/%21for.html#example_4","text":"We use a Matlab expression (the colon operator) to simplify the list of tokens. The following block of code !for 1, 2, 3, 4, 5, 6, 7 !do a? = a?{-1} + res_a?; !end can be simplified as follow: !for $[ 1 : 7 ]$ !do a? = a?{-1} + res_a?; !end","title":"Example"},{"location":"structural-modeling/slang/%21function.html","text":"!function Create exportable m-file function to be saved in working directory Syntax !function [...] = functionName(...) ... !end Description You can include in the model file the contents of m-file functions you need or want to carry around together with the model; a typical example is your own functions used in model equations. The !function ... !end command is a shortcut to the following !export ... !end structure: !export(functionName.m) function [...] = functionName(...) ... end !end The m-file function are created and saved under the name specified in the function definition at the time you load the model using the function model . The contents of the files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export .","title":"!function"},{"location":"structural-modeling/slang/%21function.html#function","text":"Create exportable m-file function to be saved in working directory Syntax !function [...] = functionName(...) ... !end Description You can include in the model file the contents of m-file functions you need or want to carry around together with the model; a typical example is your own functions used in model equations. The !function ... !end command is a shortcut to the following !export ... !end structure: !export(functionName.m) function [...] = functionName(...) ... end !end The m-file function are created and saved under the name specified in the function definition at the time you load the model using the function model . The contents of the files is are also stored within the model objects. You can manually re-create and re-save all exportable files by running the function export .","title":"!function"},{"location":"structural-modeling/slang/%21if.html","text":"!if...!elseif...!else...!end Choose block of code based on logical condition. Syntax with else and elseif clauses !if Condition1 Block1 !elseif Condition2 Block2 !elseif Condition3 ... !else Block3 !end Syntax with an else clause only !if Condition1 Block1 !else Block2 !end Syntax without an else clause !if Condition Block1 !end Description The !if...!elseif...!else...!end command works the same way as its counterpart in the Matlab programming language. Use the !if...!else...!end command to create branches or versions of the model code. Whether a block of code in a particular branch is used or discarded, depends on the condition after the opening !if command and the conditions after subsequent !elseif commands if present. The condition must be a Matlab expression that evaluates to true or false. The condition can refer to model parameters, or to other fields included in the database passed in through the option ' assign= ' in the model function. Example !if B < Inf % This is a linearised sticky-price Phillips curve. pi = A*pi{-1} + (1-A)*pi{1} + B*log(mu*rmc); !else % This is a flexible-price mark-up rule. rmc = 1/mu; !end If you set the parameter B to Inf in the parameter database when reading in the model file, then the flexible-price equatio, rmc = 0 , is used and the Phillips curve equation discarded. To use the Phillips curve equation instead, you need to re-read the model file with B set to a number other than Inf. In this example, B needs to be, obviously, declared as a model parameter. Example !if exogenous == true x = y; !else x = rho*x{-1} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named exogenous in it, and use the 'assign=' option to pass the database in. Note that you do not need to declare exogenous as a parameter in the model file. P = struct( ); P.exogenous = true; ... m = model('my.model','assign=',P); In this case, the model will contain the first equation, x = rho*x{-1} + epsilon; will be used, and the other discarded. To use the other equation, x = y , you need to re-read the model file with exogenous set to false: P = struct( ); P.exogenous = false; ... m = model('my.model','assign=',P); You can also use an abbreviate syntax to assign control parameters when readin the model file; for instance m = model('my.model','exogenous=',true);","title":"!if"},{"location":"structural-modeling/slang/%21if.html#ifelseifelseend","text":"Choose block of code based on logical condition.","title":"!if...!elseif...!else...!end"},{"location":"structural-modeling/slang/%21if.html#syntax-with-else-and-elseif-clauses","text":"!if Condition1 Block1 !elseif Condition2 Block2 !elseif Condition3 ... !else Block3 !end","title":"Syntax with else and elseif clauses"},{"location":"structural-modeling/slang/%21if.html#syntax-with-an-else-clause-only","text":"!if Condition1 Block1 !else Block2 !end","title":"Syntax with an else clause only"},{"location":"structural-modeling/slang/%21if.html#syntax-without-an-else-clause","text":"!if Condition Block1 !end","title":"Syntax without an else clause"},{"location":"structural-modeling/slang/%21if.html#description","text":"The !if...!elseif...!else...!end command works the same way as its counterpart in the Matlab programming language. Use the !if...!else...!end command to create branches or versions of the model code. Whether a block of code in a particular branch is used or discarded, depends on the condition after the opening !if command and the conditions after subsequent !elseif commands if present. The condition must be a Matlab expression that evaluates to true or false. The condition can refer to model parameters, or to other fields included in the database passed in through the option ' assign= ' in the model function.","title":"Description"},{"location":"structural-modeling/slang/%21if.html#example","text":"!if B < Inf % This is a linearised sticky-price Phillips curve. pi = A*pi{-1} + (1-A)*pi{1} + B*log(mu*rmc); !else % This is a flexible-price mark-up rule. rmc = 1/mu; !end If you set the parameter B to Inf in the parameter database when reading in the model file, then the flexible-price equatio, rmc = 0 , is used and the Phillips curve equation discarded. To use the Phillips curve equation instead, you need to re-read the model file with B set to a number other than Inf. In this example, B needs to be, obviously, declared as a model parameter.","title":"Example"},{"location":"structural-modeling/slang/%21if.html#example_1","text":"!if exogenous == true x = y; !else x = rho*x{-1} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named exogenous in it, and use the 'assign=' option to pass the database in. Note that you do not need to declare exogenous as a parameter in the model file. P = struct( ); P.exogenous = true; ... m = model('my.model','assign=',P); In this case, the model will contain the first equation, x = rho*x{-1} + epsilon; will be used, and the other discarded. To use the other equation, x = y , you need to re-read the model file with exogenous set to false: P = struct( ); P.exogenous = false; ... m = model('my.model','assign=',P); You can also use an abbreviate syntax to assign control parameters when readin the model file; for instance m = model('my.model','exogenous=',true);","title":"Example"},{"location":"structural-modeling/slang/%21import.html","text":"!import Include the content of another model file. Syntax !import(FileName) Description The !import command loads the content of the specified file FileName . This allows you to split the model code into several parts (each saved in a separate file) and to reuse some bits of the model. Example !import(mesurement_equations.model)","title":"!import"},{"location":"structural-modeling/slang/%21import.html#import","text":"Include the content of another model file.","title":"!import"},{"location":"structural-modeling/slang/%21import.html#syntax","text":"!import(FileName)","title":"Syntax"},{"location":"structural-modeling/slang/%21import.html#description","text":"The !import command loads the content of the specified file FileName . This allows you to split the model code into several parts (each saved in a separate file) and to reuse some bits of the model.","title":"Description"},{"location":"structural-modeling/slang/%21import.html#example","text":"!import(mesurement_equations.model)","title":"Example"},{"location":"structural-modeling/slang/%21links.html","text":"!links Define dynamic links Syntax !links ParameterName := Expression; VariableName := Expression; Syntax with equation labels !links 'Equation label' ParameterName := Expression; 'Equation label' VariableName := Expression; Description The dynamic links relate a particular parameter (or steady-state value) on the LHS to a function of other parameters or steady-state values on the RHS. Expression can be any expression involving parameter names, variables names, Matlab functions and constants, or your own m-file functions on the path; it must not refer to any lags or leads. Expression must evaluate to a single number. It is the user's responsibility to properly handle the imaginary (i.e. growth) part of the steady-state values. The links are automatically refreshed in solve , sstate , and chksstate functions, and also in each iteration within the estimate function. They can also be refreshed manually by calling refresh . The links must not involve parameters occuring in !dtrends equations that will be estimated using the 'outoflik=' option of the estimate function. Example !links R := 1/beta; alphak := 1 - alphan - alpham;","title":"!links"},{"location":"structural-modeling/slang/%21links.html#links","text":"Define dynamic links","title":"!links"},{"location":"structural-modeling/slang/%21links.html#syntax","text":"!links ParameterName := Expression; VariableName := Expression;","title":"Syntax"},{"location":"structural-modeling/slang/%21links.html#syntax-with-equation-labels","text":"!links 'Equation label' ParameterName := Expression; 'Equation label' VariableName := Expression;","title":"Syntax with equation labels"},{"location":"structural-modeling/slang/%21links.html#description","text":"The dynamic links relate a particular parameter (or steady-state value) on the LHS to a function of other parameters or steady-state values on the RHS. Expression can be any expression involving parameter names, variables names, Matlab functions and constants, or your own m-file functions on the path; it must not refer to any lags or leads. Expression must evaluate to a single number. It is the user's responsibility to properly handle the imaginary (i.e. growth) part of the steady-state values. The links are automatically refreshed in solve , sstate , and chksstate functions, and also in each iteration within the estimate function. They can also be refreshed manually by calling refresh . The links must not involve parameters occuring in !dtrends equations that will be estimated using the 'outoflik=' option of the estimate function.","title":"Description"},{"location":"structural-modeling/slang/%21links.html#example","text":"!links R := 1/beta; alphak := 1 - alphan - alpham;","title":"Example"},{"location":"structural-modeling/slang/%21log-variables.html","text":"!log-variables List of log-linearised variables Syntax !log-variables VariableName, VariableName, VariableName, ... Syntax with inverted list !log-variables !all-but VariableName, VariableName, VariableName, ... Syntax with regular expression(s) !log-variables VariableName, VariableName, VariableName, ... Description List all log variables under this headings. Only measurement or transition variables can be declared as log variables. In non-linear models, all variables are linearised around the steady state or a balanced-growth path. If you wish to log-linearise some of them instead, put them on a !log-variables list. You can also use the !all-but keyword to indicate an inverse list: all variables will be log-linearised except those listed. Example The following block of code will cause the variables Y , C , I , and K to be declared as log variables, and hence log-linearised in the model solution, while r and pie will be linearised: !transition-variables Y, C, I, K, r, pie !log-variables Y, C, I, K You can do the same job by writing !transition-variables Y, C, I, K, r, pie !log-variables !all-but r, pie","title":"!log-variables"},{"location":"structural-modeling/slang/%21log-variables.html#log-variables","text":"List of log-linearised variables","title":"!log-variables"},{"location":"structural-modeling/slang/%21log-variables.html#syntax","text":"!log-variables VariableName, VariableName, VariableName, ...","title":"Syntax"},{"location":"structural-modeling/slang/%21log-variables.html#syntax-with-inverted-list","text":"!log-variables !all-but VariableName, VariableName, VariableName, ...","title":"Syntax with inverted list"},{"location":"structural-modeling/slang/%21log-variables.html#syntax-with-regular-expressions","text":"!log-variables VariableName, VariableName, VariableName, ...","title":"Syntax with regular expression(s)"},{"location":"structural-modeling/slang/%21log-variables.html#description","text":"List all log variables under this headings. Only measurement or transition variables can be declared as log variables. In non-linear models, all variables are linearised around the steady state or a balanced-growth path. If you wish to log-linearise some of them instead, put them on a !log-variables list. You can also use the !all-but keyword to indicate an inverse list: all variables will be log-linearised except those listed.","title":"Description"},{"location":"structural-modeling/slang/%21log-variables.html#example","text":"The following block of code will cause the variables Y , C , I , and K to be declared as log variables, and hence log-linearised in the model solution, while r and pie will be linearised: !transition-variables Y, C, I, K, r, pie !log-variables Y, C, I, K You can do the same job by writing !transition-variables Y, C, I, K, r, pie !log-variables !all-but r, pie","title":"Example"},{"location":"structural-modeling/slang/%21measurement-equations.html","text":"!measurement-equations Block of measurement equations Syntax !measurement-equations Equation1; Equation2; Equation3; ... Syntax with equation labels !measurement-equations Equation1; 'Equation label' Equation2; Equation3; ... Description The !measurement-equations keyword starts a new block of measurement equations; the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object. Example !measurement-equations 'Inflation observations' Infl = 40*(P/P{-1} - 1);","title":"!measurement-equations"},{"location":"structural-modeling/slang/%21measurement-equations.html#measurement-equations","text":"Block of measurement equations","title":"!measurement-equations"},{"location":"structural-modeling/slang/%21measurement-equations.html#syntax","text":"!measurement-equations Equation1; Equation2; Equation3; ...","title":"Syntax"},{"location":"structural-modeling/slang/%21measurement-equations.html#syntax-with-equation-labels","text":"!measurement-equations Equation1; 'Equation label' Equation2; Equation3; ...","title":"Syntax with equation labels"},{"location":"structural-modeling/slang/%21measurement-equations.html#description","text":"The !measurement-equations keyword starts a new block of measurement equations; the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object.","title":"Description"},{"location":"structural-modeling/slang/%21measurement-equations.html#example","text":"!measurement-equations 'Inflation observations' Infl = 40*(P/P{-1} - 1);","title":"Example"},{"location":"structural-modeling/slang/%21measurement-shocks.html","text":"!measurement-shocks Declare names of measurement shocks See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!measurement-shocks"},{"location":"structural-modeling/slang/%21measurement-shocks.html#measurement-shocks","text":"Declare names of measurement shocks See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!measurement-shocks"},{"location":"structural-modeling/slang/%21measurement-variables.html","text":"!measurement-variables Declare names fo measurement variables See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!measurement-variables"},{"location":"structural-modeling/slang/%21measurement-variables.html#measurement-variables","text":"Declare names fo measurement variables See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!measurement-variables"},{"location":"structural-modeling/slang/%21parameters.html","text":"!parameters Declare names of parameters See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!parameters"},{"location":"structural-modeling/slang/%21parameters.html#parameters","text":"Declare names of parameters See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!parameters"},{"location":"structural-modeling/slang/%21postprocessor.html","text":"!postprocessor Postprocessing equations","title":"!postprocessor"},{"location":"structural-modeling/slang/%21postprocessor.html#postprocessor","text":"Postprocessing equations","title":"!postprocessor"},{"location":"structural-modeling/slang/%21preprocessor.html","text":"!preprocessor Preprocessing equations","title":"!preprocessor"},{"location":"structural-modeling/slang/%21preprocessor.html#preprocessor","text":"Preprocessing equations","title":"!preprocessor"},{"location":"structural-modeling/slang/%21substitutions.html","text":"!substitutions Define text substitutions Syntax !substitutions SubsName := TextString; SubsName := TextString; ... Description The !substitutions starts a block with substitution definitions. The definition of each substitution must begin with the name of the substitution, followed by a colon-equal sign, := , and a text string ended with a semi-colon. The semi-colon is not part of the substitution. The substitutions can be used in any of the model equations, i.e. in transition equations , measurement equations , deterministic trend equations , and dynamic links . Each occurence of the name of a substitution enclosed in dollar signs, i.e. $substitution_name$ , in model equations will be replaced with the text string from the substitution's definition. Substitutions can also refer to other substitutions; make sure, though, that they are not recursive. Also, remember to parenthesise the definitions of the substitutions (or the references to them) in the equations properly so that the resulting mathematical expressions are evaluated properly. Example !substitution a := ((omega1+omega2)/(omega1+omega2+omega3)); !transition-equations X = $a$^2*Y + (1-$a$^2)*Z; In this example, we assume that omega1 , omega2 , and omega3 are declared as parameters. The equation will expand to X = ((omega1+omega2)/(omega1+omega2+omega3))^2*Y + ... (1-((omega1+omega2)/(omega1+omega2+omega3))^2)*Z; Note that if had not used the outermost parentheses in the definition of the substitution, the resulting expression would not have given us what we meant: The square operator would have only applied to the denominator.","title":"!substitutions"},{"location":"structural-modeling/slang/%21substitutions.html#substitutions","text":"Define text substitutions","title":"!substitutions"},{"location":"structural-modeling/slang/%21substitutions.html#syntax","text":"!substitutions SubsName := TextString; SubsName := TextString; ...","title":"Syntax"},{"location":"structural-modeling/slang/%21substitutions.html#description","text":"The !substitutions starts a block with substitution definitions. The definition of each substitution must begin with the name of the substitution, followed by a colon-equal sign, := , and a text string ended with a semi-colon. The semi-colon is not part of the substitution. The substitutions can be used in any of the model equations, i.e. in transition equations , measurement equations , deterministic trend equations , and dynamic links . Each occurence of the name of a substitution enclosed in dollar signs, i.e. $substitution_name$ , in model equations will be replaced with the text string from the substitution's definition. Substitutions can also refer to other substitutions; make sure, though, that they are not recursive. Also, remember to parenthesise the definitions of the substitutions (or the references to them) in the equations properly so that the resulting mathematical expressions are evaluated properly.","title":"Description"},{"location":"structural-modeling/slang/%21substitutions.html#example","text":"!substitution a := ((omega1+omega2)/(omega1+omega2+omega3)); !transition-equations X = $a$^2*Y + (1-$a$^2)*Z; In this example, we assume that omega1 , omega2 , and omega3 are declared as parameters. The equation will expand to X = ((omega1+omega2)/(omega1+omega2+omega3))^2*Y + ... (1-((omega1+omega2)/(omega1+omega2+omega3))^2)*Z; Note that if had not used the outermost parentheses in the definition of the substitution, the resulting expression would not have given us what we meant: The square operator would have only applied to the denominator.","title":"Example"},{"location":"structural-modeling/slang/%21switch.html","text":"!switch...!case...!otherwise...!end Switch among several cases based on expression. Syntax with an otherwise clause !switch Expr !case Balue1 Block1 !case Balue2 Block2 ... !otherwise OtherwiseBlock !end Syntax without an otherwise clause !switch Expr !case Value1 Block1 !case Value2 Block2 ... !end Description The !switch...!case...!otherwise...!end command works the same way as its counterpart in the Matlab programming language. Use the !switch...!case...!end command to create a larger number of branches of the model code. Which block of code is actually read in and which blocks are discarded depends on which value in the !case clauses matches the value of the !switch expression. This works exactly as the switch...case...end command in Matlab. The expression after the !switch part of the command must must be a valid Matlab expression, and can refer to the model parameters, or to other fields included in the parameter database passed in when you run the model function; see the option 'assign=' . If the expression fails to be matched by any value in the !case clauses, the branch in the !otherwise clause is used. If it is a !switch command without the !otherwise clause, the whole command is discarded. The Matlab function isequal is used to match the !switch expression with the !case values. Example !switch policy_regime !case 'IT' r = rho*r{-1} + (1-rho)*kappa*pie{4} + epsilon; !case 'Managed_exchange_rate' s = s{-1} + epsilon; !case 'Constant_money_growth' m-m{-1} = m{-1}-m{-2} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named policy_regime in it, and use the option 'assign=' to pass the database in. Note that you do not need to declare policy_regime as a parameter in the model file. P = struct( ); P.policy_regime = 'Managed_exchange_rate'; ... m = model('my.model','assign',P); In this case, the managed exchange rate policy rule, s = s{-1} + epsilon; is read in and the rest of the !switch command is discarded. To use another branch of the !switch command you need to re-read the model file again with a different value assigned to the policy_regime field of the input database.","title":"!switch"},{"location":"structural-modeling/slang/%21switch.html#switchcaseotherwiseend","text":"Switch among several cases based on expression.","title":"!switch...!case...!otherwise...!end"},{"location":"structural-modeling/slang/%21switch.html#syntax-with-an-otherwise-clause","text":"!switch Expr !case Balue1 Block1 !case Balue2 Block2 ... !otherwise OtherwiseBlock !end","title":"Syntax with an otherwise clause"},{"location":"structural-modeling/slang/%21switch.html#syntax-without-an-otherwise-clause","text":"!switch Expr !case Value1 Block1 !case Value2 Block2 ... !end","title":"Syntax without an otherwise clause"},{"location":"structural-modeling/slang/%21switch.html#description","text":"The !switch...!case...!otherwise...!end command works the same way as its counterpart in the Matlab programming language. Use the !switch...!case...!end command to create a larger number of branches of the model code. Which block of code is actually read in and which blocks are discarded depends on which value in the !case clauses matches the value of the !switch expression. This works exactly as the switch...case...end command in Matlab. The expression after the !switch part of the command must must be a valid Matlab expression, and can refer to the model parameters, or to other fields included in the parameter database passed in when you run the model function; see the option 'assign=' . If the expression fails to be matched by any value in the !case clauses, the branch in the !otherwise clause is used. If it is a !switch command without the !otherwise clause, the whole command is discarded. The Matlab function isequal is used to match the !switch expression with the !case values.","title":"Description"},{"location":"structural-modeling/slang/%21switch.html#example","text":"!switch policy_regime !case 'IT' r = rho*r{-1} + (1-rho)*kappa*pie{4} + epsilon; !case 'Managed_exchange_rate' s = s{-1} + epsilon; !case 'Constant_money_growth' m-m{-1} = m{-1}-m{-2} + epsilon; !end When reading the model file in, create a parameter database, include at least a field named policy_regime in it, and use the option 'assign=' to pass the database in. Note that you do not need to declare policy_regime as a parameter in the model file. P = struct( ); P.policy_regime = 'Managed_exchange_rate'; ... m = model('my.model','assign',P); In this case, the managed exchange rate policy rule, s = s{-1} + epsilon; is read in and the rest of the !switch command is discarded. To use another branch of the !switch command you need to re-read the model file again with a different value assigned to the policy_regime field of the input database.","title":"Example"},{"location":"structural-modeling/slang/%21transition-equations.html","text":"!transition-equations Block of transition equations Syntax !transition-equations Equation1; Equation2; Equation2; ... Abbreviated syntax !equations Equation1; Equation2; Equation3; ... Syntax with equation labels !transition-equations Equation1; 'Equation label' Equation2; Equation3; ... Description The !transition-equations keyword starts a new block of transition equations (i.e. endogenous equations); the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object. Example !transition-equations 'Euler equation' C{1}/C = R*beta;","title":"!transition-equations"},{"location":"structural-modeling/slang/%21transition-equations.html#transition-equations","text":"Block of transition equations","title":"!transition-equations"},{"location":"structural-modeling/slang/%21transition-equations.html#syntax","text":"!transition-equations Equation1; Equation2; Equation2; ...","title":"Syntax"},{"location":"structural-modeling/slang/%21transition-equations.html#abbreviated-syntax","text":"!equations Equation1; Equation2; Equation3; ...","title":"Abbreviated syntax"},{"location":"structural-modeling/slang/%21transition-equations.html#syntax-with-equation-labels","text":"!transition-equations Equation1; 'Equation label' Equation2; Equation3; ...","title":"Syntax with equation labels"},{"location":"structural-modeling/slang/%21transition-equations.html#description","text":"The !transition-equations keyword starts a new block of transition equations (i.e. endogenous equations); the equations can stretch over multiple lines and must be separated by semi-colons. You can have as many equation blocks as you wish in any order in your model file: They all get combined together when you read the model file in. You can add descriptive labels to the equations (in single or double quotes, preceding the equation); these will be stored in, and accessible from, the model object.","title":"Description"},{"location":"structural-modeling/slang/%21transition-equations.html#example","text":"!transition-equations 'Euler equation' C{1}/C = R*beta;","title":"Example"},{"location":"structural-modeling/slang/%21transition-shocks.html","text":"!transition-shocks Declare names of transition shocks See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!transition-shocks"},{"location":"structural-modeling/slang/%21transition-shocks.html#transition-shocks","text":"Declare names of transition shocks See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!transition-shocks"},{"location":"structural-modeling/slang/%21transition-variables.html","text":"!transition-variables | !variables Declare names of transition variables See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!transition-variables"},{"location":"structural-modeling/slang/%21transition-variables.html#transition-variables-variables","text":"Declare names of transition variables See Declare model names: Variables, shocks, parameters for details on declaring model names.","title":"!transition-variables | !variables"},{"location":"structural-modeling/slang/%21ttrend.html","text":"!ttrend Linear time trend in deterministic trend equations Syntax !ttrend Description Example !dtrends log(Y) += a*!ttrend;","title":"!ttrend"},{"location":"structural-modeling/slang/%21ttrend.html#ttrend","text":"Linear time trend in deterministic trend equations","title":"!ttrend"},{"location":"structural-modeling/slang/%21ttrend.html#syntax","text":"!ttrend","title":"Syntax"},{"location":"structural-modeling/slang/%21ttrend.html#description","text":"","title":"Description"},{"location":"structural-modeling/slang/%21ttrend.html#example","text":"!dtrends log(Y) += a*!ttrend;","title":"Example"},{"location":"structural-modeling/slang/alias.html","text":"|| Separate alias from the rest of name or equation description Syntax in name descriptions \"Description || Alias\" name Syntax in equation labels \"Description || Alias\" equation; Description When used in descriptions of variables, shocks, and parameters, or in equation labels, the double exclamation mark starts an alias (but the exlamation marks are not included in it). The alias can be used to specify, for example, a LaTeX code associated with the variable, shock, parameter, or equation. The aliases can be retrieved from the model code by using the appropriate query in the function Model/access . Example Based on this snippet of a model source file, !transition-variables \"Output gap || $\\hat y_t$\" y_gap in the resulting model object, the description of the variable y_gap will be \"Output gap\" while its alias will be \" \\(\\hat y_t\\) \".","title":"alias"},{"location":"structural-modeling/slang/alias.html#_1","text":"Separate alias from the rest of name or equation description","title":"||"},{"location":"structural-modeling/slang/alias.html#syntax-in-name-descriptions","text":"\"Description || Alias\" name","title":"Syntax in name descriptions"},{"location":"structural-modeling/slang/alias.html#syntax-in-equation-labels","text":"\"Description || Alias\" equation;","title":"Syntax in equation labels"},{"location":"structural-modeling/slang/alias.html#description","text":"When used in descriptions of variables, shocks, and parameters, or in equation labels, the double exclamation mark starts an alias (but the exlamation marks are not included in it). The alias can be used to specify, for example, a LaTeX code associated with the variable, shock, parameter, or equation. The aliases can be retrieved from the model code by using the appropriate query in the function Model/access .","title":"Description"},{"location":"structural-modeling/slang/alias.html#example","text":"Based on this snippet of a model source file, !transition-variables \"Output gap || $\\hat y_t$\" y_gap in the resulting model object, the description of the variable y_gap will be \"Output gap\" while its alias will be \" \\(\\hat y_t\\) \".","title":"Example"},{"location":"structural-modeling/slang/block-comment.html","text":"%{...%} Block comments Syntax %{ ... ... ... %} Description Anything between the opening block comment sign, %{ , and the closing block comment sign, %} , is discarded. Unlike in Matlab, the opening and closing block comment signs do not need to stand alone on otherwise blank lines. You can even have block comments contained within a single line. Example !transition_equations x = rho*x{-1} %{ this is a valid block comment %} + epsilon;","title":"block-comment"},{"location":"structural-modeling/slang/block-comment.html#_1","text":"Block comments","title":"%{...%}"},{"location":"structural-modeling/slang/block-comment.html#syntax","text":"%{ ... ... ... %}","title":"Syntax"},{"location":"structural-modeling/slang/block-comment.html#description","text":"Anything between the opening block comment sign, %{ , and the closing block comment sign, %} , is discarded. Unlike in Matlab, the opening and closing block comment signs do not need to stand alone on otherwise blank lines. You can even have block comments contained within a single line.","title":"Description"},{"location":"structural-modeling/slang/block-comment.html#example","text":"!transition_equations x = rho*x{-1} %{ this is a valid block comment %} + epsilon;","title":"Example"},{"location":"structural-modeling/slang/diff.html","text":"diff First difference pseudofunction Syntax diff(Expr) diff(Expr,K) Description If the input argument K is not specified, this pseudofunction expands to ((Expr)-(Expr{-1})) If the input argument K is specified, it expands to ((Expr)-(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively. Example These two lines diff(Z) diff(log(X{1})-log(Y{-1}),-2) will expand to ((Z)-(Z{-1})) ((log(X{1})-log(Y{-1}))-(log(X{-1})-log(Y{-3})))","title":"diff"},{"location":"structural-modeling/slang/diff.html#diff","text":"First difference pseudofunction","title":"diff"},{"location":"structural-modeling/slang/diff.html#syntax","text":"diff(Expr) diff(Expr,K)","title":"Syntax"},{"location":"structural-modeling/slang/diff.html#description","text":"If the input argument K is not specified, this pseudofunction expands to ((Expr)-(Expr{-1})) If the input argument K is specified, it expands to ((Expr)-(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively.","title":"Description"},{"location":"structural-modeling/slang/diff.html#example","text":"These two lines diff(Z) diff(log(X{1})-log(Y{-1}),-2) will expand to ((Z)-(Z{-1})) ((log(X{1})-log(Y{-1}))-(log(X{-1})-log(Y{-3})))","title":"Example"},{"location":"structural-modeling/slang/difflog.html","text":"difflog First log-difference pseudofunction Syntax difflog(Expr) difflog(Expr,K) Description If the input argument K is not specified, this pseudofunction expands to (log(Expr)-log(Expr{-1})) If the input argument K is specified, it expands to (log(Expr)-log(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively. Example The following two lines of code difflog(Z) difflog(X{1}/Y{-1},-2) will expand to (log(Z)-log(Z{-1})) (log(X{1}/Y{-1})-log(X{-1}/Y{-3}))","title":"difflog"},{"location":"structural-modeling/slang/difflog.html#difflog","text":"First log-difference pseudofunction","title":"difflog"},{"location":"structural-modeling/slang/difflog.html#syntax","text":"difflog(Expr) difflog(Expr,K)","title":"Syntax"},{"location":"structural-modeling/slang/difflog.html#description","text":"If the input argument K is not specified, this pseudofunction expands to (log(Expr)-log(Expr{-1})) If the input argument K is specified, it expands to (log(Expr)-log(Expr{K})) The two derived expressions, Expr{-1} and Expr{K} , are based on Expr , and have all its time subscripts shifted by --1 or by K periods, respectively.","title":"Description"},{"location":"structural-modeling/slang/difflog.html#example","text":"The following two lines of code difflog(Z) difflog(X{1}/Y{-1},-2) will expand to (log(Z)-log(Z{-1})) (log(X{1}/Y{-1})-log(X{-1}/Y{-3}))","title":"Example"},{"location":"structural-modeling/slang/equations.html","text":"Model equations Write model equations Model source files can contain the following types of model equations Model equation type Keyword Remark Transition equations !transition-equations May be abbreviated to !equations Measurement equations !measurement-equations Deterministic trends !dtrends Dynamic links !links Preprocessing equations !preprocessor Not a structural part of the model Postprocessing equations !postprocessor Not a structural part of the model","title":"equations"},{"location":"structural-modeling/slang/equations.html#model-equations","text":"Write model equations Model source files can contain the following types of model equations Model equation type Keyword Remark Transition equations !transition-equations May be abbreviated to !equations Measurement equations !measurement-equations Deterministic trends !dtrends Dynamic links !links Preprocessing equations !preprocessor Not a structural part of the model Postprocessing equations !postprocessor Not a structural part of the model","title":"Model equations"},{"location":"structural-modeling/slang/guidelines.html","text":"Model source files Guideline for writing and structuring model source files","title":"guidelines"},{"location":"structural-modeling/slang/guidelines.html#model-source-files","text":"Guideline for writing and structuring model source files","title":"Model source files"},{"location":"structural-modeling/slang/interp.html","text":"<...> Interpolation. Syntax <Expr> Description The expression Expr enclosed within a pair of angle braces, <...> , is evaluated as a Matlab expression, and converted to a character string. The expression may refer to parameters passed into the function model , or to !for loop control variable names. The expression must evaluate to a scalar number, a logical scalar, or character string. Example The following line of code pie{<K>} which is assumed to be part of a model file named my.model , will expand to pie{3} in either of the following two calls to the function model : model('my.model','K=',3); P = struct( ); P.K = 3; model('my.model','assign=',P); Example The following !for loop !for < 2 : 4 > !do x? = x<?-1>{-1}; !end will expand to x2 = x1{-1}; x3 = x2{-1}; x4 = x3{-1};","title":"interp"},{"location":"structural-modeling/slang/interp.html#_1","text":"Interpolation.","title":"&lt;...&gt;"},{"location":"structural-modeling/slang/interp.html#syntax","text":"<Expr>","title":"Syntax"},{"location":"structural-modeling/slang/interp.html#description","text":"The expression Expr enclosed within a pair of angle braces, <...> , is evaluated as a Matlab expression, and converted to a character string. The expression may refer to parameters passed into the function model , or to !for loop control variable names. The expression must evaluate to a scalar number, a logical scalar, or character string.","title":"Description"},{"location":"structural-modeling/slang/interp.html#example","text":"The following line of code pie{<K>} which is assumed to be part of a model file named my.model , will expand to pie{3} in either of the following two calls to the function model : model('my.model','K=',3); P = struct( ); P.K = 3; model('my.model','assign=',P);","title":"Example"},{"location":"structural-modeling/slang/interp.html#example_1","text":"The following !for loop !for < 2 : 4 > !do x? = x<?-1>{-1}; !end will expand to x2 = x1{-1}; x3 = x2{-1}; x4 = x3{-1};","title":"Example"},{"location":"structural-modeling/slang/line-comment.html","text":"% Line comments Syntax % Anything from the percent sign until the end of line is discarded. Description Example","title":"line-comment"},{"location":"structural-modeling/slang/line-comment.html#_1","text":"Line comments","title":"%"},{"location":"structural-modeling/slang/line-comment.html#syntax","text":"% Anything from the percent sign until the end of line is discarded.","title":"Syntax"},{"location":"structural-modeling/slang/line-comment.html#description","text":"","title":"Description"},{"location":"structural-modeling/slang/line-comment.html#example","text":"","title":"Example"},{"location":"structural-modeling/slang/min.html","text":"min Define loss function for optimal policy Syntax min(Disc) Expr; Syntax for exact non-linear simulations min#(Disc) Expr; Description The loss function must be types as one of the transition equations. The Disc is a parameter or an expression defining the discount factor (applied to future dates), and the expression Expr defines the loss fuction. The Disc expression must not contain a comma. If you use the min#(Disc) syntax, all equations created by differentiating the lagrangian w.r.t. individual variables will be earmarked for exact nonlinear simulations provided the respective derivative is nonzero. This only makes sense if the loss function is other than quadratic, and hence its derivatives are nonlinear. There are two types of optimal policy that can be calculated: time-consistent discretionary policy, and time-inconsistent optimal policy with commitment. Use the option 'optimal=' in the function model at the time of loading the model file to switch between these two types of policy; the option can be either 'discretion' (default) or 'commitment' . Example This is a simple model file with a Phillips curve and a quadratic loss function. !transition-variables x, pi !transition-shocks u !parameters alpha, beta, gamma !transition-equations min(beta) pi^2 + lambda*x^2; pi = alpha*pi{-1} + (1-alpha)*pi{1} + gamma*y + u;","title":"min"},{"location":"structural-modeling/slang/min.html#min","text":"Define loss function for optimal policy","title":"min"},{"location":"structural-modeling/slang/min.html#syntax","text":"min(Disc) Expr;","title":"Syntax"},{"location":"structural-modeling/slang/min.html#syntax-for-exact-non-linear-simulations","text":"min#(Disc) Expr;","title":"Syntax for exact non-linear simulations"},{"location":"structural-modeling/slang/min.html#description","text":"The loss function must be types as one of the transition equations. The Disc is a parameter or an expression defining the discount factor (applied to future dates), and the expression Expr defines the loss fuction. The Disc expression must not contain a comma. If you use the min#(Disc) syntax, all equations created by differentiating the lagrangian w.r.t. individual variables will be earmarked for exact nonlinear simulations provided the respective derivative is nonzero. This only makes sense if the loss function is other than quadratic, and hence its derivatives are nonlinear. There are two types of optimal policy that can be calculated: time-consistent discretionary policy, and time-inconsistent optimal policy with commitment. Use the option 'optimal=' in the function model at the time of loading the model file to switch between these two types of policy; the option can be either 'discretion' (default) or 'commitment' .","title":"Description"},{"location":"structural-modeling/slang/min.html#example","text":"This is a simple model file with a Phillips curve and a quadratic loss function. !transition-variables x, pi !transition-shocks u !parameters alpha, beta, gamma !transition-equations min(beta) pi^2 + lambda*x^2; pi = alpha*pi{-1} + (1-alpha)*pi{1} + gamma*y + u;","title":"Example"},{"location":"structural-modeling/slang/movavg.html","text":"movavg Moving average pseudofunction Syntax movavg(Expr) movavg(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving average of the last K periods (including the current period), i.e. (((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)})/-K) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving average of the next K periods ahead (including the current period), i.e. (((Expr)+(Expr{1})+ ... +(Expr{K-1})/K) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movavg(Z) movavg(Z,-3) movavg(X+Y{-1},2) will expand to (((Z)+(Z{-1})+(Z{-2})+(Z{-3}))/4) (((Z)+(Z{-1})+(Z{-2}))/3) (((X+Y{-1})+(X{1}+Y))/2)","title":"movavg"},{"location":"structural-modeling/slang/movavg.html#movavg","text":"Moving average pseudofunction","title":"movavg"},{"location":"structural-modeling/slang/movavg.html#syntax","text":"movavg(Expr) movavg(Expr,K)","title":"Syntax"},{"location":"structural-modeling/slang/movavg.html#description","text":"If the second input argument, K , is negative, this function expands to the moving average of the last K periods (including the current period), i.e. (((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)})/-K) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving average of the next K periods ahead (including the current period), i.e. (((Expr)+(Expr{1})+ ... +(Expr{K-1})/K) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"structural-modeling/slang/movavg.html#example","text":"The following three lines movavg(Z) movavg(Z,-3) movavg(X+Y{-1},2) will expand to (((Z)+(Z{-1})+(Z{-2})+(Z{-3}))/4) (((Z)+(Z{-1})+(Z{-2}))/3) (((X+Y{-1})+(X{1}+Y))/2)","title":"Example"},{"location":"structural-modeling/slang/movgeom.html","text":"movavg Moving geometric average pseudofunction Syntax movgeom(Expr) movgeom(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving geometric average of the last K periods (including the current period), i.e. (((Expr)*(Expr{-1})* ... *(Expr{-(K-1)})^(1/-K)) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving geometric average of the next K periods ahead (including the current period), i.e. (((Expr)*(Expr{1})* ... *(Expr{K-1})^(1/K)) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movgeom(Z) movgeom(Z,-3) movgeom(X+Y{-1},2) will expand to (((Z)*(Z{-1})*(Z{-2})*(Z{-3}))^(1/4)) (((Z)*(Z{-1})*(Z{-2}))^(1/3)) (((X+Y{-1})*(X{1}+Y))^(1/2))","title":"movgeom"},{"location":"structural-modeling/slang/movgeom.html#movavg","text":"Moving geometric average pseudofunction","title":"movavg"},{"location":"structural-modeling/slang/movgeom.html#syntax","text":"movgeom(Expr) movgeom(Expr,K)","title":"Syntax"},{"location":"structural-modeling/slang/movgeom.html#description","text":"If the second input argument, K , is negative, this function expands to the moving geometric average of the last K periods (including the current period), i.e. (((Expr)*(Expr{-1})* ... *(Expr{-(K-1)})^(1/-K)) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving geometric average of the next K periods ahead (including the current period), i.e. (((Expr)*(Expr{1})* ... *(Expr{K-1})^(1/K)) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"structural-modeling/slang/movgeom.html#example","text":"The following three lines movgeom(Z) movgeom(Z,-3) movgeom(X+Y{-1},2) will expand to (((Z)*(Z{-1})*(Z{-2})*(Z{-3}))^(1/4)) (((Z)*(Z{-1})*(Z{-2}))^(1/3)) (((X+Y{-1})*(X{1}+Y))^(1/2))","title":"Example"},{"location":"structural-modeling/slang/movprod.html","text":"movsum Moving product pseudofunction Syntax movprod(Expr) movprod(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving product of the last K periods (including the current period), i.e. ((Expr)*(Expr{-1})* ... *(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving product of the next K periods ahead (including the current period), i.e. ((Expr)*(Expr{1})* ... *(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movprod(Z) movprod(Z,-3) movprod(X+Y{-1},2) will expand to ((Z)*(Z{-1})*(Z{-2})*(Z{-3})) ((Z)*(Z{-1})*(Z{-2})) ((X+Y{-1})*(X{1}+Y))","title":"movprod"},{"location":"structural-modeling/slang/movprod.html#movsum","text":"Moving product pseudofunction","title":"movsum"},{"location":"structural-modeling/slang/movprod.html#syntax","text":"movprod(Expr) movprod(Expr,K)","title":"Syntax"},{"location":"structural-modeling/slang/movprod.html#description","text":"If the second input argument, K , is negative, this function expands to the moving product of the last K periods (including the current period), i.e. ((Expr)*(Expr{-1})* ... *(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving product of the next K periods ahead (including the current period), i.e. ((Expr)*(Expr{1})* ... *(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"structural-modeling/slang/movprod.html#example","text":"The following three lines movprod(Z) movprod(Z,-3) movprod(X+Y{-1},2) will expand to ((Z)*(Z{-1})*(Z{-2})*(Z{-3})) ((Z)*(Z{-1})*(Z{-2})) ((X+Y{-1})*(X{1}+Y))","title":"Example"},{"location":"structural-modeling/slang/movsum.html","text":"movsum Moving sum pseudofunction Syntax movsum(Expr) movsum(Expr,K) Description If the second input argument, K , is negative, this function expands to the moving sum of the last K periods (including the current period), i.e. ((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving sum of the next K periods ahead (including the current period), i.e. ((Expr)+(Expr{1})+ ... +(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly). Example The following three lines movsum(Z) movsum(Z,-3) movsum(X+Y{-1},2) will expand to ((Z)+(Z{-1})+(Z{-2})+(Z{-3})) ((Z)+(Z{-1})+(Z{-2})) ((X+Y{-1})+(X{1}+Y))","title":"movsum"},{"location":"structural-modeling/slang/movsum.html#movsum","text":"Moving sum pseudofunction","title":"movsum"},{"location":"structural-modeling/slang/movsum.html#syntax","text":"movsum(Expr) movsum(Expr,K)","title":"Syntax"},{"location":"structural-modeling/slang/movsum.html#description","text":"If the second input argument, K , is negative, this function expands to the moving sum of the last K periods (including the current period), i.e. ((Expr)+(Expr{-1})+ ... +(Expr{-(K-1)}) where Expr{-N} derives from Expr and has all its time subscripts shifted by -N (if specified). If the second input argument, K , is positive, this function expands to the moving sum of the next K periods ahead (including the current period), i.e. ((Expr)+(Expr{1})+ ... +(Expr{K-1}) If the second input argument, K , is not specified, the default value -4 is used (based on the fact that most of the macroeconomic models are quarterly).","title":"Description"},{"location":"structural-modeling/slang/movsum.html#example","text":"The following three lines movsum(Z) movsum(Z,-3) movsum(X+Y{-1},2) will expand to ((Z)+(Z{-1})+(Z{-2})+(Z{-3})) ((Z)+(Z{-1})+(Z{-2})) ((X+Y{-1})+(X{1}+Y))","title":"Example"},{"location":"structural-modeling/slang/names.html","text":"Model names Declare model names: Variables, shocks, parameters Model source files can contain the following types of model names Model name type Keyword Remark Transition variables !transition-variables May be abbreviated to !variables Transition shocks !transition-shocks May be abbreviated to !shocks Measurement variables !measurement-variables Measurement shocks !measurement-shocks Parameters !parameters Exogenous variables !exogenous-variables May only be used in !dtrends equations Syntax List the names under the respective keyword. The names are separated by white spaces, commas or semicolons, and may be given optional annotations. An annotation is enclosed in double quotes and immediately precedes the respective name. !transition-variables variableName, variableName, ... \"Description of the variable\" variableName ... Example: Declare transition variables The following section declares three variables, pie , y , and re !transition-variables pie, \"Real output\" y \"Real exchange rate\" re Example: Split declaration Declaration of a particular type of model names can be split into any number of sections (as long as each model name is declared only once). The following snippet is equivalent to the previous example: !transition-variables pie !transition-variables \"Real output\" y !transition-variables \"Real exchange rate\" re This is useful when you use some of the control structures, such as !if , !switch.md , or !for , or when you split the model source code into multiple source files.","title":"names"},{"location":"structural-modeling/slang/names.html#model-names","text":"Declare model names: Variables, shocks, parameters Model source files can contain the following types of model names Model name type Keyword Remark Transition variables !transition-variables May be abbreviated to !variables Transition shocks !transition-shocks May be abbreviated to !shocks Measurement variables !measurement-variables Measurement shocks !measurement-shocks Parameters !parameters Exogenous variables !exogenous-variables May only be used in !dtrends equations","title":"Model names"},{"location":"structural-modeling/slang/names.html#syntax","text":"List the names under the respective keyword. The names are separated by white spaces, commas or semicolons, and may be given optional annotations. An annotation is enclosed in double quotes and immediately precedes the respective name. !transition-variables variableName, variableName, ... \"Description of the variable\" variableName ...","title":"Syntax"},{"location":"structural-modeling/slang/names.html#example-declare-transition-variables","text":"The following section declares three variables, pie , y , and re !transition-variables pie, \"Real output\" y \"Real exchange rate\" re","title":"Example: Declare transition variables"},{"location":"structural-modeling/slang/names.html#example-split-declaration","text":"Declaration of a particular type of model names can be split into any number of sections (as long as each model name is declared only once). The following snippet is equivalent to the previous example: !transition-variables pie !transition-variables \"Real output\" y !transition-variables \"Real exchange rate\" re This is useful when you use some of the control structures, such as !if , !switch.md , or !for , or when you split the model source code into multiple source files.","title":"Example: Split declaration"},{"location":"structural-modeling/slang/pct.html","text":"pct Percent change Syntax pct(expression) pct(expression, k) Description If the input argument k is not specified, this pseudofunction expands to (100*((expression)/(expression{-1})-1)) If the input argument k is specified, it expands to (100*((expression)/(expression{k})-1)) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively. Examples The following two lines pct(z) pct(x+y, -2) will expand to (100*((z)/(z{-1})-1)) (100*((x+y)/(x{-2}+y{-2})-1))","title":"pct"},{"location":"structural-modeling/slang/pct.html#pct","text":"Percent change","title":"pct"},{"location":"structural-modeling/slang/pct.html#syntax","text":"pct(expression) pct(expression, k)","title":"Syntax"},{"location":"structural-modeling/slang/pct.html#description","text":"If the input argument k is not specified, this pseudofunction expands to (100*((expression)/(expression{-1})-1)) If the input argument k is specified, it expands to (100*((expression)/(expression{k})-1)) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively.","title":"Description"},{"location":"structural-modeling/slang/pct.html#examples","text":"The following two lines pct(z) pct(x+y, -2) will expand to (100*((z)/(z{-1})-1)) (100*((x+y)/(x{-2}+y{-2})-1))","title":"Examples"},{"location":"structural-modeling/slang/roc.html","text":"roc Gross rate of change pseudofunction Syntax roc(expression) roc(expression, k) Description If the input argument k is not specified, this pseudofunction expands to ((expression)/(expression{-1})) If the input argument k is specified, it expands to ((expression)/(expression{k})) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively. Examples The following two lines roc(z) roc(x+y,-2) will expand to ((Z)/(Z{-1})) ((X+Y)/(X{-2}+Y{-2}))","title":"roc"},{"location":"structural-modeling/slang/roc.html#roc","text":"Gross rate of change pseudofunction","title":"roc"},{"location":"structural-modeling/slang/roc.html#syntax","text":"roc(expression) roc(expression, k)","title":"Syntax"},{"location":"structural-modeling/slang/roc.html#description","text":"If the input argument k is not specified, this pseudofunction expands to ((expression)/(expression{-1})) If the input argument k is specified, it expands to ((expression)/(expression{k})) The time-shifted expressions, expression{-1} and expression{k} , are based on expression , and have all its time subscripts shifted by \u20131 or by k periods, respectively.","title":"Description"},{"location":"structural-modeling/slang/roc.html#examples","text":"The following two lines roc(z) roc(x+y,-2) will expand to ((Z)/(Z{-1})) ((X+Y)/(X{-2}+Y{-2}))","title":"Examples"},{"location":"structural-modeling/slang/shift.html","text":"{...} Lag or lead Syntax VariableName{-lag} VariableName{lead} VariableName{+lead} Description To create a lag or a lead of a variable, use a pair of curly brackets. Example !transition-equations x = rho*x{-1} + epsilon_x; pi = 1/2*pie{-1} + 1/2*pie{1} + gamma*y + epsilon_pi;","title":"shift"},{"location":"structural-modeling/slang/shift.html#_1","text":"Lag or lead","title":"{...}"},{"location":"structural-modeling/slang/shift.html#syntax","text":"VariableName{-lag} VariableName{lead} VariableName{+lead}","title":"Syntax"},{"location":"structural-modeling/slang/shift.html#description","text":"To create a lag or a lead of a variable, use a pair of curly brackets.","title":"Description"},{"location":"structural-modeling/slang/shift.html#example","text":"!transition-equations x = rho*x{-1} + epsilon_x; pi = 1/2*pie{-1} + 1/2*pie{1} + gamma*y + epsilon_pi;","title":"Example"},{"location":"structural-modeling/slang/steady-ref.html","text":"& | $ Reference to the steady-state level of a variable Syntax &variableName &variableName{K} Alternative syntax $variableName $variableName{K} Description Use either a & or $ sign in front of a variable name to create a reference to that variable's steady-state level in transition or measurement equations. The two signs, & and $ , are interchangeable. Steady-state references may only be used in nonlinear models. The steady-state reference can include a time shift (a lag or a lead), K . In that case, the steady-state value will be adjusted for steady-state growth backward or forward accordingly. The steady-state reference will be replaced: with the variable itself at the time the model's steady state is being calculated, i.e. when calling the function Model/steady ; with the actually assigned steady-state value at the time the model is being solved, i.e. when calling the function 'Model/solve' '. Examples x = rho*x{-1} + (1-rho)*&x + epsilon_x !! x = 1;","title":"steady-ref"},{"location":"structural-modeling/slang/steady-ref.html#_1","text":"Reference to the steady-state level of a variable","title":"&amp; | $"},{"location":"structural-modeling/slang/steady-ref.html#syntax","text":"&variableName &variableName{K}","title":"Syntax"},{"location":"structural-modeling/slang/steady-ref.html#alternative-syntax","text":"$variableName $variableName{K}","title":"Alternative syntax"},{"location":"structural-modeling/slang/steady-ref.html#description","text":"Use either a & or $ sign in front of a variable name to create a reference to that variable's steady-state level in transition or measurement equations. The two signs, & and $ , are interchangeable. Steady-state references may only be used in nonlinear models. The steady-state reference can include a time shift (a lag or a lead), K . In that case, the steady-state value will be adjusted for steady-state growth backward or forward accordingly. The steady-state reference will be replaced: with the variable itself at the time the model's steady state is being calculated, i.e. when calling the function Model/steady ; with the actually assigned steady-state value at the time the model is being solved, i.e. when calling the function 'Model/solve' '.","title":"Description"},{"location":"structural-modeling/slang/steady-ref.html#examples","text":"x = rho*x{-1} + (1-rho)*&x + epsilon_x !! x = 1;","title":"Examples"},{"location":"structural-modeling/slang/steady-version.html","text":"!! Steady-state versions of equations Syntax dynamicEquation !! steadyEquation; Description For each transition or measurement equation, you can provide a separate steady-state version of it. The steady-state version is used when you run the functions steady and checkSteady , the latter unless you change the option EquationSwitch= . This is useful when you can substantially simplify some parts of the full dynamic equations, split the model into sequential blocks, and help therefore the numerical solver to achieve faster and possibly laso more accurate results. Examples log(a) = 0.8*log(a{-1}) + (1-0.8)*2 + epsilon_a !! log(a) = 2; The following steady state version of an Euler equation will be valid only in stationary models where we can safely remove lags and leads. lambda = lambda{1}*(1+r)*beta !! r = 1/beta - 1;","title":"steady-version"},{"location":"structural-modeling/slang/steady-version.html#_1","text":"Steady-state versions of equations","title":"!!"},{"location":"structural-modeling/slang/steady-version.html#syntax","text":"dynamicEquation !! steadyEquation;","title":"Syntax"},{"location":"structural-modeling/slang/steady-version.html#description","text":"For each transition or measurement equation, you can provide a separate steady-state version of it. The steady-state version is used when you run the functions steady and checkSteady , the latter unless you change the option EquationSwitch= . This is useful when you can substantially simplify some parts of the full dynamic equations, split the model into sequential blocks, and help therefore the numerical solver to achieve faster and possibly laso more accurate results.","title":"Description"},{"location":"structural-modeling/slang/steady-version.html#examples","text":"log(a) = 0.8*log(a{-1}) + (1-0.8)*2 + epsilon_a !! log(a) = 2; The following steady state version of an Euler equation will be valid only in stationary models where we can safely remove lags and leads. lambda = lambda{1}*(1+r)*beta !! r = 1/beta - 1;","title":"Examples"},{"location":"time-series-modeling/index.html","text":"Time Series Modeling","title":"Introduction"},{"location":"time-series-modeling/index.html#time-series-modeling","text":"","title":"Time Series Modeling"},{"location":"time-series-modeling/dfm/index.html","text":"Dynamic Factor Models","title":"Introduction"},{"location":"time-series-modeling/dfm/index.html#dynamic-factor-models","text":"","title":"Dynamic Factor Models"},{"location":"time-series-modeling/dummy/index.html","text":"Estimation with Prior Dummies","title":"Introduction"},{"location":"time-series-modeling/dummy/index.html#estimation-with-prior-dummies","text":"","title":"Estimation with Prior Dummies"},{"location":"time-series-modeling/panel/index.html","text":"Panel VARs","title":"Introduction"},{"location":"time-series-modeling/panel/index.html#panel-vars","text":"","title":"Panel VARs"},{"location":"time-series-modeling/svar/index.html","text":"Structural VARs","title":"Introduction"},{"location":"time-series-modeling/svar/index.html#structural-vars","text":"","title":"Structural VARs"},{"location":"time-series-modeling/var/index.html","text":"Vector Autoregressions","title":"Introduction"},{"location":"time-series-modeling/var/index.html#vector-autoregressions","text":"","title":"Vector Autoregressions"}]}